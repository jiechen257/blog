---
title: DX 的发展与现状
categories: front-end
tags: ["DX", "local-first"]
abbrlink: 20270724
date: 2024-07-24
thumbnail: https://cdn.jsdelivr.net/gh/jiechen257/personal-gallery@main/img/202407242014806.png
---

- UX - `User Experience`，用户体验
- DX - `Developer Experience`，开发体验

## 从 UX 到 DX 的重心演变

当下的开发者有没有一种感觉（尤其常在推特上逛的开发者），近几年的开发过程中 DX 越来越好—— 体现在 `infra` 建设得越来越完善，与之对比的是，在 UX 上的优化影响愈发清淡，似乎是天秤上的两端重心发生了偏移

开发本身的出发点应当是做好产品，服务业务、服务消费者，为何 UX 的发展会演变成落后于 DX 的发展？

从我自身的观察、思考来说，有以下几点原因：

### UX 发展的边际递减效应

产品的 UX 体验优化程度已经趋近于边际、接近饱和，在没有出现革命性的技术创新前，UX 体验只能以相对越来越缓慢的速度演变

*强如 Apple 这种把用户体验放在一线的公司，近几年也在被用户吐槽发布的产品像是在挤牙膏*

### 降本增效的时代背景

经济大萧条的环境下，不管国内国外，各大互联网厂商都在降本增效

在这种时代背景下，公司对员工的生产力考量发生了转变：如何让员工贡献超出自身薪资的价值 -> 如何让一个员工能干两个员工的活，从而嘎掉另外一个

一个员工能干两个员工的活，自然只能从工作效率上入手(当然不乏有些牛马公司从工作时长上入手 😒

工作效率提升的出发点就是**提升 UX 体验**

### 新兴的工种-独立开发

> 这点本质上还是因为降本增效的时代背景，公司实行的广进计划(财源广进)
>
> 在这批流出的人才当中，存在很多技术狂热分子 —— 回过头看，可能也正是因为这些人深扎于自身关注技术的成长，少了人情世故的熏陶所以被噶(狗头.emoji

独立产品的目标用户一般都是开发者(在消费者业务上压根竞争不过大厂)，独立开发者自然对开发者体验有更深的投入

同样因为产品用户体量不大，独立开发者不需要关心技术的 side effect，也很乐意去尝试新兴技术栈

<hr />

聊完了 DX 过渡历程，我们再来看当下的 DX 发展到了一个怎样的程度

## DX 现状

### full-stack 趋势的愈演愈烈

像 Next.js、Nuxt.js 这样的全栈框架，集成了前端渲染、路由、状态管理、后端 API 等功能，使得开发者可以在一个统一的环境中进行全栈开发

- 数据库交互的简化
  - ORM 工具如 Prisma 的出现，开发者可以用类似 JavaScript 对象的方式来操作数据库，大大简化了数据库操作
- 部署和 DevOps 的简化
  - Vercel、Netlify 等平台的出现，简化了全栈应用的 CI、CD 过程
- 前后端全链路的 type safe
  - tRPC：前后端共享代码 / 运行时类型检测 / 二进制序列化

#### 众多云服务的集成

随着 Web 开发的复杂性增加,越来越多的云服务轮子被开发出来,以简化或直接省略特定模块的开发

这些云服务的封装和集成为开发者提供了强大的功能

- Convex: 实时后端服务
- Clerk: 用户认证和管理
- Liveblocks: 实时协作功能
- Stripe：支付功能

等等，还有很多

### Local-First Software 的火热

local-first 是一个很早就出现的技术性话题，正所谓 `技术大牛不一定掌握 CRDT，但掌握了 CRDT 的一定是技术大牛`

这里我们先看布道师(雪碧老师)的[推文](https://twitter.com/ewind1994/status/1813251128014086627)：

```txt
Local-first 正在变成一个 umbrella term，讲这个概念的人既可能是关心数据所有权的原教旨派，也可能是个 CRDT nerd，
还可能是单纯觉得本地 DB + sync engine 带来的全栈 reactivity 真香的 CRUD boy 
但 @localfirstconf 上的交流给我的启发是，它有机会这样演化成通用架构：

1. 设想你的新 linear/notion/figma……都直接做在本地 DB 上，换句话说全量数据都像 git 那样存在本地。这样 DX 非常爽，
因为更新 UI 的 reactivity 都能直接源于本地 DB，那些糊前后端接口的中间层全部不用管，你的 view 去订阅 DB 的 query 语句就能按需更新了

2. 但光有本地 DB 还不够，卖 SaaS 恰饭得有服务端啊。于是就有了所谓的 sync engine，
跟你承诺本地 DB 里放什么都能自动同步到服务端。它往往会在 DB 层用到 CRDT，但对上层基本是透明的，比如  @ElectricSQL 干的就是这个

3. 但你肯定还是不爽，因为首先如果我只分享 repo 里的一篇文档给你，凭什么要 clone 整个 DB 下来才能读？
其次服务端数据量可能无限大，但网页和移动端里的存储能力都很有限。所以这基本是对 local first 最大的质疑之一了

4. 但是别急，如果这个 sync engine 一等公民地内建了 partial sync 和分布式执行 query 的能力呢？
这样 web 端无非就是系统里存储上限很低（比如 100M）的 peer，始终按 LRU 之类策略存最热的数据就行，本地跑不完的 query 就一起在服务端查了送回来呗，反正各端都同构，UI 还是只管订阅更新就好

5. 这样一来，不论是强调 lazy loading 的 web 还是强调持有全量数据的 native client，大家的数据层就都是同构的，
只是同步数据量的上限不同而已。从而不管在哪，都能获得最优的加载行为和源自本地 DB 的响应式 DX

6. 这就是 local first 业界现在关注通用 sync engine 的原因。像 ZeroSync 最近演示的就是靠约 100M 的本地缓存做了个 linear，
大部分 UI 本地秒出，剩下的数据从服务端串流过来，API 也是带响应式的 Rx/LINQ 风格

7. 所以我是相信只要 UX 和 DX 都能更好，各种 SaaS 应用（而不仅是文档类）就没理由不用 local first 栈了呀。 
当然这背后整套基建目前业界做到的还很早期，包括  @AFFiNEOfficial 在内都是付了很多 pioneer tax 的。
但只要有兴趣折腾，现在这不就是一片蓝海吗
```

总结就是推导 local-first 的潜在演化方向：

- 本地数据库作为核心，提供良好的开发体验
- 同步引擎连接本地和服务端
- 解决数据共享和存储限制问题
- 引入部分同步和分布式查询执行
- 实现跨平台的同构数据层

## DX 的未来

*Undoubtedly, the future of DX is **AI***

![](https://cdn.jsdelivr.net/gh/jiechen257/personal-gallery@main/img/202407241855355.png)