{"title":"Go处理错误优雅化","date":"2023-11-04T16:00:00.000Z","date_formatted":{"ll":"Nov 5, 2023","L":"11/05/2023","MM-DD":"11-05"},"link":"post/59a5727bc82c","comments":true,"tags":["error"],"categories":["golang"],"updated":"2024-03-11T03:21:43.669Z","content":"<blockquote>\n<p>当前 Go 版本 1.17.5</p>\n</blockquote>\n<h2 id=\"go-的错误处理设计\">Go 的错误处理设计<a title=\"#go-的错误处理设计\" href=\"#go-的错误处理设计\"></a></h2>\n<p>关于 Go 的错误处理，一直争议不断。其实 Go 本身的争议也不少 😂。这里不进行评价，只是简单地和主流语言对比，总结一下 Go 的特征。</p>\n<p>作为一个历史悠久的语言，C 的错误处理非常混乱。典型情况下，C 通过返回值表示执行是否成功，至于失败的具体原因，通过额外的全局变量传递。这种设计的致命缺陷是错误与返回结果混淆在一起，例如函数 <code>int atoi(const char *str)</code> ，如果转换出错应该返回什么呢？0？-1？其实都不合理，因为任何数字都有可能代表一个正常的结果。</p>\n<p>为此，部分开发者选择利用指针传递结果，而返回值仅表示是否出错。这确实解决了上述问题，但又导致了「参数」语义的混淆。没有经验的同学看到什么入参出参搞的一脸懵比。</p>\n<p>而近现代语言通常采用 <code>try-catch</code> 的思想。例如 java 与 python。这种模型既分离的错误与返回值和参数，也提供了结构化处理的可能。通过面相对象的思想，开发者可以自定义错误类、子类，它们又可以包装其他错误，确保错误上下文不会丢失。</p>\n<hr>\n<p>Go 则与众不同。它利用多返回值的特性做到了错误的分离，因此，很多 Go 的函数最后一个返回值都是一个 <code>error</code> 来标识是否出错。相比于 C 这是一个进步，但没有提供灵活的捕获机制，这就仁者见仁智者见智了。</p>\n<p><strong>我个人的观点是：不应该试图在 A 语言中复刻 B 语言的功能，而是根据语言自身的特点，在宏观理念的指导下，实现针对性的错误处理方案。</strong> 后文将以这个观点为继续进行探索。</p>\n<h2 id=\"基本理念\">基本理念<a title=\"#基本理念\" href=\"#基本理念\"></a></h2>\n<p>虽然语法不同，但是一些语言无关的思想还是很重要的，我们应该尽量遵循。</p>\n<p>首先，一个错误信息，至少要具有两个作用：</p>\n<ol>\n<li>给程序看。可以根据错误类型进入处理分支。</li>\n<li>给人看。告诉我们到底发生了什么。</li>\n</ol>\n<h3 id=\"不要重复处理错误\">不要重复处理错误<a title=\"#不要重复处理错误\" href=\"#不要重复处理错误\"></a></h3>\n<p>私以为这是很容易踩的一个坑，考虑下面的代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span> (Result, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\"> result, err := repository.Find(id)</span><br><span class=\"line\"> <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">   log.Errof(err)</span><br><span class=\"line\">   <span class=\"keyword\">return</span> Result&#123;&#125;, err</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里打印了错误（相当于处理），然后返回它。可以想象，<code>foo()</code> 的调用方会再次打印，再返回。最终一个错误会打印出一大堆东西。</p>\n<h3 id=\"错误要包含调用栈\">错误要包含调用栈<a title=\"#错误要包含调用栈\" href=\"#错误要包含调用栈\"></a></h3>\n<p>调用栈是 debug 的基本需要。如果仅仅是一层层返回 error，那么最顶层的函数将收到最底层的错误。试想你用 Go 写了一个 web 后端，在处理一个支付请求时出现了 io 错误。这对 debug 毫无帮助——无法定位哪个环节出错。</p>\n<p>另一个不好的方案是，每一层只返回自己的错误，例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pay</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := checkOrder(); err!=<span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> errors.New(<span class=\"string\">&quot;支付异常&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">checkOrder</span><span class=\"params\">()</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := calcMoney(); err!=<span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> errors.New(<span class=\"string\">&quot;计算金额异常&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">calcMoney</span><span class=\"params\">()</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := querySql(); err!=<span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> errors.New(<span class=\"string\">&quot;查询数据库异常&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种情况和上一种相反：顶层函数只能得到最近的错误，对引发的原因一无所知，显然这不是我们希望的。</p>\n<h3 id=\"错误要是结构化的\">错误要是结构化的<a title=\"#错误要是结构化的\" href=\"#错误要是结构化的\"></a></h3>\n<p>有聪明的同学改造了一下代码来解决丢失调用栈的问题：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">checkOrder</span><span class=\"params\">()</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := calcMoney(); err!=<span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;计算金额异常：%s&quot;</span>, err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>确实，修改后顶层函数得到的异常如下：</p>\n<blockquote>\n<p>支付异常：计算金额异常：查询数据库异常</p>\n</blockquote>\n<p>现在基本上可以看出调用栈了，<strong>但仅限于人类</strong>。这个错误是否属于数据库异常？计算机无从得知。<s>我们可以通过自然语言处理来解决</s>，除非你疯了。</p>\n<p>所以需要结构化错误——错误有包含关系，子错误是父错误的一种，顶层函数可以轻松判断异常类型。</p>\n<h3 id=\"错误要有上下文\">错误要有上下文<a title=\"#错误要有上下文\" href=\"#错误要有上下文\"></a></h3>\n<p>这一点很好理解了，我们希望错误日志包含一些相关的数据，比如用户 id，订单 id 等。</p>\n<p>值得注意的是，这个原则要和「不重复处理」结合，否则将会得到这样的天书 log：</p>\n<blockquote>\n<p>支付异常 uid=123, orderId=456, reqId=328952104：计算金额异常 uid=123, orderId=456, reqId=328952104：查询数据库异常 uid=123, orderId=456, reqId=328952104</p>\n</blockquote>\n<h2 id=\"实践\">实践<a title=\"#实践\" href=\"#实践\"></a></h2>\n<h3 id=\"错误链\">错误链<a title=\"#错误链\" href=\"#错误链\"></a></h3>\n<p>曾经，在 Go 中做到保留调用栈和结构化是很麻烦的，为此 <a href=\"https://github.com/pkg/errors\" target=\"_blank\">errors</a> 开源库被广泛使用。不过 Go 1.13 一定程度上增强了错误处理，Go 2 也计划进一步改善。因此这个库已进入维护状态。</p>\n<p>现在，调用栈不再需要我们自己构造，通过 <code>fmt.Errorf(&quot;... %w&quot;, ..., err)</code> 就可以包装一个错误，层层套娃形成错误链。相应的，通过 <code>errors.Is()</code> 或 <code>errors.As()</code> 可以判断一个错误（链）是否是（包含）另一个错误，前者要求严格相等，后者只需类型一致。不知不觉中，「结构化」也基本上实现了。</p>\n<p>等等！为什么说「基本」？虽然标准库提供了判断错误类型的方法，但是错误类型是啥？相比 java 中抛出一个具体异常，Go 中基本上只会返回底层错误接口 <code>error</code>，而没有具体结构体，那怎么判断呀？难道又要回到 <code>err.msg</code> 的时代？当然不是，包装一个错误，除了使用 <code>fmt</code> 之外，还可以自己定义一个结构体。实际上，<code>fmt.Errorf()</code> 返回的是 <code>wrapError</code>，相当于是便捷函数，用于无需明确错误类型的场景。</p>\n<h3 id=\"自定义结构体\">自定义结构体<a title=\"#自定义结构体\" href=\"#自定义结构体\"></a></h3>\n<p>自定义错误结构体不仅帮助识别错误类型，还顺便解决了下上下文问题。通过简单的 string 自然是 OK 的，不过为了让上下文本身也可以被程序识别，更好的办法是作为结构体的一个字段：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> orderError <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  orderId <span class=\"type\">int</span></span><br><span class=\"line\">  msg <span class=\"type\">string</span></span><br><span class=\"line\">  err <span class=\"type\">error</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *orderError)</span></span> Error() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> e.msg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *orderError)</span></span> Unwrap() <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> e.err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个结构体不仅实现了 error 接口，还额外拥有 <code>Unwrap()</code> 方法，这样就可以包装其他异常，确保不丢失调用栈。</p>\n<p>那么就可以这么来返回：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">checkOrder</span><span class=\"params\">()</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := calcMoney(); err!=<span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">return</span> orderError&#123;<span class=\"number\">123</span>, <span class=\"string\">&quot;计算金额异常&quot;</span>, err&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"公开-or-私有\">公开 OR 私有<a title=\"#公开-or-私有\" href=\"#公开-or-私有\"></a></h3>\n<p>有了自己的结构体，随之而来的就是它需要公开吗？这个问题标准库已经给出了答案：一般不需要。所以我们见到的大多数函数，只返回 <code>error</code> 而不是 <code>xxxError</code>。根据网上的资料，这么做旨在隐藏实现细节，提高 lib 的灵活性，减少升级时需要考虑的兼容问题。</p>\n<p>不公开结构体，也就是意味着外部无法通过 <code>errors.As()</code> 判断了，为此，需要公开一个函数帮助外部确认这是否是属于本 lib 的错误。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">IsOrderError</span><span class=\"params\">(err <span class=\"type\">error</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> errors.As(err, orderError)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"error-check-hell\">Error Check Hell<a title=\"#error-check-hell\" href=\"#error-check-hell\"></a></h2>\n<p>上面已经总结了返回错误的结构，符合一开始提出的基本理念。在实际代码中，错误检查可能会充斥着项目，甚至每一个调用都裹着一个 <code>if</code> 来及时打断并返回——因为 Go 没有 throw 或 raise 机制。看下面这个恶心的例子：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">checkPersion</span><span class=\"params\">(*p Persion)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := checkAttr(p.name); err != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := checkAttr(p.age); err != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := checkAttr(p.country); err != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := checkAttr(p.work); err != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"抽取匿名函数\">抽取匿名函数<a title=\"#抽取匿名函数\" href=\"#抽取匿名函数\"></a></h3>\n<blockquote>\n<p>此方法适用于连续调用同一个函数。</p>\n</blockquote>\n<p>把错误检查抽取到匿名函数中，若已经存在错误，那么不真正执行，直接返回。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">checkPersion</span><span class=\"params\">(*p Persion)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> err <span class=\"type\">error</span></span><br><span class=\"line\">  check := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(attr <span class=\"keyword\">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    err = checkAttr(attr)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  check(p.name)</span><br><span class=\"line\">  check(p.age)</span><br><span class=\"line\">  check(p.country)</span><br><span class=\"line\">  check(p.work)</span><br><span class=\"line\">  <span class=\"comment\">// more check</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"利用-panic\">利用 panic<a title=\"#利用-panic\" href=\"#利用-panic\"></a></h3>\n<blockquote>\n<p>⚠️ 使用 panic 来代替 error 是错误的习惯。不要滥用此技巧。</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// checkAttr() 不再返回 error 而是直接 panic</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">checkAttr</span><span class=\"params\">(attr <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> attr == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(checkErr&#123;...&#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">checkPersion</span><span class=\"params\">(*p Persion)</span></span> (err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> r := <span class=\"built_in\">recover</span>(); r != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 恢复 checkAttr() 的 panic 转为 error</span></span><br><span class=\"line\">      err = r.(checkErr)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// do any thing</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>用 panic 简化 check 的关键在于 recover 时只处理已知的错误，对于未知情况应该继续传递 panic。因为 panic 原则上仅用于不可恢复的严重错误（例如数组越界），如果不分情况一律 recover 则可能会掩盖 bug 引发未知的后果。</p>\n<p>有的网站给出下面这种写法，非常不推荐，除非你知道自己在干嘛：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">checkPersion</span><span class=\"params\">(*p Persion)</span></span> (err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> r := <span class=\"built_in\">recover</span>(); r != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> ok <span class=\"type\">bool</span></span><br><span class=\"line\">      <span class=\"comment\">// 这里对于未知错误也一并捕获了</span></span><br><span class=\"line\">      err, ok = r.(<span class=\"type\">error</span>)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">        err = fmt.Errorf(<span class=\"string\">&quot;failed to check persion: %v&quot;</span>, r)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">  <span class=\"comment\">// do something thing</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>尽管很多网站都宣传不要滥用 panic，但我认为，如果像第一个例子那样，确保自己只捕获已知的异常来简化 error check，应该不算做滥用——此时 panic 不会对包外部的调用者造成任何影响——原来会 panic 的现在依然会 panic，原来会返回 error 的现在依然只返回 error。Go 的官方文档 <a href=\"https://go.dev/doc/effective_go\" target=\"_blank\">effective go</a> 也承认了这种用法：</p>\n<blockquote>\n<p>With our recovery pattern in place, the <code>do</code> function (and anything it calls) can get out of any bad situation cleanly by calling <code>panic</code>. We can use that idea to simplify error handling in complex software.</p>\n</blockquote>\n<p>有了 recovery 模式，我们就可以随时通过调用 panic 简单地摆脱异常情况，可以使用该思想来简化复杂软件中的错误处理。</p>\n<h2 id=\"转载\">转载<a title=\"#转载\" href=\"#转载\"></a></h2>\n<ul>\n<li><a href=\"https://chenhe.me/post/go-handle-errors-gracefully/\" target=\"_blank\">Go 优雅地处理错误</a></li>\n</ul>\n","prev":{"title":"RSS - 高效率的阅读方式","link":"post/9e0760493a64"},"next":{"title":"T3-Stack组合拳","link":"post/85996fbf0018"},"plink":"https://becase.top/post/59a5727bc82c/","toc":[{"id":"go-的错误处理设计","title":"Go 的错误处理设计","index":"1"},{"id":"基本理念","title":"基本理念","index":"2","children":[{"id":"不要重复处理错误","title":"不要重复处理错误","index":"2.1"},{"id":"错误要包含调用栈","title":"错误要包含调用栈","index":"2.2"},{"id":"错误要是结构化的","title":"错误要是结构化的","index":"2.3"},{"id":"错误要有上下文","title":"错误要有上下文","index":"2.4"}]},{"id":"实践","title":"实践","index":"3","children":[{"id":"错误链","title":"错误链","index":"3.1"},{"id":"自定义结构体","title":"自定义结构体","index":"3.2"},{"id":"公开-or-私有","title":"公开 OR 私有","index":"3.3"}]},{"id":"error-check-hell","title":"Error Check Hell","index":"4","children":[{"id":"抽取匿名函数","title":"抽取匿名函数","index":"4.1"},{"id":"利用-panic","title":"利用 panic","index":"4.2"}]},{"id":"转载","title":"转载","index":"5"}],"reading_time":"2634 words in 18 min"}