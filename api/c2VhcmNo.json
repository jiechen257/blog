[{"title":"Markdown的前生今世","date":"2023-12-17T13:47:50.000Z","date_formatted":{"ll":"Dec 17, 2023","L":"12/17/2023","MM-DD":"12-17"},"updated":"2024-03-11T03:21:43.671Z","content":"\n如果你是一位笔记爱好者，同时又从事编程相关工作，那自然听说或使用过 \bMarkdown\n笔者在刚接触编程时，有专门分析过 \bMarkdown 的技术实现，时间转眼过去一两年，已经是一名深度的 \bMarkdown 使用用户，所有的文档笔记和 ssg 博客内容都是出自于 \bMarkdown…\n现在回过头来看，不禁想挖掘 \bMarkdown 的发展历史，顺便将以前的技术分析统一成文，方便后续思考\n\n主要人物\n作者 - John Gruber\nJohn Gruber 出生于费城，获得了德雷克赛尔大学计算机科学学士学位，曾先后供职于  Bare Bones Software  和 Joyent。John Gruber 在 2002 年创建了个人博客  Daring Fireball，核心内容是关于苹果公司的各类信息。\n\n\n关于这位老哥的故事还可以多说几句，他自 2006 年开始全职经营博客。他同时主持一档名为  The Talk Show  的播客节目。最近几年的 WWDC 大会期间，The Talk Show 都会邀请到苹果高管进行面对面。苹果高级副总裁  Phil Schiller 、Eddy Cue 、 Craig Federighi，苹果 AR 负责人 Mike Rockwell，销售主管 Greg Joswiak 在 WWDC 2015 - 2018 期间先后在 The Talk Show 上亮相\n\nJohn Gruber 在  Daring Fireball: Dive Into Markdown  中写到在还没有 Markdown 的当年，用 BBEdit 编辑和预览 HTML 并拷贝到  Movable Type  发布的不愉快经历。这种不爽的体验促使他做出改变，为了更好地进行博客写作，两年后（2004 年）他发布了一个叫 Markdown 的工具\n布道者 - Jeff Atwood\nJeff Atwood  软件工程师。先后创建了著名的编程问答网站  Stack Overflow  和开源论坛软件  Discourse\n前者是程序员解决问题三大件之一，另外两个是 Google 和 Github；而后者是目前首选的架设论坛的开源软件\nJeff 在 Markdown 发布的同一年开始自己的博客  Coding Horror。再该博客中，他表示自己是 Markdown 忠实铁粉，记录了他如何在早期的 Stack Overflow 使用 Markdown 的语法用于书写问题和答案（Discourse 的也是集成 Markdown\n\n发展历史\n2004 - Markdown 起源\n2004 年 3 月，John Grube 发表了第一篇关于 Markdown 文章  Daring Fireball: Introducing Markdown，开始公开测试 Markdown\n同年 8 月正式发布 Markdown 1.0\n在 2004 年 12 月更新到 1.0.1 版本，修复了一些缺陷。同时把 license 由 1.0 版本的 GPL 修改为更宽松的 BSD-style license\n自此，John Gruber 再也没有更新过 Markdown ，不论是用 Perl 编写用于转换为 HTML 的工具，还是 Markdown 的语法规则\n2007 - ## Pandoc\nPandoc  是 John MacFarlane 开发的一款万能文档转换工具。Pandoc 可以在几十种文档格式之间相互转换。Pandoc 早期就加入对 Markdown 格式的支持。这使得会有更多早期的用户尝试 Markdown 工具写作\n2008 - Stack Overflow\n2008 年，Stack Overflow  的联合创始人  Jeff Atwood  选定 Markdown 作为 Stack Overflow 用户编写和回答问题的语法方案。经过一年半的实践，Jeff Atwood 在  Responsible Open Source Code Parenting 说到:\n\nI’m a big fan of John Gruber’s Markdown. When it comes to humane markup languages for the web, I don’t think anyone’s quite nailed it like Mr. Gruber. His philosophy was clear from the outset. 我是 Markdown 的忠实铁粉。说到网页人性化的标记语言时，我认为没有人可以像 Gruber 先生那样优秀。在一开始他的思路就非常明确。\n\n\nWith a year and a half of real world Markdown experience under our belts on Stack Overflow, we’ve been quite happy. I’d say that Markdown is the worst form of markup except for all the other forms of markup that I’ve tried. Stack Overflow 线上使用 Markdown 一年半之后，我们感到相当满意。我必须得说， Markdown 是最糟糕的标记形式，除了其他所有我已经试过的。\n\n\nOn 15 Mar 2008, at 02:55, John Gruber wrote: I despise what you’ve done with Text::Markdown, which is to more or less make it an alias for MultiMarkdown, almost every part of which I disagree with in terms of syntax additions.\n\nJohn Gruber 对 Markdown 社区的态度极其冷淡。Jeff Atwood 对此感到非常失望\nJeff Atwood 是最热心的 Markdown 布道者，用他的影响力不断地向世人阐述使用 Markdown 的好处；同时 Jeff Atwood 埋怨 John Gruber 对 Markdown 的发展毫不关心\n因 Stack Overflow 的影响力，Markdown 逐渐开始在程序员的世界里流行起来。\n2009 - Github Flavored Markdown\nGithub 大约在 2009 年开始使用 Markdown 1.0 的派生版本  GitHub Flavored Markdown (GFM)。其中最主要区别在于以下两点：\n\n段落换行的界定：Github 认为一个换行符（回车键）即为新起一个段落更符合人们的预期。Markdown 1.0 则需要一行空白行（两个回车键）。我深刻理解 Github 的努力，因为我第一次使用 Stack Overflow 时也为此感到困惑过。\n下划线用来分割多个单词表示一个整体时，不应该处理为斜体\n\n\n2012 - who’s with me?\nJeff 在  The Future of Markdown  中提议 Stack Exchange、GitHub、Meteor 和 Reddit 等其他有一定访问量的网站一起努力制定出 Markdown 标准规范和用于测试 Markdown 实现的标准测试用例。Jeff 希望这个标准规范主要内容包含：\n\n把 John Gruber 的 Markdown 文档用正式的语言规范进行标准化；\n提供三个可选项，且给予更稳妥的默认值：a) 默认关闭在单词内部的强调标记；b) 默认打开自动添加超链接；c) 默认打开回车键即换行；\n验证 Markdown 实现的一组测试用例；\n对 Markdown 中存在边界模糊的情况进行清理和调整；\n对 Markdown 不同流行版本的处理。\n\nJeff 便在这个时候开始组建工作小组，成员列表如下：\n\nJohn MacFarlane, jgm@berkeley.edu\nDavid Greenspan, david@meteor.com\nVicent Marti, vicent@github.com\nNeil Williams, neil@reddit.com\nBenjamin Dumke-von der Ehe, ben@stackexchange.com\nJeff Atwood, jatwood@codinghorror.com\n\n2014 - Standard Markdown &amp; CommonMark\nJeff 所组建的工作小组经过两年的努力，在 2014 年 9 月发布名为  Standard Markdown  的项目。因 John Gruber 反对这个名称，Jeff 将这个项目名称修改为  CommonMark。CommonMark 规范主要由 Pandoc 的作者 John MacFarlane 编写，其中包含了 624 个测试用例，C 和 JavaScript 的规范实现。\n2016 - text/Markdown\n互联网技术标准制定机构 IETF 发布  RFC 7763 - The text/Markdown Media Type  和  RFC 7764 - Guidance on Markdown  两份征求意见稿，收录 Markdown 格式作为互联网媒体标准格式 text/Markdown。同时为了区分不同 Markdown 版本，提供一个可选参数 variant=Identifer。RFC7764 中收录了不同 Markdown 版本 Identifier 的值，同时指出不同版本之间的区别：\n\ntext/Markdown  或  text/Markdown; variant=Original John Gruber 发布的最原始版本；\ntext/Markdown; variant=MultiMarkdown MultiMarkdown；\ntext/Markdown; variant=GFM GitHub Flavored Markdown；\ntext/Markdown; variant=pandoc Pandoc；\ntext/Markdown; variant=Fountain Fountain；\ntext/Markdown; variant=CommonMark CommonMark；\ntext/Markdown; variant=kramdown-rfc2629 Markdown for RFCs；\ntext/Markdown; variant=rfc7328 Pandoc2rfc；\ntext/Markdown; variant=Extra PHP Markdown Extra。\n\n2017 - GitHub Flavored Markdown Spec\nGitHub Flavored Markdown 基于 CommonMark Spec 发布了自己 spec，支持表格、任务列表和删除线，禁止 HTML 原始标签。测试用例从 624 个增加到 651 个。\n现在\nMarkdown 已经是事实上的无处不在。也是诸多笔记和写作软件首选支持的格式\nJohn Gruber 为了方便更新他的博客，发布了 Markdown。但在此后的 10 多年里，他再也没有更新 Markdown，他的博客里在这之后也几乎看不到关于 Markdown 的只言片语\n而另外一个人，却十年如一日地爱着 Markdown，在他的 Stack Overflow 和 Discourse 中使用 Markdown，并长期有组织地推广 Markdown。\n我们记住 Markdown 的创造者 John Gruber 的同时，也一并铭记 Jeff Atwood 为 Markdown 做出的巨大努力。\n技术原理\n就当下的 Markdown 主流版本做的分析\ntypora\n大家都知道在 md 界中一个叫 typora 的软件，以其实时预览的功能广各位 coder 欢迎，typora 如何使用不再过多介绍\n核心技术点：Electron + node 技术栈\n\nElectron 是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。 嵌入 Chromium 和 Node.js 到 二进制的 Electron 允许您保持一个 JavaScript 代码代码库并创建 在 Windows 上运行的跨平台应用 macOS 和 Linux——不需要本地开发 经验。\n参考：简介 | Electron\n\n如上所说 typora 的显示，其实本质上还是以 html 网页的形式呈现，但是因为 electron 的技术实现，使得在 app 底座上能够显示 html 的内容\nvscode 的 md 功能\n本质上与 typora 一样，因为 vscode 本身也是用 typescript + electron 实现的桌面端 app\n预览\n通过 vscode.window.createWebviewPanel 创建一个 webview，指定在侧边打开，之后通过该 panel 对象的 webview.html 属性来设置 html。\nhtml 是通过编辑器的 Markdown 内容生成的， 编辑器内容通过 editor.document.getText() 拿到，然后调用第三方的 Markdown 转 html 的库来生成。\n这样就完成了 Markdown 的预览。\n编辑+更新\n预览之后需要更新，监听 vscode.workspace.onDidSaveTextDocument 和 vscode.workspace.onDidChangeTextDocument 的事件，在文档更新和保存的时候，拿到编辑器的内容，重新生成 html，然后设置到 webview。\nwebviewPanel 支持 webview.postMessage(message); 的方式传递消息，支持 updateHTML 等一系列 command，可以通过传递消息来触发。\n\n但是怎么知道哪个文档更新哪个 webview 呢？\n\n可以维护一个 map，在创建 webviewPanel 的时候记录到 map 中，key 为文件路径，这样更新的时候就能查找到对应的 webview 进行更新。\n这样，就完成了 Markdown 内容的更新。\n实时预览\n这里把 typora 的实时预览单独拿出来介绍下，毕竟 typora 的大火除了其自身界面简介友好，还有其实时预览的功能\n实时预览就是用 md 语法写完一个语法块，页面内容就能渲染出来\n实现思路：\n\n监听 input 输入\n在 debounce 处理（防抖）之后调用 md parser 进行实时解析\n渲染到对应位置上\n\n其实实现思路也很直观，并不是什么惊奇的 idea\n参考\n\nMarkdown - Wikipedia\nMarkdown 发展史\nThe Markdown Movement\nJohn Gruber - Wikipedia\nJeff Atwood - Wikipedia\nvscode 中 markdown 预览的实现原理 \nmarkdown-it-analysis · GitHub\n\n","plink":"https://becase.top/post/8aed14ccdc07/"},{"title":"RSS - 高效率的阅读方式","date":"2023-11-29T16:00:00.000Z","date_formatted":{"ll":"Nov 30, 2023","L":"11/30/2023","MM-DD":"11-30"},"updated":"2024-03-11T03:21:43.672Z","content":"背景\n如果你经常逛一些博客网站，会发现他们的头部 tab 常常带有一个 RSS 的内容区域，长这样\n\n如：mdhweekly.com/weekly\n\n再如： 云原生实验室\n\n点进去一看，就是满满的一屏又一屏的 xml文件\n\n这是什么东西？用来做什么？\n介绍\n先看维基百科：RSS\n\nRSS（英文全称：RDF Site Summary 或 Really Simple Syndication），中文译作简易信息聚合，也称聚合内容**，是一种消息来源格式规范，用以聚合多个网站更新的内容并自动通知网站订阅者。使用 RSS 后，网站订阅者便无需再手动查看网站是否有新的内容，同时 RSS 可将多个网站更新的内容进行整合，以摘要的形式呈现，有助于订阅者快速获取重要信息，并选择性地点阅查看\n\n通俗来说，就是一个网站支持 RSS，就意味着每当它新发布一篇新文章，就会往一个位于特定网址的文件中，以特定的语法（具体而言是 XML 标记语言或 JSON）增加一条记录，列明这篇文章的标题、作者、发表时间和内容（可以是全文，也可以是摘要）等信息\n这样，用户只要搜集所有他感兴趣的网站提供的这种文件的网址，并不时检查这些文件内容的更新，就能知道这些网站是否、何时发布了什么内容\n比如，当我关注的某个人在知乎、或者在博客上回答了一个问题、写了一篇新文章，我马上就能收到推送。当我关注的人变多了，我不必一一点开知乎、简书、甚至翻看博客去主动获取更新，而是在一个统一的终端内阅读\n如何（获取 or 制作）网站的 RSS\n如何判断一个网站有无 RSS，首先在网站里寻找这个标识：\n\n如果有的话，可以直接拷贝链接订阅。 没有标识呢？也可能是有 RSS 的，不过藏得比较深。\n简单的方法是：直接在主域名后加 /feed ， /rss 或 /atom.xml 比如博客：yxrct.com 在后面加 /feed 变为 yxrct.com/feed ，如果能刷出来一个xml页面，那么只需添加这个链接到 RSS 阅读器中，即可订阅。 但一些网站并不用普通的后缀，这时候我们需要用到 RSS+ 浏览器插件。\nRSS+ 浏览器插件：\n\n先安装 油猴插件 ，这里需要科学上网。\n再安装 RSS+ 脚本\n此时，如果网站有 RSS，可在右下角小圆圈里发现。\n\n对无 RSS 的网站，需要自己制作 RSS，这里推荐几个工具：\n\nfeed43\nRSSHub\nFeedOcean\n\n以上的工具，不仅可以订阅无 RSS 的博客，还能直接订阅知乎专栏、公众号、微博、贴吧、即刻等；具体方法参见文档\n如何使用 RSS\n从直观上来看这就是一连串的 xml标签，所以通常是借助工具来转译成可阅读文本，这种工具统称为 RSS阅读器\nInoreader\nInoreader \n免费版基础功能完善，抓取时间大概15分钟，符合要求。有网页版、iOS、Android 版本。\n添加 RSS 地址后，便能直接抓取内容转为可阅读内容\n\n\nReabble\nReabble\n基于 Inoreader 的 API 开发，为 Kindle 而生。建议升级收费版（年费 ¥21，免费版 7 篇文章 / 天，且不支持推送） 我设置每天 9 点定时推送新文章至 Kindle 阅读，也方便标注 &amp; 导出书摘。 若想在电脑上阅读，也可以直接打开 reabble.com ，创建桌面快捷方式，界面比 Inoreader 简洁且无广告。\n详细使用略…\n关于 RSS 的一些思考\nRSS 并不适合订阅新闻类网站，刷新太快、内容繁琐反而导致阅读体验不佳\n所以 RSS 更适合订阅高质量博客之类的网站。订阅源并不是越多越好，应该小而精。过多的订阅源会引起「信息过载」，你会发现自己每天都收到数以百计的新资讯，却无暇阅读\n\n在网上获取信息时，可以中二一点把自己想象成古代听取群臣意见的帝王。对于皇帝来说，最危险和最不该做的事情就是暴露自己的喜好，这是被臣下蒙蔽乃至最后被夺权篡位的基础。英明的皇帝会保持内心的虚静无为（客观中立），坚持单独听取各方意见而不暴露自己的感想，并将各方意见与客观事实一一验证来确认各自的可信度。这也是几千年后每个人获取信息时应该坚守的原则。挑选信息来源也是最值得花时间的地方\n\n参考\n\nRSS - 维基百科，自由的百科全书\nRSS - 高效率的阅读方式\n\n","plink":"https://becase.top/post/9e0760493a64/"},{"title":"Go处理错误优雅化","date":"2023-11-04T16:00:00.000Z","date_formatted":{"ll":"Nov 5, 2023","L":"11/05/2023","MM-DD":"11-05"},"updated":"2024-03-11T03:21:43.669Z","content":"\n当前 Go 版本 1.17.5\n\nGo 的错误处理设计\n关于 Go 的错误处理，一直争议不断。其实 Go 本身的争议也不少 😂。这里不进行评价，只是简单地和主流语言对比，总结一下 Go 的特征。\n作为一个历史悠久的语言，C 的错误处理非常混乱。典型情况下，C 通过返回值表示执行是否成功，至于失败的具体原因，通过额外的全局变量传递。这种设计的致命缺陷是错误与返回结果混淆在一起，例如函数 int atoi(const char *str) ，如果转换出错应该返回什么呢？0？-1？其实都不合理，因为任何数字都有可能代表一个正常的结果。\n为此，部分开发者选择利用指针传递结果，而返回值仅表示是否出错。这确实解决了上述问题，但又导致了「参数」语义的混淆。没有经验的同学看到什么入参出参搞的一脸懵比。\n而近现代语言通常采用 try-catch 的思想。例如 java 与 python。这种模型既分离的错误与返回值和参数，也提供了结构化处理的可能。通过面相对象的思想，开发者可以自定义错误类、子类，它们又可以包装其他错误，确保错误上下文不会丢失。\n\nGo 则与众不同。它利用多返回值的特性做到了错误的分离，因此，很多 Go 的函数最后一个返回值都是一个 error 来标识是否出错。相比于 C 这是一个进步，但没有提供灵活的捕获机制，这就仁者见仁智者见智了。\n我个人的观点是：不应该试图在 A 语言中复刻 B 语言的功能，而是根据语言自身的特点，在宏观理念的指导下，实现针对性的错误处理方案。 后文将以这个观点为继续进行探索。\n基本理念\n虽然语法不同，但是一些语言无关的思想还是很重要的，我们应该尽量遵循。\n首先，一个错误信息，至少要具有两个作用：\n\n给程序看。可以根据错误类型进入处理分支。\n给人看。告诉我们到底发生了什么。\n\n不要重复处理错误\n私以为这是很容易踩的一个坑，考虑下面的代码：\n12345678func foo() (Result, error) &#123; result, err := repository.Find(id) if err != nil &#123;   log.Errof(err)   return Result&#123;&#125;, err &#125;  return result, nil&#125;\n这里打印了错误（相当于处理），然后返回它。可以想象，foo() 的调用方会再次打印，再返回。最终一个错误会打印出一大堆东西。\n错误要包含调用栈\n调用栈是 debug 的基本需要。如果仅仅是一层层返回 error，那么最顶层的函数将收到最底层的错误。试想你用 Go 写了一个 web 后端，在处理一个支付请求时出现了 io 错误。这对 debug 毫无帮助——无法定位哪个环节出错。\n另一个不好的方案是，每一层只返回自己的错误，例如：\n1234567891011121314151617181920func pay()&#123;  if err := checkOrder(); err!=nil &#123;    return errors.New(&quot;支付异常&quot;)  &#125;  return nil&#125;func checkOrder() error &#123;  if err := calcMoney(); err!=nil &#123;    return errors.New(&quot;计算金额异常&quot;)  &#125;  return nil&#125;func calcMoney() error &#123;  if err := querySql(); err!=nil &#123;    return errors.New(&quot;查询数据库异常&quot;)  &#125;  return nil&#125;\n这种情况和上一种相反：顶层函数只能得到最近的错误，对引发的原因一无所知，显然这不是我们希望的。\n错误要是结构化的\n有聪明的同学改造了一下代码来解决丢失调用栈的问题：\n123456func checkOrder() error &#123;  if err := calcMoney(); err!=nil &#123;    return fmt.Errorf(&quot;计算金额异常：%s&quot;, err)  &#125;  return nil&#125;\n确实，修改后顶层函数得到的异常如下：\n\n支付异常：计算金额异常：查询数据库异常\n\n现在基本上可以看出调用栈了，但仅限于人类。这个错误是否属于数据库异常？计算机无从得知。我们可以通过自然语言处理来解决，除非你疯了。\n所以需要结构化错误——错误有包含关系，子错误是父错误的一种，顶层函数可以轻松判断异常类型。\n错误要有上下文\n这一点很好理解了，我们希望错误日志包含一些相关的数据，比如用户 id，订单 id 等。\n值得注意的是，这个原则要和「不重复处理」结合，否则将会得到这样的天书 log：\n\n支付异常 uid=123, orderId=456, reqId=328952104：计算金额异常 uid=123, orderId=456, reqId=328952104：查询数据库异常 uid=123, orderId=456, reqId=328952104\n\n实践\n错误链\n曾经，在 Go 中做到保留调用栈和结构化是很麻烦的，为此 errors 开源库被广泛使用。不过 Go 1.13 一定程度上增强了错误处理，Go 2 也计划进一步改善。因此这个库已进入维护状态。\n现在，调用栈不再需要我们自己构造，通过 fmt.Errorf(&quot;... %w&quot;, ..., err) 就可以包装一个错误，层层套娃形成错误链。相应的，通过 errors.Is() 或 errors.As() 可以判断一个错误（链）是否是（包含）另一个错误，前者要求严格相等，后者只需类型一致。不知不觉中，「结构化」也基本上实现了。\n等等！为什么说「基本」？虽然标准库提供了判断错误类型的方法，但是错误类型是啥？相比 java 中抛出一个具体异常，Go 中基本上只会返回底层错误接口 error，而没有具体结构体，那怎么判断呀？难道又要回到 err.msg 的时代？当然不是，包装一个错误，除了使用 fmt 之外，还可以自己定义一个结构体。实际上，fmt.Errorf() 返回的是 wrapError，相当于是便捷函数，用于无需明确错误类型的场景。\n自定义结构体\n自定义错误结构体不仅帮助识别错误类型，还顺便解决了下上下文问题。通过简单的 string 自然是 OK 的，不过为了让上下文本身也可以被程序识别，更好的办法是作为结构体的一个字段：\n12345678910111213type orderError struct &#123;  orderId int  msg string  err error&#125;func (e *orderError) Error() string &#123;    return e.msg&#125;func (e *orderError) Unwrap() error &#123;    return e.err&#125;\n这个结构体不仅实现了 error 接口，还额外拥有 Unwrap() 方法，这样就可以包装其他异常，确保不丢失调用栈。\n那么就可以这么来返回：\n123456func checkOrder() error &#123;  if err := calcMoney(); err!=nil &#123;    return return orderError&#123;123, &quot;计算金额异常&quot;, err&#125;  &#125;  return nil&#125;\n公开 OR 私有\n有了自己的结构体，随之而来的就是它需要公开吗？这个问题标准库已经给出了答案：一般不需要。所以我们见到的大多数函数，只返回 error 而不是 xxxError。根据网上的资料，这么做旨在隐藏实现细节，提高 lib 的灵活性，减少升级时需要考虑的兼容问题。\n不公开结构体，也就是意味着外部无法通过 errors.As() 判断了，为此，需要公开一个函数帮助外部确认这是否是属于本 lib 的错误。\n123func IsOrderError(err error) bool &#123;  return errors.As(err, orderError)&#125;\nError Check Hell\n上面已经总结了返回错误的结构，符合一开始提出的基本理念。在实际代码中，错误检查可能会充斥着项目，甚至每一个调用都裹着一个 if 来及时打断并返回——因为 Go 没有 throw 或 raise 机制。看下面这个恶心的例子：\n123456789101112131415func checkPersion(*p Persion) error &#123;  if err := checkAttr(p.name); err != nil&#123;    return err  &#125;  if err := checkAttr(p.age); err != nil&#123;    return err  &#125;  if err := checkAttr(p.country); err != nil&#123;    return err  &#125;  if err := checkAttr(p.work); err != nil&#123;    return err  &#125;  return nil&#125;\n抽取匿名函数\n\n此方法适用于连续调用同一个函数。\n\n把错误检查抽取到匿名函数中，若已经存在错误，那么不真正执行，直接返回。\n12345678910111213141516func checkPersion(*p Persion) error &#123;  var err error  check := func(attr interface&#123;&#125;)&#123;    if err != nil&#123;      return    &#125;    err = checkAttr(attr)  &#125;  check(p.name)  check(p.age)  check(p.country)  check(p.work)  // more check  return err&#125;\n利用 panic\n\n⚠️ 使用 panic 来代替 error 是错误的习惯。不要滥用此技巧。\n\n123456789101112131415161718// checkAttr() 不再返回 error 而是直接 panicfunc checkAttr(attr interface&#123;&#125;) &#123;  if attr == nil&#123;    panic(checkErr&#123;...&#125;)  &#125;&#125;func checkPersion(*p Persion) (err error) &#123;  defer func() &#123;    if r := recover(); r != nil &#123;      // 恢复 checkAttr() 的 panic 转为 error      err = r.(checkErr)    &#125;  &#125;()  // do any thing&#125;\n用 panic 简化 check 的关键在于 recover 时只处理已知的错误，对于未知情况应该继续传递 panic。因为 panic 原则上仅用于不可恢复的严重错误（例如数组越界），如果不分情况一律 recover 则可能会掩盖 bug 引发未知的后果。\n有的网站给出下面这种写法，非常不推荐，除非你知道自己在干嘛：\n12345678910111213func checkPersion(*p Persion) (err error) &#123;  defer func() &#123;    if r := recover(); r != nil &#123;      var ok bool      // 这里对于未知错误也一并捕获了      err, ok = r.(error)      if !ok &#123;        err = fmt.Errorf(&quot;failed to check persion: %v&quot;, r)      &#125;    &#125;  &#125;()  // do something thing&#125;\n尽管很多网站都宣传不要滥用 panic，但我认为，如果像第一个例子那样，确保自己只捕获已知的异常来简化 error check，应该不算做滥用——此时 panic 不会对包外部的调用者造成任何影响——原来会 panic 的现在依然会 panic，原来会返回 error 的现在依然只返回 error。Go 的官方文档 effective go 也承认了这种用法：\n\nWith our recovery pattern in place, the do function (and anything it calls) can get out of any bad situation cleanly by calling panic. We can use that idea to simplify error handling in complex software.\n\n有了 recovery 模式，我们就可以随时通过调用 panic 简单地摆脱异常情况，可以使用该思想来简化复杂软件中的错误处理。\n转载\n\nGo 优雅地处理错误\n\n","plink":"https://becase.top/post/59a5727bc82c/"},{"title":"T3-Stack组合拳","date":"2023-10-07T08:53:39.000Z","date_formatted":{"ll":"Oct 7, 2023","L":"10/07/2023","MM-DD":"10-07"},"updated":"2024-03-11T03:21:43.673Z","content":"背景\n在今年上半年 React 推出了 RSC，当时推特上一片谩骂（讽刺其梦回 PHP 时代），但同时，也间接的反映出 React 技术的发展自从 hooks 时代后一直没有什么声响\n\n虽然 React 一直在发展，但直到现在，twitter 上每天喷 React 的 useEffect 调用两次的 post 依然数不胜数 :P\n\n也是在那期间，横空出世的一套组合拳 T3 Stack 开始被广大 web dev 得知\n它是什么\n“T3 Stack” 是由 Theo↗ 创建的一个 web 开发技术栈，专注于简单性、模块化和全栈类型安全\n项目结构：\n123456789101112131415161718192021222324252627282930313233343536.├── README.md├── next-env.d.ts├── next.config.mjs├── package.json├── pnpm-lock.yaml├── postcss.config.cjs├── prettier.config.mjs├── prisma│   └── schema.prisma├── public│   └── favicon.ico├── src│   ├── env.mjs│   ├── pages│   │   ├── _app.tsx│   │   ├── api│   │   │   ├── auth│   │   │   │   └── [...nextauth].ts│   │   │   └── trpc│   │   │       └── [trpc].ts│   │   └── index.tsx│   ├── server│   │   ├── api│   │   │   ├── root.ts│   │   │   ├── routers│   │   │   │   └── example.ts│   │   │   └── trpc.ts│   │   ├── auth.ts│   │   └── db.ts│   ├── styles│   │   └── globals.css│   └── utils│       └── api.ts├── tailwind.config.ts└── tsconfig.json\n技术栈包括：\n\n核心部分是 Next.js↗ 和 TypeScript↗\nTailwind CSS↗ 作为 css 框架\ntRPC↗、Prisma↗ 和 NextAuth.js↗ 作为服务端技术内嵌其中\n\n对于这种上来就给你内嵌了几个轮子的框架，值得让人去思考这些轮子的意义 (为什么需要 -&gt; 解决了什么问题 or 带来了什么帮助）\n本篇博客就是通过对这些技术栈的介绍，来分析其背后的意义\n老生常谈的哥三儿\nTypeScript\n类型安全有多重要，懂的自然懂，不懂的…\nTailwind CSS\n原子化 CSS，懂的自然懂，不懂的…\nNext. js\nNext. js 本身是一门 SSR（服务端） 技术栈，反映了对 CSR（客户端渲染） 的优劣取舍\n作为 React 体系的 full-stack Web applications 代表作，Next. js 支持服务器渲染、静态生成和动态路由等功能，使开发人员能够构建高性能的 Web 应用程序\n常与 Next. js 摆在桌面上论道的是 Vue 体系的 Nuxt. js（且不说二者的实际开发体验，但就二者的官方文档比较来看，我单方面宣布 Next. js 胜出 dog.emoji）\n后起之秀\nPrisma —— 优化数据库的对接问题\n\n[!NOTE]\n对象关系映射（ORM）最早由 Java 中的 Hibernate 框架引入\n对象关系映射的最初目标是解决 Java 类和关系型数据库表之间的所谓阻抗不匹配问题。从这个想法发展出了更广泛的雄心勃勃的概念，即为应用程序提供一个通用的持久化层\nPrisma 是 Java ORM 层的现代 JavaScript 演进\n\n如果有过服务端开发经验自然对 ORM (Object-relational mapping) 并不陌生，而 Prisma 正是一个 TypeScript 写的 ORM 工具\n它相比传统 ORM 工具最大的优势在于：自动生成的模型和查询构建器（这意味着你不必手动编写查询语句或模型类，而是可以使用自动生成的 API 进行数据库操作）\n\n此外，支持多个数据库、现代异步 API、自动迁移和模式演化等等也是它众多的优点之一\ntRPC —— 保证前后端调用时的类型安全\n\nRPC（Remote Procedure Call）是一种通信协议和编程模型，用于实现分布式系统中不同计算机或进程之间的远程调用。它允许一个计算机程序调用另一个地址空间（通常是在远程机器上运行的）的过程或函数，就像调用本地过程一样，而不需要开发者显式处理网络通信和数据传输的细节\n\n正如同 tRPC 官网所说：The client below is **not** importing any code from the server, only its type declarations.\n\n相比于普通 RPC，tRPC 则是与 TypeScript 强绑定的一类 RPC\n\n类型安全：通过 tRPC，在编译和运行时，您可以确保输入和输出与您的 TypeScript 类型匹配。避免因参数改变而导致运行时崩溃是非常重要的。\n简易性：相比GraphQL，您不需要任何schemas或代码生成。您可以像平常一样编写函数，tRPC会顺利地处理其余部分。\n轻量级：tRPC是一个简单轻量的库，不会给您的应用程序增加过多的负担。它还支持以最小的延迟来流式传输数据\n\n对比 REST 范式\nREST 优势：\n\n熟悉性：你应该很熟悉 REST 吧？它是一种简单的 HTTP 协议，已经广为人知很长时间了。它是经典的网页开发协议。\n兼容性：REST可以与支持HTTP请求的任何语言或平台简单地配合使用。它也与现有的工具和框架（如Swagger或Postman）很好地集成。\n简单性：REST不需要任何特殊的语法或库来使用。你只需要遵循一些命名URL和方法的约定即可\n\nREST 劣势：\n\n容易冗长：你是否曾经处理过复杂或嵌套的数据结构？你可能需要进行多次请求或在网络上发送不必要的数据。\n不一致性：由于它没有标准的方式来定义或文档化API模式，这可能很快变得麻烦。如果你不是独立工作，你的同事可能会使用不同的样式或格式来编写他们的API，导致混乱或错误。\n效率低下：没有方便的过滤、排序或分页功能。你可能需要为每个用例创建新的端点或参数，这可能会增加API的复杂性\n\nNextAuth . js —— 集成在 Next. js 中的身份验证中间件\n\nNextAuth. js is a complete open-source authentication solution for Next.js applications.\nIt is designed from the ground up to support Next. js and Serverless.\n\nNextAuth. js 简化了身份验证和授权流程的开发，提供了一种快速、安全和灵活的方式来添加用户认证功能到 Next. js 应用程序中\n初始化注入：\n123456789101112131415161718192021222324252627282930// init.tsimport NextAuth from &quot;next-auth&quot;import GithubProvider from &quot;next-auth/providers/github&quot;export const authOptions = &#123;  // Configure one or more authentication providers  providers: [    GithubProvider(&#123;      clientId: process.env.GITHUB_ID,      clientSecret: process.env.GITHUB_SECRET,    &#125;),    // ...add more providers here  ],&#125;export default NextAuth(authOptions)// provider.tsimport &#123; SessionProvider &#125; from &quot;next-auth/react&quot;export default function App(&#123;  Component,  pageProps: &#123; session, ...pageProps &#125;,&#125;) &#123;  return (    &lt;SessionProvider session=&#123;session&#125;&gt;      &lt;Component &#123;...pageProps&#125; /&gt;    &lt;/SessionProvider&gt;  )&#125;\n使用：\n123456789101112131415161718192021222324252627282930313233343536373839// front-endimport &#123; useSession, signIn, signOut &#125; from &quot;next-auth/react&quot;export default function Component() &#123;  const &#123; data: session &#125; = useSession()  if (session) &#123;    return (      &lt;&gt;        Signed in as &#123;session.user.email&#125; &lt;br /&gt;        &lt;button onClick=&#123;() =&gt; signOut()&#125;&gt;Sign out&lt;/button&gt;      &lt;/&gt;    )  &#125;  return (    &lt;&gt;      Not signed in &lt;br /&gt;      &lt;button onClick=&#123;() =&gt; signIn()&#125;&gt;Sign in&lt;/button&gt;    &lt;/&gt;  )&#125;// back-endimport &#123; getServerSession &#125; from &quot;next-auth/next&quot;import &#123; authOptions &#125; from &quot;./auth/[...nextauth]&quot;export default async (req, res) =&gt; &#123;  const session = await getServerSession(req, res, authOptions)  if (session) &#123;    res.send(&#123;      content:        &quot;This is protected content. You can access this content because you are signed in.&quot;,    &#125;)  &#125; else &#123;    res.send(&#123;      error: &quot;You must be signed in to view the protected content on this page.&quot;,    &#125;)  &#125;&#125;\nZod——消除重复的类型声明\nZod 本身也是在 T3-Stack 中的一项技术，虽然它在开头并未提及:(\n\nZod 被设计成对开发者尽可能友好。其目的是消除重复的类型声明。使用 Zod，你只需声明 一次 验证器，Zod 就会自动推断出静态 TypeScript 类型。它很容易将较简单的类型组成复杂的数据结构。\n\n类型验证\n类型验证是验证数据结构是否符合特定类型的过程。您可以使用它来确保输入数据的有效性，以及记录和执行代码的数据结构。\n使用类型验证有两个主要好处：\n\n运行时的数据完整性：确保数据以正确的格式输入您的系统有助于避免错误并保持数据一致性。虽然 TypeScript 可以帮助您在编译时确保类型安全，但当您处理来自未知数据（例如服务器或用户输入）的数据时，类型验证在运行时会大放异彩。\n文档：一个好的类型验证库将为您使用的数据结构提供准确的类型定义。类型定义可用于为您的项目生成静态文档。\n\nZod 示例\n假设我们要验证用户输入的密码。我们希望密码是一个非空字符串，长度至少为 8 个字符，最多为 32 个字符：\n12345import &#123; z &#125; from &quot;zod&quot;;const stringSchema = z.string().nonempty().min(8).max(32);stringSchema.parse(&quot;&quot;);stringSchema.parse(&quot;&quot;); // throws an exceptionstringSchema.parse(&quot;I am a valid password&quot;); // returns &quot;I am a valid password&quot;\n当你运行上面的代码时，你会看到 parse 方法抛出了一个异常。异常将包含一个对象数组，其中包含 ZodError 错误的详细描述：\n123456789101112131415161718[  &#123;  &quot;code&quot;: &quot;too_small&quot;,  &quot;minimum&quot;: 1,  &quot;type&quot;: &quot;string&quot;,  &quot;inclusive&quot;: true,  &quot;message&quot;: &quot;Should be at least 1 characters&quot;,  &quot;path&quot;: []  &#125;,  &#123;  &quot;code&quot;: &quot;too_small&quot;,  &quot;minimum&quot;: 8,  &quot;type&quot;: &quot;string&quot;,  &quot;inclusive&quot;: true,  &quot;message&quot;: &quot;Should be at least 8 characters&quot;,  &quot;path&quot;: []  &#125;]\n当您尝试解析有效字符串时，parse 将简单地返回其值\n最后\n总的来说，T3 Stack 旨在提供一个全面的开发技术栈，使开发人员能够构建现代、高性能、类型安全的 Web 应用程序，同时减少开发过程中的摩擦和复杂性\n这个技术栈的组件和工具被精心选择，以满足各种 Web 开发需求\n参考\n\nCreate T3 App\ntRPC - Move Fast and Break Nothing. End-to-end typesafe APIs made easy. | tRPC\ntRPC与REST和GraphQL 服务对比\n\n","plink":"https://becase.top/post/85996fbf0018/"},{"title":"2023 前端技术趋势","date":"2023-08-25T13:47:50.000Z","date_formatted":{"ll":"Aug 25, 2023","L":"08/25/2023","MM-DD":"08-25"},"updated":"2024-03-21T03:26:38.025Z","content":"1、❌ Vite 没有取代 Webpack。光从下载量看，还有 5 倍以上的差距。那构建的未来是 Vite 吗？其实未必，Vite 的痛点是其始终是基于 JavaScript 生态，有明显的天花板，同时 Rollup 是他的最大软肋，由于 Build 阶段基于 Rollup 打包，所以速度上极慢，很多人在 Dev 用 Vite 而构建用 Webpack。如果 Rollup 能用 Rust 重写，可能会带来转机。前端构建基建的未来应该是基于 Rust 的。\n2、❌ Deno 没有取代 Node。是个人都能看出来了吧。今年 Deno 为了市场份额，还做了不少兼容 npm 和 Node 生态的事。\n3、❌ Low Code 没有取代 Pro Code。感觉 Low Code 的势头已经过去了，今年声音比较小。Low Code 在我看来更多是 Leader 和大老板喜欢，有卖点，能讲故事；而一线开发者并不喜欢，至少对于我来说是这样，能用 Pro Code 抽象的为啥要用 Low Code 抽象？就算体验做到极致，基于 Low Code 做产品毕竟是在别人画好的圈子里做事，你得很清楚边界在哪，什么能做，什么不能做，边界内可能能提效 20%，但一旦超出边界，可能降效 200%。从市场上看，开 Low Code 的公司可能可以赚点小钱，但赚不了大钱。\n4、✅ Typescript 已取代 JavaScript。在我的视野中看来是这样，比如我们的项目应该是全量 TypeScript 的，至少新增项目是这样。我日常写前端代码，90%+ 都是 TypeScript 。\n5、❌ Rust 没有取代传统 JavaScript 工具链。虽然有这个趋势，但目前还远没有取代或成为主流。同时我觉得 Rust 只会取代其中 CPU 密集型的那部分，IO 密集型的用 Node 同样不会成为性能卡点，同时 Rust 的上手门槛和维护成本相比 Node 是真的高，感觉只有大厂会愿意且有能力投。注：Rust 作为前端工具链也是能讲好故事的。\n6、❌ CSS in JS 没有取代 CSS Modules。CSS in JS 有优势，但优势没有大到大部分前端切换放弃 CSS Modules 的程度。但我个人觉得 CSS in JS 是趋势，因为他解了不少 CSS Modules 不能解的问题。蚂蚁中后台这边经过多维度的权衡，已选择了 CSS in JS；同时 antd 5 这个大版本也选择了 CSS in JS。当然，也有可能螳螂捕蝉黄雀在后，他们都会被 Tailwind CSS 取代也不一定。\n7、❌ web³ 没有取代 web² 。不懂 web³，热潮已过，现在依旧满世界的 web²。但还是不时有人站出来说 web³ 很赚钱。\n8、✅ pnpm 已取代 npm 和 yarn。从我个人角度看是这样，1）pnpm 周下载 444w，2）我已多年没有直接用 npm，3）pnpm 确实解了 npm 存在的大量问题，包括幽灵依赖等诟病已久的问题，同时在 monorepo 等场景下也表现得更出色，还有速度非常快。值得一提的是，从速度角度看，bun 安装 npm 依赖的速度似乎比 pnpm 更快。\n9、❌ swc 没有取代 babel 。但是有这个趋势，尤其是随着 Rust 工具链越来越多，swc 会占据更大份额。swc 很强大，但是相比 babel，API 层也是真难用，维护成本指数级上升。\n10、✅ esm 已取代 cjs 。我是从编码的角度看的，但 cjs 在 npm 包产物里的占比还是占据绝对领导地位的。还有人手写 cjs 吗？应该很少了吧，大家都用 TypeScript 写代码，然后 cjs 可能是其中一种产物类型。为啥还需要 cjs？比如 bun blog 最近的一篇《CommonJS is not going away》中描述的，对于性能有极致要求的场景下，比如 server、框架和 cli，cjs 相比 esm 会更快，以 babel 为例，require(‘babel’) 比 import ‘babel’ 快 2.4 倍。\n11、❌ vue 3 没有取代 vue 2。原因是从下载量看，Vue 3 只有 Vue 2 的 1/3 。\n12、❌ hooks 没有取代 external store 数据流。感觉数据流的时代过去了，至少现在很少有重数据流的项目。越累越多的项目倾向于用 react-query 或 swr 做服务器状态的同步，这种方案能解 80% 的传统数据流问题。同时，值得注意的是，如果 RSC 成为主流，可能连 react-query 或 swr 都不需要了。\n13、❌ serverless 没有取代 server。应该没有吧，我了解不多。\n14、❌ webide 没有取代 ide。webide 更多是一种辅助角色，不管是 VSCode 的在线版，还是 stackbliz、codesandbox 这种，都不会成为程序员的主要工具。我们内部的 VSCode 在线版 webide 倒是很多人用他来排查问题和临时修改代码，因为本地同时启动多个项目会卡。\n15、❌ bundless 没有取代 bundle。略。参考 Vite 和 Webpack 的那部分。\n16、❌ øJS 没有取代 Rich JS 。作为 0JS 的鼻祖，Astro 有点雷声大雨点小的感觉。Astro 的周下载量只有 8W 。0JS 是多页应用，个人不太看好多页应用（MPA），尽管有各种技术加持做缓存和预加载，但体验上始终不如 SPA。0JS 的最佳场景是容器应用，这类应用本身就是多页应用，基于此能进一步减少尺寸和提升可交互时间，那自然是好的。但需要注意的是，RSC 可能是这个问题更好的解。\n转载\nhttps://mp.weixin.qq.com/s/GTEYKVt7GUI-OHdML2WaaQ\n","plink":"https://becase.top/post/1438cca65161/"},{"title":"ClashX的增强模式","date":"2023-08-19T13:47:50.000Z","date_formatted":{"ll":"Aug 19, 2023","L":"08/19/2023","MM-DD":"08-19"},"updated":"2024-03-11T03:21:43.669Z","content":"背景\n记录下被 ClashX 的【增强模式】坑惨的一天\ngit 问题\n一直用的好好的 git，今天却在提交代码时，报错：\n12ssh: connect to host github.com port 22: Connection timed outfatal: Could not read from remote repository.\n在连接 github 时，执行”ssh -T git@github.com” 命令时，出现：\n12$ ssh -T git@github.comssh: connect to host github.com port 22: Connection timed out\ngit 问题定位\n网络问题？\n第一时间觉得是梯子的问题，然后去切换了好几个节点，甚至用上了公司的 VPN\n还是不行\nssh 秘钥过期？\n然后又觉得是 ssh 秘钥过期了，然后去 github 上查看：\n\n显示正常呀，然后自己又生成了个新的 rsa 上传，还是不对\ngit 解决办法\n在多次 google 后的解决办法中，成功实验了一种\n在存放公钥私钥 (id_rsa 和 id_rsa. pub) 的同级文件夹中，有一个 config 文本（没有则新建一个），我原先的内容如下：\n12345# GitHubHost github.comHostname ssh.github.comIdentityFile ~/.ssh/id_rsa_githubUser 1487503910@qq.com\n然后发现网上资料还有两行：\n1234567# GitHubHost github.comHostname ssh.github.comIdentityFile ~/.ssh/id_rsa_githubUser 1487503910@qq.comPort 443 # thisPreferredAuthentications publickey # this\n猜测是网络层需要指定某种校验规则\n再次执行”ssh -T git@github.com” 时，这时验证就可以通过。\n12$ ssh -T git@github.comHi jiechen257! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.\n又现图床问题\n解决完 git 的问题，发现我的图床又不可以用了 :(\n\n我图床是用 github + jsdelivr + PicGo 实现的\n图床问题定位\n跟git 的思考逻辑一样，这是网络问题？token 过期问题？还是我 picgo 配置问题？\n然后又捣鼓捣鼓好久，发现都不是，然后在 picgo 仓库的中发现一个 issues\n\n心想这不就是我的问题吗 :P\n然后给作者发 issues，把错误日志发过去，然后被告知我这就是单纯的网络问题\n我人肯定蒙了呀，但作者大大的话肯定是有依据的，我又排查自己的网络，看这个梯子到底有没有生效\n上 youtube 不再当作依据，我直接 ping 国外网址\n\n好家伙，感情我是被 ClashX 演了呀 =_=\n然后琢磨 ClashX 的配置项，发现个【增强模式】，果然一开就 ping 通了\n\n又现 Mac 安装 App 问题\n想必每个 mac 拥有者都遇到过:\n\n我在测试 picgo 的配置时，删了原有的版本，在重下一个新的包时，就一直报这个错\ngoogle 解决办法都是开启 【运行任何来源】\n\n但依然无效果\nmac 问题再解决\n最后还是在技术网站找到了解决方案：\nsudo xattr -r -d com.apple.quarantine /Applications/PicGo.app\n通过 ChatGPT 查到，这段代码的作用是移除文件或文件夹的&quot;com.apple.quarantine&quot;属性，该属性通常与从互联网下载的文件相关联\n具体而言，命令中的各个部分的含义如下:\n\n\nxattr: 这是macOS中的一个命令，用于操作文件或文件夹的扩展属性（extended attributes）。扩展属性是文件系统中与文件相关联的额外元数据，不同于文件内容或基本属性（如权限、创建日期等）。\n\n\n-r: 这是一个选项，表示递归地处理指定目录下的所有文件和子目录。\n\n\n-d com.apple.quarantine: 这是一个选项和参数的组合，用于删除指定文件或文件夹的名为&quot;com.apple.quarantine&quot;的扩展属性。这将移除与该文件相关的下载来源警告\n\n\n执行完命令后，再安装就成功了\nClashX 的增强模式\n最后，回到 ClashX 本身，这个功能有什么用，不开会怎样？\n这里就要明确代理的含义了\n\nSS、SSR、V2ray等软件工具属于代理(proxy)，不是VPN。这意味着在电脑上(PC端)，开启这些上网工具后，浏览器可以顺利上外网，但命令行、其他工具的流量可能并不会走代理\n\n如果想实现其他软件也走代理，那就是全局代理，类比之下，也就是 ClashX 的【增强模式】\n所以我在一开始定位网络问题时，能在浏览器上 youtube 等国外网站，但在终端中是没有代理效果的…\n最后\n真是充zhe实mo的一天！\n","plink":"https://becase.top/post/53d5067bc396/"},{"title":"为何不推荐 Sass 作为 css 预处理","date":"2023-07-04T12:47:50.000Z","date_formatted":{"ll":"Jul 4, 2023","L":"07/04/2023","MM-DD":"07-04"},"updated":"2024-03-11T03:21:43.677Z","content":"背景\n我 npm install 又双叒叕遇到 sass 报错了！！！\n痛心疾首，下定决心写一个 sass 避坑指南 :)\n\nSass 是成熟、稳定、强大的专业级 CSS 扩展语言。它兼容 CSS、功能丰富、社区庞大，为业界认可，被广泛应用\n\n本文将根据使用 Sass 存在的痛点，以及更好的替代品，来陈述个人观点：不推荐使用 scss 作为 css 预处理器，更倾向于使用 Less 或 Stylus\nSass Vs Scss\nSass 有两种语法：\n\n第一个被称为 SCSS（Sassy CSS），在本参考文献中一直使用，它是 CSS 语法的扩展。这意味着每个有效的 CSS 样式表，都是具有相同含义的有效 SCSS 文件，两者完全兼容。下文描述的 Sass 功能增强了此语法。使用此语法的文件扩展名为 .scss。\n第二种或更旧的语法称为缩进语法（有时也称为“ Sass”），提供了一种更为简洁的 CSS 编写方式。它使用缩进而不是方括号来表示选择器的嵌套，并使用换行符而不是分号来分隔属性。使用此语法的文件扩展名为 .sass\n\n以上出自 Sass 官网对两者的解释。因为 scss 完全兼容 css，目前一般常用的是 scss；但 scss 也是 Sass 语法一部分，因此就以此为标题；言下之意，无论是 .scss 还是 .sass 皆不推荐使用。\n不推荐使用的理由\nSass 是采用 Ruby 语言编写的一款 CSS 预处理语言，如果安装并单独使用 sass，这并无什么问题；\n12345# 安装 sassnpm install -g sass# 使用 sasssass source/stylesheets/index.scss build/stylesheets/index.css\n但在工程化项目中，就另当别论了；，需要借助 node-sass。它虽然能够以惊人的速度，通过连接中间件自动将 .scss 文件本地编译为 css，但同时存在很多问题，导致在有的时候引发巨大痛点，这便是“不推荐使用 Sass 作为 css 预处理器”主要理由。\n\nNode-sass is a library that provides binding for Node.js to LibSass, the C version of the popular stylesheet preprocessor, Sass.\n\nnode-sass 存在的痛点\n\nnode 版本与 node-sass 版本不兼容\n\nnode-sass 与 Node.js 版本相关联；这就导致，一旦本地 Node.js 升级，就会出现 node-sass 无法工作的情况，如下报错：\n\nModule build failed: ModuleBuildError: Module build failed: Error: Node Sass does not yet support your current environment:\nThis usually happens because your environment has changed since running npm install. Run npm rebuild node-sass to build the binding for your current environment.\n\n\nModule build failed (from ./node_modules/sass-loader/index.js):Error: Missing binding /…/xxx/node_modules/node-sass/vendor/darwin-x64-64/binding.node\nNode Sass could not find a binding for your current environment: OS X 64-bit with Node.js 10.x\n\n通常遇见类似问题，你就需要通过 rebuild 或重新安装 node-sass 来解决，徒增烦恼；当然，也可以借助 nvm 来切换至 node-sass 对应 Node.js 版本；\n12345678npm rebuild node-sass# Ornpm uninstall node-sassnpm install node-sass# Ornvm use [node-sass 对用的 Node 版本]\n\n需要 node-gyp 作为先决条件\n\nnode-sass 需要 node-gyp 作为先决条件，而 node-gyp 又需要您安装了兼容版本的 Python，啧啧，这真是，不出问题还好；出现就得好一番折腾（而且其报错并不是很友好，就需要定位排查、查阅各种资料来修复）。\n\nnode-gyp requires that you have installed a compatible version of Python, one of: v2.7, v3.5, v3.6, v3.7, or v3.8. If you have multiple Python versions installed …\n\n先前因为需要，在 Mac 上，需要将 Python2 升级至 Python3，之后就导致各种 node-sass 问题，好一番折腾才修复。\n\ngyp verb check python checking for Python executable “python” in the PATH\ngyp verb which succeeded python /usr/local/bin/python\ngyp ERR! configure error\ngyp ERR! stack Error: Command failed: /usr/local/bin/python -c import sys; print “%s.%s.%s” % sys.version_info[:3];\ngyp ERR! stack File “”, line 1\ngyp ERR! stack import sys; print “%s.%s.%s” % sys.version_info[:3];\ngyp ERR! stack ^\ngyp ERR! stack SyntaxError: invalid syntax\n\n\n/Users/xxx/.node-gyp/12.13.0/include/node/v8.h:3039:5: note: candidate constructor not\nviable: requires 2 arguments, but 1 was provided\nUtf8Value(Isolate* isolate, Localv8::Value obj);&gt;\n\n\nbinding.node 源无法访问或速度慢\n\n实际上 node-sass 依赖了一个二进制文件 binding.node，从 npm 源安装完本体后还会从 github（默认源） 下载 binding.node；这就导致默认情况下，下载 node-sass 依赖很迟缓。\n以上，SASS 不仅需要额外安装 node-sass （很慢），而且跟本地开发环境（Node.js，Python）高度挂钩，容易出现各种诡异问题，故而不推荐使用；而且，SASS 所提供的常用功能，Less、Stylus 也同样具备；而且 Less、Stylus 易于安装，使用便捷，何乐不为？\n推荐使用 Less或 Stylus 或 dart-sass\n\nLess：Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。Less 可以运行在 Node 或浏览器端\nStylus：Stylus 是一种创新的样式表语言，可编译为 CSS。受 SASS 的启发，Stylus 是用 node.js 构建的，并能够在本交互式教程中说明的浏览器中运行\n\n转载\n\n为何不推荐使用 Sass 作为 css 预处理器\n\n","plink":"https://becase.top/post/d1db0227e2c5/"},{"title":"新兴的Astro","date":"2023-04-23T13:47:50.000Z","date_formatted":{"ll":"Apr 23, 2023","L":"04/23/2023","MM-DD":"04-23"},"updated":"2024-03-11T03:21:43.679Z","content":"Astro\n框架定位\n先来聊一聊 Astro 框架的定位，是像 Vue、React 这样的底层渲染框架，还是像 Next.js 这种上层的研发框架？\n这一点其实挺困扰初学者的，因为 Astro 既自创了类似于.vue、.jsx文件的 .astro 语法，又提供了像 Next.js 里面各种运行时的能力，比如约定式路由、构建优化、SSR 等等。\n但实际上它给自己的定位非常清晰，即 content-focused 应用开发框架，换句话说，就是重内容、轻交互场景下的上层研发框架，比如大多数电商网站、文档站、博客站、证券网站等等。\n你可以将 Astro 理解为一个垂直场景下的Next.js，但它可以在它适用的领域里面可以胜过其它所有竞品(如Next.js、Remix、Vuepress 等)，这是它能够做起来的重要原因。接下来，我们就来看看 Astro 的优势在于哪些地方。\n核心优势\nAstro 的主要优势包括如下几点:\n\nIslands 架构，解决传统 SSR/SSG 框架的全量 hydration 问题，做到尽可能少的 Client 端 JS 的开销，甚至是 0 JS。\n学习成本低。.astro 语法和传统的 .jsx 和 .vue 非常相似，对于新手前端来说也比较容易掌握。\n使用灵活。对于页面的开发，你既可以使用官方的.astro 语法，也同样可以使用 .md、.vue、.jsx 语法，也就是说，你可以自由选择其它前端框架的语法来开发，甚至可以在一个项目中同时写 Vue 组件和 React 组件！\n构建迅速。底层构建体系基于 Vite 以及 Esbuild 实现，项目启动速度非常快。\n\nIslands 架构\n在如上的几个优点中，我们来重点说一说 Astro 的 Islands 架构，因为这是它高性能最主要的原因。\nIslands 架构模型早在 2019 年就被提出来了，并在 2021 年被 Preact 作者Json Miller 在Islnads Architecture 一文中得到推广。这个模型主要用于 SSR (也包括 SSG) 应用，我们知道，在传统的 SSR 应用中，服务端会给浏览器响应完整的 HTML 内容，并在 HTML 中注入一段完整的 JS 脚本用于完成事件的绑定，也就是完成 hydration (注水) 的过程。当注水的过程完成之后，页面也才能真正地能够进行交互。\n那么当应用的体积逐渐增大时，需要在客户端执行的 JS 脚本也会越来越多，这也意味着 TTI(可交互时间) 指标越来越高:\n为了解决这个问题，Islands 架构将页面拆分为各自独立的组件，包含静态组件和可交互组件，如下图的例子所示：\n\n可以清楚的看到，一个页面中只有部分的组件交互，那么对于这些可交互的组件，我们可以并行地执行 hydration 过程，因为组件之间是互相独立的。\n而对于静态组件，即不可交互的组件，我们可以让其不参与 hydration 过程，直接复用服务端下发的 HTML 内容。\n可交互的组件就犹如整个页面中的孤岛(Island)，因此这种模式叫做 Islands 架构:\n\n相比于传统 SSR 中的全量 hydration，Islands 模式可以实现局部(partial) hydration，从而优化 JS 的体积，减少网络传输的成本和 JS 运行时的开销。\n在 Astro 中，默认所有的组件都是静态组件，比如:\n1234// index.astroimport MyReactComponent from &#x27;../components/MyReactComponent.jsx&#x27;;---&lt;MyReactComponent /&gt;\n值得注意的是，这种写法不会在浏览器添加任何的 JS 代码。但有时我们需要在组件中绑定一些交互事件，那么这时就需要激活孤岛组件了，在 Astro 如何来激活呢？其实很简单，在使用组件时加上client:load指令即可:\n12345// index.astro---import MyReactComponent from &#x27;../components/MyReactComponent.jsx&#x27;;---&lt;MyReactComponent client:load /&gt;\n如此一来，Astro 会给浏览器传输一部分 JS 代码供这个组件完成 hydration，以便后续的交互。\nAstro 2.0\n\n内容集合：Markdown 和 MDX 的自动类型安全；\n混合渲染：支持静态渲染和动态渲染；\n重新设计的错误 Overlays；\n改进的开发服务器 (HMR)；\nVite 4.0；\n新的公开路线图\n\n详情参考：Astro 2.0正式发布，现代化静态站点生成器 - 掘金\nSSR和SSG\n1. 静态资源和动态资源分别是什么？\n首先静态资源和动态资源都是服务端这边的概念，因为我们访问互联网本质都是访问对应的服务端\n对于服务端来说：\n\n静态资源是：提前准备好的，写死了的，直接文件IO就可以response的属于静态资源。\n动态资源是：不是写死的，需要读库的 或 需要调下游接口的 或 需要脚本处理的属于动态资源\n\n前端角度看哪些是静态资源？\n\n通过前端工程npm run build编译好的js、css、html文件，都属于静态资源\n提前准备好的文件（比如自己开发的源代码），都属于静态资源\n图片、视频等资源文件，都属于静态资源\n\n前端角度看哪些是动态资源？\n\n需要调接口才能得到的内容，并且内容不是提前准备好的，属于动态资源\n\n2. 从架构角度看动、静态资源\n1. 请求SSR架构的服务的html属于静态资源还是动态资源？\n结论：属于动态资源\n因为：html没有提前准备好，没有提前静态化。是来一个请求，就动态编译生成html的\n2. 请求SSG架构的服务的html属于静态资源还是动态资源？\n结论：属于静态资源\n因为：html被提前静态化了。无需实时编译\n3. 引发对性能优化的思考\nSSR架构的存在问题，以及如何解决\nSSR架构性能好是最大的特色之一，但被人诟病的一个最大问题也是性能问题，原因：\n\n\nSSR架构的性能好，其实是针对前端来说的\n\n\n对于前端用户来说，访问SSR的服务，可以直接得到完整的html（CSR架构的html是空的，没有dom内容，dom内容需等js后续生成的），\n\n\n并且如果你的首屏需要被多个接口阻塞时，SSR可以在服务端把请求处理完\n\n\n服务端处理请求非常非常快，举个栗子：同一个接口前端ajax需要1s，服务端请求可能只需20ms，因为服务端可以抹掉网络连接的阻塞，可能和目标下游服务器就在同一个机房\n\n\n\n\nSSR架构对于服务端来说，性能非常差\n\n这个怎么理解呢？ 其实是和服务端接口来做对比的，比如接口的QPS可以很容易超过1000，但SSR的处理QPS可能只有10，因为html是动态生成的，需要大量的时间来编译得到html，所以对于接口来说，SSR的性能很差很差\n\n\n\n解决办法\n\n\n做成SSG（静态化）\n\n\n原理：提前编译好html，节省编译html的时间，让 请求动态资源 变成 请求静态资源。\n\n\n但也不是没副作用的，副作用是：会丢失动态化能力，比如我本来可以在服务端根据用户的ip，显示对应的语言的html。做成SSG之后，只能默认显示一种语言。并且也无法在服务端把阻塞请求处理完\n\n\n\n\n不过有办法可以解决上面SSG架构的缺陷（动静结合！）\n\n\n原理：在多加一层bff层，由这一层来处理动态化部分\n\n\n比如 把阻塞请求处理完，通过&#123;&#123; &#125;&#125;占位标识，替换掉对应html内的数据。\n\n\n比如 根据用户ip显示多语言的问题，需要我们提前用ssg编译好多份html（对应多语言），然后由bff来处理。。（确实做的有点复杂了，不过假如要追求极致性能的话，这是一种选择）\n\n\n\n\n\n\n参考\nAstro 1.0 正式发布，给前端带来了什么\n对静态资源和动态资源的思考，延伸至SSR和SSG的性能优化\n","plink":"https://becase.top/post/fbd252aeca35/"},{"title":"初识WebComponent","date":"2023-02-16T13:47:50.000Z","date_formatted":{"ll":"Feb 16, 2023","L":"02/16/2023","MM-DD":"02-16"},"updated":"2024-03-11T03:21:43.678Z","content":"背景\n\n组件化 已经成为目前主流的前端开发模式，其可复用性这一大特点是一众复制粘贴工程师的福音。目前我们实现组件化主要是依托于各大框架如 Vue ， React ， Angular 。这些框架基本都是在遵从浏览器的规则下制定出自己的一套开发规则和书写语法使开发者的项目获得组件化的能力\n\n随着近年来组件化框架的盛行，官方也推行了一套组件化的解决方案和原生API上的支持 —— Web Component 。\nWeb Component 是什么\nWeb Components 是一系列加入 w3c 的 HTML 和 DOM 的特性，使得开发者可以创建可复用的组件\n\n由于 web components 是由 w3c 组织去推动的，因此它很有可能在不久的将来成为浏览器的一个标配。\n\n关键字：原生、定制化标签\n使用 Web Component 编写的组件是脱离框架的，换言之，也就是说使用 Web Component 开发的组件库，是适配所有框架的，不会像 Antd 这样需要对 Vue 、 React 等框架出不同的版本\n使用 Web Component\nWeb Component 核心技术\n\nCustom elements（自定义元素）：一组 JavaScript API，允许您定义 custom elements 及其行为，然后可以在您的用户界面中按照需要使用它们\nShadow DOM（影子DOM）：一组 JavaScript API，用于将封装的 “影子” DOM 树 附加到元素（与主文档DOM分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突\nHTML templates（HTML模板）： &lt; template &gt; 和 &lt; slot &gt; 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用\nHTML Imports（HTML导入）：一旦定义了 自定义组件，最简单的重用它的方法就是使其定义细节保存在一个单独的文件中，然后使用导入机制将其导入到想要实际使用它的页面中。 HTML 导入就是这样一种机制，尽管存在争议 — Mozilla 根本不同意这种方法，并打算在将来实现更合适的\n\n实现一个简单的组件\n\n定义自定组件:12345678class MyButton extends HTMLElement &#123;\tconstructor () &#123;\t\tsuper();\t\tconst template = document.getElementById(&#x27;mybutton&#x27;);\t\tconst content = template.content.cloneNode(true);\t\tthis.appendChild(content);\t&#125;&#125;\n\n\n（神似 react）\n\n\n定义组件模板:\n123&lt;template id=&quot;mybutton&quot;&gt;\t&lt;button&gt;Add&lt;/button&gt;&lt;/template&gt;\n\n\n注册组件:\n1window.customElements.define(&#x27;my-button&#x27;, MyButton);\n\n\n使用组件:\n123&lt;body&gt;\t&lt;my-button&gt;&lt;/my-button&gt;&lt;/body&gt;\n\n\n这样， 一个简单的 Web Component 就完成了。\n生命周期\n和一般框架中的组件一样，Web Component 的组件为了支持更多场景的应用也是有生命周期的。\n常用的生命周期方法如下:\n\nconnectedCallback\n当 web component 被添加到 DOM 时，会调用这个回调函数，这个函数只会被执行一次。可以在这个回调函数中完成一些初始化操作，比如更加参数设置组件的样式。\ndisconnectedCallback\n当 web component 从文档 DOM 中删除时执行。\nadoptedCallback\n当 web component 被移动到新文档时执行。\nattributeChangedCallback\n被监听的属性发生变化时执行\n\n与React的结合\n就像刚刚所使用的，看起来 WebComponent 和 React 很想，但实际上二者是互补的关系\nReact中使用的API都是声明式的，react封装了对DOM的操作并做了一定的优化； 而WebComponent中则是命令式的，它的方法都是基于原生DOM进行操作的（要不然咋说它是原生组件技术，doge）\nreact官方也有说明，详情参考：Web Components – React\n在 Web Component 中使用 React\n1234567891011class XSearch extends HTMLElement &#123;  connectedCallback() &#123;    const mountPoint = document.createElement(&#x27;span&#x27;);    this.attachShadow(&#123; mode: &#x27;open&#x27; &#125;).appendChild(mountPoint);    const name = this.getAttribute(&#x27;name&#x27;);    const url = &#x27;https://www.google.com/search?q=&#x27; + encodeURIComponent(name);    ReactDOM.render(&lt;a href=&#123;url&#125;&gt;&#123;name&#125;&lt;/a&gt;, mountPoint);  &#125;&#125;customElements.define(&#x27;x-search&#x27;, XSearch);\n在 React 中使用 Web Component\n12345class HelloMessage extends React.Component &#123;  render() &#123;    return &lt;div&gt;Hello &lt;x-search&gt;&#123;this.props.name&#125;&lt;/x-search&gt;!&lt;/div&gt;;  &#125;&#125;\n\nWeb Components 的组件 video 可能会公开 play() 和 pause() 方法。要访问 Web Components 的命令式 API，你需要使用 ref 直接与 DOM 节点进行交互\n如果你使用的是第三方 Web Components，那么最好的解决方案是编写 React 组件包装该 Web Components。\n\nWeb Components 触发的事件可能无法通过 React 渲染树正确的传递。 你需要在 React 组件中手动添加事件处理器来处理这些事件。\ndemo演示\n\n如果我们想要实现原生组件复用，就需要把代码写在一个js文件里面，引入该js文件，就等于引入了组件。\n123456789101112131415161718192021222324252627//index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;    //引入编写好的组件，在这里引入文件，注意要添加defer关键字  &lt;script src=&quot;./MyList/index.js&quot; defer&gt;&lt;/script&gt;  &lt;body&gt;    &lt;div&gt;        //使用组件      &lt;my-list id=&quot;node&quot;&gt;          &lt;!--原生支持插槽  --&gt;        &lt;slot&gt;web component&lt;/slot&gt;      &lt;/my-list&gt;    &lt;/div&gt;    &lt;script&gt;        //因为是原生，所以我们需要获取dom节点行后续操作      const node = document.getElementById(&quot;node&quot;);        //我们将变量转换一下格式，就能传递给子组件      node.dataset.arr = JSON.stringify([&quot;吃饭&quot;, &quot;睡觉&quot;]);    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//index.jsconst template = document.createElement(&quot;template&quot;);//在js文件中，我们想要书写html和css就必须要借助innerHTML，在其内部书写我们的样式和结构template.innerHTML = `  &lt;style&gt;    #contain &#123;      display: flex;      flex-direction: column    &#125;    input &#123;      width: 200px    &#125;  &lt;/style&gt;  &lt;div id=&quot;contain&quot;&gt;    &lt;span&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/span&gt;    &lt;div&gt;     &lt;input type=&quot;text&quot; id=input&gt;     &lt;button id=&quot;mybutton&quot; data-text1=&quot;111111&quot;&gt;添加&lt;/button&gt;    &lt;/div&gt;  &lt;/div&gt;`;class MyList extends HTMLElement &#123;  constructor() &#123;    //因为我们的组件继承于HTMLElement，所以需要调用super关键字      super();    // 获取标签    const content = template.content.cloneNode(true);    const mybutton = content.getElementById(&quot;mybutton&quot;);    const input = content.getElementById(&quot;input&quot;);    const contain = content.getElementById(&quot;contain&quot;);    // 获取props    const arr = JSON.parse(this.dataset.arr);   //进行事件的监听    mybutton.addEventListener(&quot;click&quot;, () =&gt; &#123;      arr.push(input.value)      const li = document.createElement(&quot;li&quot;);      li.innerText = input.value;      contain.appendChild(li);    &#125;);    // 将数据渲染到页面    arr.forEach((item) =&gt; &#123;      const li = document.createElement(&quot;li&quot;);      li.innerText = item;      contain.appendChild(li);    &#125;);     //初始化一个影子dom    this.attachShadow(&#123; mode: &quot;closed&quot; &#125;).appendChild(content);  &#125;&#125;// 注册组件window.customElements.define(&quot;my-list&quot;, MyList);\n相应框架\n从上面的案例看的出来这种原生dom操作的开发效率还是太低，这里再推荐一个WebComponent的封装框架：Stencil\n\n有人就疑惑了，WebComponent不是强调不依赖vue、react等框架吗？\n\n是的，它是不依赖vue、react等框架，但并不表示他不能像js拥有jQuery一样，拥有自己的封装库。\n封装出来的语法题和强依赖的运行环境，二者的关系需要弄清楚\n框架使用示例\n123456789101112131415161718192021import &#123; Component, Prop, h &#125; from &#x27;@stencil/core&#x27;;@Component(&#123;  tag: &#x27;my-component&#x27;,            // the name of the component&#x27;s custom HTML tag  styleUrl: &#x27;my-component.css&#x27;,   // css styles to apply to the component  shadow: true,                   // this component uses the ShadowDOM&#125;)export class MyComponent &#123;  // The component accepts two arguments:  @Prop() first: string;  @Prop() last: string;   //The following HTML is rendered when our component is used  render() &#123;    return (      &lt;div&gt;        Hello, my name is &#123;this.first&#125; &#123;this.last&#125;      &lt;/div&gt;    );  &#125;&#125;\n使用\n1&lt;my-component first=&quot;Stencil&quot; last=&quot;JS&quot;&gt;&lt;/my-component&gt;\n参考\nWeb Component | MDN\nWeb Component入门\nStencil\n","plink":"https://becase.top/post/c47c9cd006a5/"},{"title":"windows 系统的包管理器","date":"2023-01-16T16:00:00.000Z","date_formatted":{"ll":"Jan 17, 2023","L":"01/17/2023","MM-DD":"01-17"},"updated":"2024-03-11T03:21:43.677Z","content":"\n大家都听说过 linux 的 apt、yum 等，MacOS 的 homebrew，那 windows 系统的包管理器呢？\nwindows 有没有包管理器，有的话为什么没多少人用？\n\n什么是包管理器\n\n包管理器又称软件包管理系统，它是在电脑中自动安装、配置、卸载和升级软件包的工具组合，在各种系统软件和应用软件的安装管理中均有广泛应用。\n\n如果你用过 Python ，那么对 pip 一定不陌生，Python 对所有第三方库的查找、下载、安装、卸载等都可以通过 pip 来完成的。需要哪个库，pip install帮你安装；不需要了，pip uninstall一键就能卸载。简单省事、方便快捷。不少编程语言均有各自对应的包管理器，比如 Nodejs 的 npm 等。\n其实在操作系统上，包管理器应用就更广泛了，尤其是 Linux 系统和 macOS 系统已经相当成熟了。比如 Ubuntu 的 apt、CentOS 的 yum、 macOS 系统下的 Homebrew 等\nWindows 平台的包管理器因为 支持下载的软件包少、国内下载速度慢、社区不完善 等问题仍受诟病，因此使用的人数很少，以至于有些人都没听说过 windows 系统也有包管理器\nWindows 系统上常见的包管理器主要有 Chocolatey、winget 和 Scoop。\n包管理器的作用\n\n降低安装维护软件的成本\n避免安装大量软件造成的路径污染\n不必查找和安装软件的其他依赖项\n避免捆绑和垃圾软件\n彻底地卸载\n\nChocolatey 的安装使用\n环境要求\n在安装之前，必须要保证自己电脑满足以下标准：\n\nWindows 7+ / Windows Server 2003+\nPowerShell v2+\n.NET Framework 4+\n\n安装\n右键开始菜单，选择用管理员权限打开 Windows Powershell(管理员)(A)\n\n1Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString(&#x27;https://chocolatey.org/install.ps1&#x27;))\n等待安装完成，之后可以使用 choco -v 查看安装结果,也可以使用 choco -? 查看帮助文档\n使用\nChocolatey 的默认下载地址是在C 盘，如果你想更改默认下载位置，可以通过修改电脑的环境变量来实现\n\nchoco list/search [应用名]\n搜索应用\nchoco info [应用名]\n列出应用的详细信息\nchoco install [软件包名]\n显然就是来安装软件的\n-y 选项来默认确认安装\nchoco list/search -l\n查看本地安装的所有应用\nchoco list/search [应用名] --by-id-only\n只返回 id 中含有关键字的应用\nchoco uninstall [应用名]\n自动卸载应用（一个或多个）\nchoco outdated\n检查一下哪些应用需要更新\nchoco update all\n更新所有的软件\n当然你也可以直接用 choco upgrade [应用名] 更新某一个软件\n\n除了命令行界面，还有 ChocolateyGUI 图形界面以供使用\nwinget 的安装和使用\nWinGet（Windows 程序包管理器：Windows Package Manager）是微软为 win10 开发的一款开源的软件包管理器，于 2020 年 5 月的 Microsoft Build 开发者大会上 首宣 。\n前提：Windows 10 1709 及以上版本\n当前 WinGet 支持的安装程序类型尚不多，除了 EXE、MSIX、MSI 三种之外，还能够在自定义配置后下载部分微软应用商店的程序\n安装\n你可以在 Github Release 下载.appxbundle格式的文件，双击打开并运行（官方 GitHub 主页 和 Microsoft Docs 里有 WinGet 更详细配置信息）\n基本使用\n\n显示简略帮助文档：winget -?（-?可选）；查看特定命令的详细帮助文档：winget [&lt;命令&gt;] -?，如 winget install -?\n显示软件详细信息：winget show &lt;包名&gt;\n搜索软件：winget search &lt;包名&gt;\n安装软件：winget install &lt;包名&gt;\n\nScoop\nScoop 功能更全面、可配置性更高\n下载安装\n前提：\n\nWindows 7 SP1+ / Windows Server 2008\nPowerShell 5+（include PowerShell Core and .NET Framework 4.5 ）\n\n安装\n管理员身份运行 PowerShell，输入以下两条命令，待安装完成之后，输入 scoop 显示帮助文档即说明安装成功。\n12Set-ExecutionPolicy RemoteSigned -scope CurrentUseriwr -useb get.scoop.sh | iex\n注：Scoop 支持利用 aria2 进行多线程下载。所以可先 scoop install aria2 下载 aria2，之后所有的下载任务就均可以调用 aria2 多线程下载来提高速度了\n使用\n\n换源\n要改善 Scoop 的下载速度，详细可以参照 Scoop | Gitee 版 的说明更换下载源。换源之后的Scoop，速度提升不是一星半点儿。\n\n更换 Scoop 源\n\n123scoop config SCOOP_REPO https://gitee.com/squallliu/scoopscoop update\n\n更换 bucket 源\n\n1234567scoop install git# 注意：引号里面换成自己的路径，如果是默认路径则为$&#123;Env:USERPROFILE&#125;\\scoop\\buckets\\&lt;bucket_name&gt;git -C &quot;D:\\Scoop\\buckets\\main&quot; remote set-url origin https://hub.fastgit.org/ScoopInstaller/Main.gitgit -C &quot;D:\\Scoop\\buckets\\extras&quot; remote set-url origin https://hub.fastgit.org/lukesampson\n参考\nChocolatey Software | Chocolatey - The package manager for Windows\nWindows 系统缺失的包管理器：Chocolatey、WinGet 和 Scoop\n","plink":"https://becase.top/post/97d8ea65d765/"},{"title":"前端单元测试框架的实现原理","date":"2023-01-13T13:47:50.000Z","date_formatted":{"ll":"Jan 13, 2023","L":"01/13/2023","MM-DD":"01-13"},"updated":"2024-03-11T03:21:43.679Z","content":"关于单元测试\n先看维基百科：\n\n在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。\n\n在前端背景下，这个也可以很简单理解为测试工具函数。通常来说，单元测试，关于验证我们应用中每一个函数是否调用正确。如何判断调用正确呢？考虑一般如下：\n\n函数调用次数合理\n函数入参符合预期\n函数出参，也即是返回值符合预期\n\n当然函数本身可能又会调用其他函数，或者也可以说函数会依赖其他模块、第三方库，同时函数也可能是同步或异步。所以当被测试的函数是纯函数时，就是测试函数本身的出入参是否符合预期就行了，否则，我们需要做许多 mock 的工作，借此来排除不是我们目标的测试代码。\n当然我们日常工作中，如果要写单元测试的话，一般都会使用业界成熟的测试库，比如 jest、mocha、chai、ava、tape、QUnit 等等。其实大部分测试框架背后的原理基本类似。所以，让我们通过实现一个最简单的单元测试框架，来学习单元测试原理吧！\n测试容器和断言库\n测试框架基本可以拆分出两个部分：\n\n测试容器（Test Runner）\n断言库（Assertion Library）\n\n简介\n测试容器最基本的作用是，自动运行所有测试，对测试结果进行数据汇总等。我们常见的使用方式一般如下，编写测试单元：\n1234567891011121314// ./math.test.jsconst &#123; sumAsync, subtractAsync &#125; = require(&#x27;./math&#x27;);test(&#x27;sumAsync adds numbers asynchronously&#x27;, async () =&gt; &#123;  const result = await sumAsync(3, 7);  const expected = 10;  expect(result).toBe(expected);&#125;);test(&#x27;subtractAsync subtracts numbers asynchronously&#x27;, async () =&gt; &#123;  const result = await subtractAsync(7, 3);  const expected = 4;  expect(result).toBe(expected);&#125;);\n假设我们有 math 工具函数如下：\n1234567// ./math.jsconst sum = (a, b) =&gt; a + b;const subtract = (a, b) =&gt; a - b;const sumAsync = (...args) =&gt; Promise.resolve(sum(...args));const subtractAsync = (...args) =&gt; Promise.resolve(subtract(...args));module.exports = &#123; sum, subtract, sumAsync, subtractAsync &#125;;\n我们用 jest 运行测试，在终端反馈汇总后的测试结果：\n12345678910$ jest PASS  ./math.test.js  ✓ sumAsync adds numbers asynchronously (4ms)  ✓ subtractAsync subtracts numbers asynchronously (1ms)Test Suites: 1 passed, 1 totalTests:       2 passed, 2 totalSnapshots:   0 totalTime:        1.145sRan all test suites.\n断言库一般形式如下：\n12345expect(result).toBe(expected);expect(func).toHaveBeenCalled();expect(func).toHaveBeenCalledTimes(1);expect(func).toHaveBeenCalledWith(arg1, arg2 /* ...args  */);// ...\n断言库是不是看起来很语义化~\n测试容器实现示例\n测试容器其实并不复杂，最简单的实现不过如下：\n12345678910// ./test.jsasync function test(title, callback) &#123;  try &#123;    await callback();    console.log(`✓ $&#123;title&#125;`);  &#125; catch (error) &#123;    console.error(`✕ $&#123;title&#125;`);    console.error(error);  &#125;&#125;\n需要留意的是，这里加上了 async/await 是为了等待测试用例中的异步逻辑。\n断言库实现示例\n断言库也没有黑魔法，我们写一个最简单的 expect(x).toBe(y) 的语法如下：\n12345678910// ./expect.jsfunction expect(actual) &#123;  return &#123;    toBe(expected) &#123;      if (actual !== expected) &#123;        throw new Error(`$&#123;actual&#125; is not equal to $&#123;expected&#125;`);      &#125;    &#125;,  &#125;;&#125;\n远比想象中简单，对不对~\n这里有个比较关键的地方是，断言函数里如果断言失败时，我们的选择是抛出一个错误，然后在测试容器中会 try/catch 捕获，同时打印错误堆栈。（在简单情况下，我们也可以使用 Node.js 自带的 assert 库进行断言）\n除此之外，还有很多更复杂的断言语法，不过基本形式也就是这样。当然如何巧妙设计测试函数调用次数（toHaveBeenCalledTimes）、出入参（toHaveBeenCalledWith）的断言函数，后文会提到。\n自动注入\n有些同学可能留意到了，在测试框架中，我们并不需要手动引入 test、expect 这些函数，每个测试文件可以直接使用。这个其实也很简单。参考代码如下：\n12345678910// ./test-framework.js// 注入给全局对象，使得每个文件可以访问global.test = require(&#x27;./test&#x27;);global.expect = require(&#x27;./expect&#x27;);// 从命令行加载所有测试用例：process.argv.slice(2).forEach(file =&gt; &#123;  // 测试文件中  require(file);&#125;);\n然后在终端运行：\n1234$ node test-framework.js ./math.test.js✓ sumAsync adds numbers asynchronously✓ subtractAsync subtracts numbers asynchronously\n对不对！就是这么简单！\n接下来我们只需要把这件事情做得更优雅，比如\n\n把它封装成 TestRunner 对象\n把命令放在 ./bin 中\n扩展更多的断言语法\n使用 glob 匹配所有测试文件\n支持配置（参考 jest.config.js）\n测试汇总统计\n支持优雅的错误堆栈\n\n甚至于你可以扩展进行支持 DOM 测试，因为 DOM 测试的核心逻辑也是使用 JSDOM 根据 W3C 标准在内存中模拟相似的 DOM 结构，从而支持断言测试的。\n函数测试\n上文中我们基本搭建了一个最简单的测试框架，文件结构如下：\n123456.├── expect.js├── math.js├── math.test.js├── test-framework.js└── test.js\n说起来，在某些场景下，其实我们需要能够保证函数只被执行一次，以及被调用时候的入参是准确的。\n因为函数调用多次可能会引发内存泄露，入参错误则可能会导致应用不可预期的行为。所以我们需要从断言库中更细粒度的去测试保障。\n那么断言库是怎么做到的呢？\n接下来我们将扩展一下断言库，使其支持更丰富的函数测试。\n入参与调用次数监控的实现原理\n假设我们扩展支持这两种断言语法：\n123expect(sum).toHaveBeenCalledTimes(1);expect(sum).toHaveBeenCalledWith(3, 7);\n大家可以思考一下如何设计实现呢？\n我们在测试框架中，集成下面这个函数：\n123456789101112// ./test-framework.jsglobal.jest = &#123;  fn: (impl = () =&gt; &#123;&#125;) =&gt; &#123;    const mockFn = (...args) =&gt; &#123;      mockFn.mock.calls.push(args);      return impl(...args);    &#125;;    mockFn.originImpl = impl;    mockFn.mock = &#123; calls: [] &#125;;    return mockFn;  &#125;,&#125;;\n其中的 fn 函数是一个高阶函数，包裹传入的待测试函数 impl。挂载 mock 对象，在返回的 mockFn 中调用时，用以统计调用数据。\n当然对于编写测试用例的调用方来说是无需感知的，只需要使用 jest.fn 进行包裹即可：\n12const sumMockFn = jest.fn(sum);\n接下来只需要对返回的 sumMockFn 进行测试即可，本质上对 sumMockFn 的操作，都会透传到 sum 中。\n扩展断言函数\n所以我们还差什么？… 嗯对了。还有断言函数：\n123456789101112131415161718192021222324252627282930313233343536373839// ./expectconst &#123; isEqual &#125; = require(&#x27;lodash&#x27;);module.exports = function expect(actual) &#123;  return &#123;    toBe(expected) &#123;      // ...    &#125;,    toEqual(expected) &#123;      if (!isEqual(actual, expected)) &#123;        throw new Error(`$&#123;actual&#125; is not equal to $&#123;expected&#125;`);      &#125;    &#125;,    toHaveBeenCalledTimes(expected) &#123;      let actualCallTimes = 0;      try &#123;        actualCallTimes = actual.mock.calls.length;        expect(actualCallTimes).toEqual(expected);      &#125; catch (err) &#123;        throw new Error(          `expect function: $&#123;actual.originImpl.toString()&#125; to call $&#123;expected&#125; times, but actually call $&#123;actualCallTimes&#125; times`        );      &#125;    &#125;,    toHaveBeenCalledWith(...expectedArgs) &#123;      let actualCallArgs = [];      try &#123;        actualCallArgs = actual.mock.calls;        actualCallArgs.forEach(callArgs =&gt; &#123;          expect(callArgs).toEqual(expectedArgs);        &#125;);      &#125; catch (err) &#123;        throw new Error(          `expect function: $&#123;actual.originImpl.toString()&#125; to be called with $&#123;expectedArgs&#125;, but actually it was called with $&#123;actualCallArgs&#125;`        );      &#125;    &#125;,  &#125;;&#125;;\n别看代码有点长，其实细看很简单对不对。关键点就是对 jest.fn 包裹过后的函数挂载的对象 mock 长度、内容进行断言。这里需要留意的是。我们捕获了 expect(x).toEqual(y) 抛出的错误，抛出了一个对用户更友好的错误。\n终于，我们编写测试用例如下：\n1234567891011test(&#x27;sum should have been called once&#x27;, () =&gt; &#123;  const sumMockFn = jest.fn(sum);  sumMockFn(3, 7);  expect(sumMockFn).toHaveBeenCalledTimes(1);&#125;);test(&#x27;sum should have been called with `3` `7`&#x27;, () =&gt; &#123;  const sumMockFn = jest.fn(sum);  sumMockFn(3, 7);  expect(sum).toHaveBeenCalledWith(3, 7);&#125;);\n成功运行！\n1234$ node test-framework.js ./math.test.js✓ sum should have been called once✓ sum should have been called with `3` `7`\n模块\n经过我们的努力。我们已经做了一个像模像样的测试框架了。但是请等等！现实真的有这么简单么？\n突然需要测试一个新的函数，这个函数好像有点不一样…\n123456789101112// ./user.jsconst &#123; v4: uuidv4 &#125; = require(&#x27;uuid&#x27;);module.exports = &#123;  createUser(&#123; name, age &#125;) &#123;    return &#123;      id: uuidv4(),      name,      age,    &#125;;  &#125;,&#125;;\n我们想要测试这个函数返回带有一个 id 的用户对象，同时也调用了 uuidv4。但是发现这个函数没办法编写测试，因为每次生成的 id 不一样，所以它每次返回对象都不一样。没办法简单的使用 expect(x).toEqual(y)。\n但是我们不可能去测试 uuid 库。因为测试它们是毫无意义的，也是不现实的。\n那怎么办呢？我们还是有办法的。扩展测试框架如下：\n1234567891011121314151617// ./test-framework.jsglobal.jest = &#123;  fn: (impl = () =&gt; &#123;&#125;) =&gt; &#123;    // ...  &#125;,  mock: (mockPath, mockExports = &#123;&#125;) =&gt; &#123;    const path = require.resolve(mockPath);    require.cache[path] = &#123;      id: path,      filename: path,      loaded: true,      exports: mockExports,    &#125;;  &#125;,&#125;;// ...\n我们发现上面的 mock 函数使用 require.resolve 获取了模块加载路径，然后在 require.cache 准备好构造后的缓存导出对象。\n编写测试如下：\n12345678910111213141516171819// ./user.test.jsjest.mock(&#x27;uuid&#x27;, &#123;  v4: () =&gt; &#x27;FAKE_ID&#x27;,&#125;);const &#123; createUser &#125; = require(&#x27;./user&#x27;);test(&#x27;create an user with id&#x27;, () =&gt; &#123;  const userData = &#123;    name: &#x27;Christina&#x27;,    age: 25,  &#125;;  const expectUser = &#123;    ...userData,    id: &#x27;FAKE_ID&#x27;,  &#125;;  expect(createUser(userData)).toEqual(expectUser);&#125;);\n因为 require.cache 的关系，我们需要把 jest.mock 提到文件最前面调用。（jest 里同样的操作不需要提前，那是因为测试框架在运行测试用例时自动提前此类操作了）然后模拟导出的 v4 对象返回一个 FAKE_ID。\n运行测试如下：\n12$ node test-framework.js ./user.test.js✓ create an user with id\n完美解决~\n真实世界里的应用函数往往不会是干净可爱的纯函数，依赖大量第三方流行库进行开发是我们的日常，也是开源世界里一件幸福的事情。\n如何排除第三方依赖库进行测试，基本原理也是如上。\n让它更优雅\n每次都要调用 node test-framework.js ./user.test.js 来运行测试，看上去不是很好。我们让这个测试框架变得更优雅吧！\n嗯，我们给这个测试框架起个名字，就叫 mjest 吧！\n第一步，我们在项目新建 bin 目录，将上文的测试框架的实现丢进 ./bin/mjest.js 中。\n1234$ tree ./bin/./bin/└── mjest.js\n第二步，在 mjest.js 文件顶部加入 Shebang。使用 node 作为默认解释器。\n123#!/usr/bin/env node// mjest code\n第三步，在 package.json 中加入 bin 声明：\n123456789&#123;  &quot;name&quot;: &quot;mjest&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;mini jest implementation&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;bin&quot;: &#123;    &quot;mjest&quot;: &quot;./bin/mjest.js&quot;  &#125;&#125;\n第四步，在项目路径终端下运行 npm link。该命令会将项目的 bin 软链接到系统中 bin 中：\n123$ which mjest/Users/sulirc/.nvm/versions/node/v10.20.1/bin/mjest\n第五步！使用热乎乎刚出炉的 mjest 运行测试用例吧：\n12$ mjest ./user.test.js✓ create an user with id\n12345$ mjest ./math.test.js✓ sum should have been called once✓ sum should have been called with `3` `7`✓ sumAsync adds numbers asynchronously✓ subtractAsync subtracts numbers asynchronously\n我们也可以用 glob 语法更优雅的匹配文件：\n123456$ mjest *.test.js✓ sum should have been called once✓ sum should have been called with `3` `7`✓ create an user with id✓ sumAsync adds numbers asynchronously✓ subtractAsync subtracts numbers asynchronously\n本文的完整测试框架代码，笔者也已经放在 github 上，欢迎阅读：github.com/sulirc/mjes…\n更多\n到此为止，相信大家应该对测试框架原理基本有一定了解了。在 jest 中，还有比如 beforeEach、beforeAll 等钩子函数，大家也可以想办法自己实现。断言库里丰富的断言函数，也可以一个一个击破。\n不断丰富特性，四舍五入，我们就实现了一个测试框架。\n在单元测试的基础上，其实集成测试框架原理也相差不远。因为集成测试其实就是建立在单元测试上的。大家也可以进行思考。\n转载\n深入浅出前端单元测试框架的实现原理\n","plink":"https://becase.top/post/7b5b5d05b31a/"},{"title":"esbuild 为什么快","date":"2022-11-18T12:47:50.000Z","date_formatted":{"ll":"Nov 18, 2022","L":"11/18/2022","MM-DD":"11-18"},"updated":"2024-03-11T03:21:43.674Z","content":"大多数其他打包工具都是用 JavaScript 编写的，但是对于 JIT-compiled（just-in-time compiled，也叫做 run-time compilations、运行时编译，或者也叫做 dynamic translation 动态编译）语言来说，命令行应用程序的性能是最差的。\n每次运行打包器时，Javascript VM 都是第一次看到打包器的代码，没有任何优化提示\n当 esbuild 忙于解析你的 JavaScript 时，node 正忙于解析你的打包器的 JavaScript 代码。当 node 完成你的打包器代码的解析时，esbuild 可能已经退出并且你的打包器甚至还没有开始打包。\n也就是说其他打包器因为使用 JavaScript 编写，于是每次编译开始需要先解析打包器的代码，然后再去实际编译 JavaScript 代码，这样就会更慢。而 Go 不属于动态编译的语言，省去了这个步骤\n速度快的原因\nesbuild 内部打包速度优化的四个原因：\n\nesbuild 是用 Go 语言写的，并且编译为 native code\n大量使用并行，充分利用多核 CPU\nesbuild 中的所有内容都是从头编写的，没有使用第三方库\n内存得到有效利用\n\n下面我们分别来介绍一下：\n1. esbuild 是用 Go 语言写的，并且编译为 native code\n其他大多数打包器，因为使用 JavaScript 编写，于是每次编译开始需要先解析打包器的代码，然后再去实际编译 JavaScript 代码，这样就会更慢。而 Go 不属于动态编译的语言，省去了这个步骤。\n另外，Go 语言的核心是并行性，JavaScript 不是。Go 可以在线程直接共享内存，JavaScript 需要在线程之间序列化数据。Go 和 JavaScript 都有并行的垃圾收集器，但是 Go 的堆在所有线程间共享，JavaScript 每个线程都有单独的堆。根据测试，这似乎使 JavaScript 的并行性减少了一半，可能是因为 CPU 的内核，一半正在忙着为另一半进行垃圾收集。\n2. 大量使用并行\nesbuild 内部使用算法保证充分利用多核 CPU，编译过程有三个阶段：解析（parsing）、链接（linking）和代码生成（code generation），解析和代码生成这两个阶段包括了大部分工作，并且可以完全可以并行去做的（大部分情况下，链接是一个串行的任务）。\n由于上面提到的，所有线程都可以共享内存。当从不同的入口点，打包相同的 JavaScript 库时，任务可以轻松的被共享。大多数计算机都有多核，于是并行性会是一个非常大的优势。\n3. esbuild 中的所有内容都是从头编写的\nesbuild 没有使用第三方库，内容都是自己从头编写的，这样会使架构更加的可扩展，并拥有性能优势\n举个例子，很多打包工具使用了 Typescript 官网的编译器作为解析器，但是 Typescript 官方的解析器并没有把性能当作一个首要的考虑点。\n他们的代码内大量使用了megamorphic object shapes和不必要的dynamic property accesses(这两者会使 JavaScript 的运行速度减慢)\n而且在 Typescript 解析器的类型检查被禁用的情况下，貌似还是会执行类型检查。\nesbuild 自定义了 Typescript 的解析器\n4. 内存得到有效利用\n理想情况下，编译器的复杂度时 O(n)，所以如果你在处理大量的数据，内存的访问速度可能会严重影响性能。修改数据的次数越少，编译器运行的速度就会越快。\n举例来说，esbuild 只涉及三次整个 JavaScript AST\n\n\n\n用于词法分析、解析、作用域设置和符号声明\n\n\n\n\n绑定符号、最小化语法、把 JSX/TS 编译为 JS、把 ES-next 编译为 ES-2015\n\n\n\n\n最小化标识符、最小化空格、生成代码和 source map\n\n\n\n可以最大程度的重复利用 AST，其他打包器将这些步骤分开进行的，不是交叉进行\n","plink":"https://becase.top/post/8c88aca6f150/"},{"title":"web前端加密是否有意义","date":"2022-11-07T14:04:58.000Z","date_formatted":{"ll":"Nov 7, 2022","L":"11/07/2022","MM-DD":"11-07"},"updated":"2024-03-11T03:21:43.677Z","content":"背景\n\n在 web 通信建立在 https 的基础上，是否还需要前端对用户密码的加密?\n\n有人会笑话说这不是废话吗，常识如此（我最开始看到这个问题就是这么想的)\n你若再问我为什么，我不假思索就会来上一句“有助于提高系统用户的安全性”\n可真的能 提高 系统用户的安全性”吗？？\n先回顾一下前后端交互的几个核心诉求\n前后端交互过程中的安全性诉求\n这里借用一个比喻：\nAlice（ 浏览器前端 ）和 Bob（服务器后端）到底可以怎么幽会。这个问题又会涉及到以下这些问题：\n\nAlice 怎么知道 Bob 是 Bob？\nBob 怎么知道 Alice 是 Alice?\nAlice 和 Bob 幽会中的 窃窃私语 如何不被Eve偷听到，甚至被Oscar串改呢？\n\n前两个问题被统称归为 Authenticity（认证），第三个问题可以被归为 Confidentiality（保密） 和 Integrity。\n对于一般人而言，以上三个问题的成熟解决方案实现现有 SSH 和 mTLS ，常用的就是是 HTTPS 即 HTTP over TLS（在 TLS 安全信道上 HTTP 通讯）\n关于系统用户安全性的提升\n直觉上大家都会觉得前端既然加密了，那对 该网站用户认证系统 的整体安全性肯定是有所帮助的，哪怕是 m + n + 1 的帮助也是帮助，即  用户认证安全性 = m + n + 1，（先记住这个概念，后面会再用到）\n\nm 指后端加密\n这里的 n 是指传统的 htttps\n1 则是前端用户加密\n\n实际上并非如此，因为你的这个 n 正是从 1 迭代而来的，二者并没有累加的关系，而是后浪和前浪的关系，以下是解释\nn 和 1 的关系\n先看案例：\n\n如果某一天，这个系统的数据库泄露了，黑客就直接拿到了每个用户的密码 md5 值 \n但此时，由于黑客知道密码是在前端进行哈希的，所以他不需要爆破出该 md5 对应的原文是什么，而是直接修改客户端向服务器发出的请求，把密码字段换成数据库中 MD5 就可以了\n由于与数据库中记录一致，直接就会登录成功。这跟 直接存储 明文密码 没有任何区别！！\n\n在这个类似中间人攻击的案例中，我们再分析 n 和 1 的实际映射对象\n\nn 指对信息传输通道所做的操作，可以是 https 加密传输等其他任何传输方式\n1 指对信息发送源头所做的操作，可以是前端对密文做的一切加密操作\n\n再来看案例中黑客如何爆破这个系统的，他无视掉了 1（对信息发送源头所做的操作），仅仅是干掉了 n（即信息传输通道所做的操作）这一操作，就干掉了这个认证系统\n——即此时认证系统的安全性完全取决于 n\n因此，这个公式应该变成  用户认证安全性 = m + n\n针对这些，现代密码学有一些“反常识”的方法，也能加强这一理解\n现代密码学\n1.A 可以向 B 证明自己拥有一个密码，但是如果 B 是假冒的验证者，A 不会透露关于密码的任何信息给 B。——“零知识证明”\n2.A 可以和 B 比较自己持有的一个值的大小关系，而不泄露这个值给对方。——“百万富翁问题”\n3.A 可以给 B 发来的一段信息进行 电子签名 ，而不知道信息的内容。——“ 盲签名 ”\n4.A 和 B 可以，在没有公正第三人的情况下，进行等概率胜负的博弈。——“电 子博弈 ”\n5.邮件服务，如果不考虑法律风险的话，是可以做到让服务器看不到你的邮件内容的。——PGP\n对用户认证系统安全性并没有帮助\n以上，我们可以明确前端密码加密对用户认证系统安全性 并没有帮助\n有些人会认为前端进行了加密，可以降低后台的安全性需求，这种错误的观念会造成系统的 安全漏洞\n实际上，我们不能对前端做任何的假设，所有跟安全相关的技术，都必须应用在传输通道和后台上\n其他意义\n如果跳出系统用户安全性的这个范围，前端对密码加密还是有一定意义的\n主要是防止这个网站用户密码破解后，被黑客拿去 撞库， 去验证用户在其他平台的账号\n你可能又会问，这不也是加强安全性了吗？不是，这是 社会工程学 上的意义\n每个网站自己的 用户认证安全性 与其他网站的安全性应当是独立的，这只能防止被窃听到原文的密码被攻击者用在社会学攻击上，而不能改善该网站的安全性\n结论\n回到一开始的问题，答案是：Web 前端密码加密没有意义，又有意义\n这个意义跟多数开发者所想的并不一致，它并不能改善该网站的安全性，它体现在社会工程学上\n参考\n Web 前端密码加密是否有意义？\n","plink":"https://becase.top/post/00218782ad69/"},{"title":"关于图灵完备","date":"2022-11-02T16:00:00.000Z","date_formatted":{"ll":"Nov 3, 2022","L":"11/03/2022","MM-DD":"11-03"},"updated":"2024-03-11T03:21:43.678Z","content":"什么是图灵机\n\n图灵机（Turing Machine）是图灵在1936年发表的 “On Computable Numbers, with an Application to the Entscheidungsproblem”（《论可计算数及其在判定性问题上的应用》）中提出的 数学模型\n\n既然是数学模型，它就并非一个实体概念，而是架空的一个想法。在文章中图灵描述了它是什么，并且证明了， 只要图灵机可以被实现，就可以用来解决任何可计算问题 。\n图灵机结构\n\n图灵机的结构包括以下几个部分：\n\n一条无限长的纸带（tape），纸带被分成一个个相邻的格子（square），每个格子都可以写上至多一个字符（symbol）。\n一个字符表（alphabet），即字符的集合，它包含纸带上可能出现的所有字符。其中包含一个特殊的空白字符（blank），意思是此格子没有任何字符。\n一个读写头（head），可理解为指向其中一个格子的指针。它可以读取/擦除/写入当前格子的内容，此外也可以每次向左/右移动一个格子。\n一个状态寄存器（state register），它追踪着每一步运算过程中，整个机器所处的状态（运行/终止）。当这个状态从运行变为终止，则运算结束，机器停机并交回控制权。如果你了解 有限状态机，它便对应着有限状态机里的状态。\n一个有限的指令集（instructions table），它记录着读写头在特定情况下应该执行的行为。可以想象读写头随身有一本操作指南，里面记录着很多条类似于“当你身处编号53的格子并看到其内容为0时，擦除，改写为1，并向右移一格。此外，令下一状态为运行。”这样的命令。其实某种意义上，这个指令集就对应着程序员所写下的程序了。\n\n在计算开始前，纸带可以是完全空白，也可以在某些格子里预先就有写上部分字符作为输入。运算开始时，读写头从某一位置开始，严格按照此刻的配置（configuration），即：\n\n当前所处位置\n当前格子内容\n\n来一步步的对照着指令集去进行操作，直到状态变为停止，运算结束。而后纸带上留下的信息，即字符的序列（比如类似“…011001…”）便作为输出，由人来解码为 自然语言\n要重申一下，以上只是图灵机模型的内容，而非具体的实现。所谓的纸带和读写头都只是图灵提出的抽象概念\n为便于理解打一个比方\n抽象比喻\n算盘虽然不是图灵机（因为它没有无限长的纸带，即无限的存储空间），但它的行为与图灵机一致。每一串算珠都是纸带上的一格，一串算珠上展示的数字便记录着当前格中的字符（可以是空白，可以是 12345 ）\n人类的手即是读写头，可以更改每串算珠的状态。算盘的运行遵循人脑中的算法，当算法结束，算盘停机\n图灵机可以解决什么问题\n假设 上述模型里所说的功能都能被以某种形式物理实现， 那么 任意可计算问题都可以被解决\n\n在计算机领域，或者说自动机领域，我们研究的一切问题都是计算问题（Computational Problem）。它泛指一切与计算相关的问题。\n\n计算问题的一些举例：\n\n给定一个正整数 n，判断它是否是质数\n给定一个 01 序列，把它们按位取反\n\n非计算问题的例子：\n\n今晚吃什么\n为什么太阳从东边升起\n\n计算问题有的可以解决，有的不可解决。这就引出了计算问题的可计算性（Computability）\n如上面的问题 1，我们当然可以找到一个算法来解决判断任意正整数 n 是否为质数的问题（比如从2遍历到 n-1，看 n 是否可以整除它）\n所以，问题 1 就是可计算的。\n也有一些不可计算的计算问题，比如著名的 停机问题（Halting Problem)\n\nHalting Problem: given the description of an arbitrary program and a finite input, decide whether the program finishes running or will run forever.\n\n12345它的表述是这样的：给定一段程序的描述和该程序的一个有效输入，运行此程序，那么程序最终是会终止，还是会死循环下去？它是一个不可判定问题（Undecidable Problem）。即不存在一个 **通用** 算法，可以在任意输入下解决此问题图灵在文章里很优雅的用反证法推翻了假设“假设有这么一个算法可以解决任何停机问题”，从而证明了这样的算法并不存在\n什么是图灵完备\n图灵完备性（Turing Completeness）是针对一套数据操作规则而言的概念。\n数据操作规则可以是一门编程语言，也可以是计算机里具体实现了的指令集。\n当这套规则可以实现图灵机模型里的全部功能时，就称它具有图灵完备性\n常见不完备原因\n图灵不完备的语言常见原因有循环或递归受限(无法写不终止的程序,如 while(true){}; ), 无法实现类似数组或列表这样的数据结构(不能模拟纸带). 这会使能写的程序有限\n缺点\n图灵完备可能带来坏处, 如C++的模板语言, 模板语言是在类型检查时执行, 如果编译器不加以检查,我们完全可以写出使得C++编译器陷入死循环的程序.\n图灵不完备也不是没有意义, 有些场景我们需要限制语言本身. 如限制循环和递归, 可以保证该语言能写的程序一定是终止的.\n直观理解图灵完备——Brainfuck 语言\n如今主流的编程语言（C++，Java，Python，以及等等等等）都是图灵完备的语言\n关于语言优劣之争也只是在其封装、优化等方面，以及因为这些区别而产生的“不同语言适用于不同情况”的争执。如果我们回到最底层，就会发现它们可以实现的功能其实完全一样，并且本质上就是一个图灵机\n在1993年，Urban Müller 发明了 Brainfuck 语言。这门语言可以说是编程语言界的 helloworld 了——它一共只含有 8 个有效字符，每个有效字符就是一条指令\n语言虽然极致轻量，它却是一门图灵完备的编程语言\n\nBrainfuck is fully Turing-complete.\n一门新语言功能语法很复杂，要用数学证明的方式确定性说明它图灵完备会很麻烦，但只要用这门新语言实现一个brainfuck的解释器，那么就必然证明了是图灵完备的\n\n示例\n先贴上一段 BF 的代码，体验一下它的画风：\n1++++++++ [ &gt; ++++ [ &gt; ++ &gt; +++ &gt; +++ &gt; + &lt;&lt;&lt;&lt; - ] &gt; + &gt; + &gt; - &gt;&gt; + [ &lt; ] &lt; - ] &gt;&gt;. &gt; ---. +++++++.. +++. &gt;&gt;. &lt; -. &lt;. +++. ------. --------. &gt;&gt; +. &gt; ++.\n这个程序编译运行后，控制台打印 “Hello World!”。\nBF 的工作机制与图灵机高度一致。首先它存储数据的方式是一个不限长的一维整数数组，里面的数值全部初始化为 0。此外，有一数据指针，每一时刻都指向数组的某一任意元素。指针可以向左/右移动，也可以读取/修改当前值。\n语言里的 8 个有效字符分别是：\n123456789101112131415&gt; 指针向右移动一格&lt; 指针向左移动一格+ 使指针当前格数值加一- 使指针当前格数值减一. 把当前格数值按 ASCII 表输出到终端, 从终端接受一 byte 的数据，存储其 ASCII 数值到当前格[ 当指针当前值为 0 时，程序跳转至与之对应的 ] 之后；否则程序正常执行] 程序跳转回与之对应的 [ 处\n有了这些工具，我们可以很快做出一个计算乘法的程序。因为 ASCII 表中 ‘A’ 对应的值为 65，可以使用 5 * 13 算出 65 并输出得到字符 ‘A’。\n123456+++++[&gt; +++++++++++++&lt; -]&gt;.\n解释：\n\n把指针初始处的格子命名为 cell 0，cell 0 右边的那个格子命名为 cell 1。那么第一句将其递增 5 次变为 5。\n循环执行“右移指针，递增 13 次， 左移指针，递减 1 次”。当 cell 0 的值最终被递减为 0 的时候，循环结束。\n此时 cell 1 的值执行了 5 次“递增 13 次”的操作，即 65。指针右移至 cell 1，输出此格子，则在终端会看到 ‘A’。\n\ngif示例\nBrainfuck Visualizer - FreddieRa - OpenProcessing\n参考\n什么是图灵完备\n","plink":"https://becase.top/post/4bc5dfbd8a5c/"},{"title":"TS类型体操刷题tips","date":"2022-08-27T06:14:33.000Z","date_formatted":{"ll":"Aug 27, 2022","L":"08/27/2022","MM-DD":"08-27"},"updated":"2024-03-11T03:21:43.674Z","content":"类型的运算结果都可以用接口来表示 —— type 声明才是万能的\n重载的简写\n123456789101112131415161718const is: &#123;    (name: string, state: boolean | undefined): string    (name: string): string  &#125; = (name: string, ...args: [boolean | undefined] | []) =&gt; &#123;    const state = args.length &gt;= 1 ? args[0]! : true    return name &amp;&amp; state ? `$&#123;statePrefix&#125;$&#123;name&#125;` : &#x27;&#x27;  &#125;  const B: &#123;    (name: string, state: boolean): string    (name: string): string&#125; = (name: string, ...args: [boolean] | []) =&gt; &#123;    console.log(name, ...args)    return &quot;ss&quot;&#125;B(&quot;cdjk&quot;, false)B(&quot;dfs&quot;)\n泛型中 extends 的约束\n123type MyPick&lt;T, K extends keyof T&gt; = &#123;  [P in K]: T[P] &#125;;\n需要注意的是 K 是一个 union，keyof T 也将 T 中的属性转换为一个 union。当我们使用 extends 来进行条件约束的时候，TS 会使用 union 分发 的特性自动遍历 union K 中的属性与 keyof T 中的属性进行比较。\n假设 K 为 ‘title’ | ‘completed’ | ‘invalid’ ，T 为 ‘title’ | ‘completed’ | ‘description’。它的过程如下\n123step1:  &#x27;title&#x27; extends &#x27;title&#x27; | &#x27;completed&#x27; | &#x27;description&#x27; //通过step2:  &#x27;completed&#x27; extends &#x27;title&#x27; | &#x27;completed&#x27; | &#x27;description&#x27; //通过step3:  &#x27;invalid&#x27; extends &#x27;title&#x27; | &#x27;completed&#x27; | &#x27;description&#x27; //未通过，报错\n如果比较成功则通过，失败则报错，这样我们就实现了所有的关键步骤，通过了所有的测试用例。\nkeyof any\n\nRecord&lt;K, V&gt;\n\n123type MyRecord&lt;K  extends keyof any, V&gt; = &#123;  [key in K]: V&#125;\n注意对象的键值只能是 number | string | symbol ,所以 K 需要被约束\n同时，可以使用 keyof any 来代替 number | string | symbol ，它返回对象键值类型的所有可能\n接口或者枚举类型中的 never\n\nOmit&lt;T, K&gt;\n\n使用 as never 来使一个元素消失。\n在 TS 中如果一个 union 中的元素是一个 never 类型的，那么 TS 认为这个元素是一个空值，会返回去除这个值之后的结果。\ninfer 的使用\n\nParameters&lt; T &gt;\n\n在这个条件语句 T extends (...args: infer P) =&gt; any ? P : T 中，infer P 表示待推断的函数参数。\n整句含义为：如果 T 能赋值给 (...args: infer P) =&gt; any，则结果是 (...args: infer P) =&gt; any 类型中的参数 P，否则返回为 T\ninfer 的作用：在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用\n1type MyParameters&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: infer P) =&gt; any ? P : never;\n以上代码中 infer R 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。\n类中构造器的类型声明方式\n\nConstructorParameters&lt; T &gt;\n\nc:&#123; new(): T &#125; 和 c: new () =&gt; T 是一样的，后者是前者的简写，意即 C 的类型是对象类型且这个对象包含返回类型是 T(类的实例) 的构造函数\n12345678910111213141516// es6, T === new People()class People: new () =&gt; T &#123;    constructor(name, age)&#123;        this.name = name;        this.age = age;    &#125;&#125;// es5var People = /*#__PURE__*/_createClass(function People(name, age) &#123;  _classCallCheck(this, People);  _defineProperty(this, &quot;name&quot;, void 0);  _defineProperty(this, &quot;age&quot;, void 0);  this.name = name;  this.age = age;&#125;);\n字符串字面量和递归\n看到递归的时候，才真正意识到 ts 也是一门编程语言，而不是什么类型的银弹（silver bullet）\n123type LastChar&lt;T extends string&gt; = T extends `$&#123;infer F&#125;$&#123;infer R&#125;` ?  (R extends &#x27;&#x27; ? F : LastChar&lt;R&gt;) : never;\n元祖类型的属性 length\n\nLengthOfTuple&lt; T &gt;\n\n1type LengthOfTuple&lt;T extends any[]&gt; = T[&#x27;length&#x27;]\n关于 T extends $&#123;infer L&#125;.$&#123;infer R&#125;\n如果 T extends 字面量，则 R 表示剩余参数\n如果 T extends 元祖，则 R 表示第二个参数\n关于 Record&lt;string, unknown&gt;\n\nimplement IsEmptyType&lt; T &gt;\n\nRecord&lt;string, unknown&gt; 表示任意对象类型\n1234567// 首先判断是不是对象类型// 其次判断对象的键为空type IsEmptyType&lt;T&gt; =  T extends Record&lt;string, unknown&gt; ?    [keyof T] extends [never] ?      true : false    : false;\nany类型如何表示\n\nimplement IsAny&lt; T &gt;\n\n123456789101112// 想写出这道题必须了解：any 类型在和其他类型进行联合、交叉时等于 any 类型自身type WhatEverType = true;type AnotherWhatEverType = [];type A = WhatEverType &amp; any; // anytype B = WhatEverType | any; // anytype T = WhatEverType extends AnotherWhatEverType &amp; any ? true : false; // truetype Q = WhatEverType extends AnotherWhatEverType | any ? true : false; // truetype IsAny&lt;T&gt; = WhatEverType extends (AnotherWhatEverType &amp; T) ? true : false;// 举例type IsAny&lt;T&gt; = 0 extends 1 &amp; T ? true : false;\n","plink":"https://becase.top/post/2eab1fe53ff5/"},{"title":"SSL建立的三个随机数作用","date":"2022-05-27T14:01:01.000Z","date_formatted":{"ll":"May 27, 2022","L":"05/27/2022","MM-DD":"05-27"},"updated":"2024-03-11T03:21:43.673Z","content":"概述\n首先再重温下 TLS四次握手 的过程：\n\n客户端向服务端发送协议版本号、一个随机数和可以使用的加密方法\n服务端接受后，确认加密的方法，向客户端发送一个随机数和自己数字证书\n客户端首先检查数字证书是否有效，如果有效，就再生成一个随机数，用数字证书提供的公钥加密再发给服务端，同时提供一个前面所有内容的hash值发给服务端以供校验\n服务端接收后，使用自己的私钥对数据解密，同时也发一个前面所有内容的hash值供客户端校验\n\n双方再有了三个随机数之后，按照之前约定的加密方法，使用三个随机数生成一个密钥，之后双方通信，就是用这个密钥对数据加密后再传输\n其中有用到三个随机数，用来做什么，为什么是三个？\n分析\n具体过程，图示如下（1-9）：\n\n其中建立 SSL 的三个随机数分别是：\n\nClientHello 中存在的一个随机数，令为 A\nServerHello 中存在的一个随机数，令为 B\nClientKeyExchange中的随机密码串\n\n随机数的作用\n先看第三个随机数，这是一个被称为 Pre-master secret 的随机密码串，由加密算法提供\n当客户端生成了 Pre-master secret 后，结合原来的 A 和 B 使用算法算出一个 master secret ，根据这个推到出 hash secret和session secret，这两个结果完全是依据三个随机数推到出来的，只有双方知道\n通信：\n\n双方使用对称加密算法进行加密，用hash secret对HTTP报文做一次运算生成一个MAC，附在HTTP报文的后面，然后用session-secret加密所有数据（HTTP+MAC），然后发送。\n接收方则先用session-secret解密数据，然后得到HTTP+MAC，再用相同的算法计算出自己的MAC，如果两个MAC相等，证明数据没有被篡改\n\n\nMAC(Message Authentication Code)称为报文摘要，能够查知报文是否遭到篡改，从而保护报文的完整性\n\n为什么是三个\nSSL协议默认不信任 每个主机都能产生完全随机的随机数， 如果随机数不随机，那么 pre-master secret 就可能被破解（因为密钥交换算法是公开的算法），所以必须引入新的随机因素，那么客户端和服务器加上pre-master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一\n参考\nHTTPS通信的过程的三个随机数的作用\n为什么是三个随机数\n SSL_ 随机数_的作用\n","plink":"https://becase.top/post/6791626c102e/"},{"title":"状态管理工具的演变","date":"2022-05-27T13:47:50.000Z","date_formatted":{"ll":"May 27, 2022","L":"05/27/2022","MM-DD":"05-27"},"updated":"2024-03-11T03:21:43.680Z","content":"概述：把组件之间需要共享的状态抽取出来，遵循特定的约定，统一来管理，让状态的变化可以预测\nStore模式\n将状态存到一个外部变量， this.$root.$data\n123456789101112var store = &#123;  state: &#123;    message: &#x27;Hello!&#x27;  &#125;,  setMessageAction (newValue) &#123;    // 发生改变记录点日志啥的    this.state.message = newValue  &#125;,  clearMessageAction () &#123;    this.state.message = &#x27;&#x27;  &#125;&#125;\n由于store的state值改变方式（mutation）只有通过触发action来操作，因此可以很容易跟踪到state的改变流程，出现错误也能通过日志明确错误位置\n\nstore并没有限制组件只能通过action来修改state\n由这一点演化得出了 Flux 架构\nFlux\nFlux是类似于MVC、MVVM之类的一种思想，它把一个应用分成四个部分\n——View、Action、Dispatcher、Store\n\nView视图层可以是通过vue或者react等框架实现，而View中的数据都是Store，Store改变就抛出一个事件，通知所有的订阅者（或者监听，不同的框架对应不同的数据响应技术）发生改变\nFlux要求，View要想修改Store，必须经过一套流程\n\n视图先要告诉Dispatcher，让Dispatcher dispatch 一个 action\nDispatcher 收到 View 发出的 action，然后转发给Store\nStore就触发相应的action来更新数据\n数据更新则伴随着 View 的更新\n\n注意：\n\nDispatcher的作用是接受所有的 Action。然后发给所有的 Store（Action可能是View触发的，也可能是其他地方触发的，如测试用例）\nStore的改变只能通过Action，Store不应该有公开的 Setter，所有的Setter都应该是私有的，只能有公开的 Getter\n具体Action的处理逻辑一般放在 Store 里\n\nFlux 特点： 单向流动\nRedux\n与 Flux 思想类似，\n但修改了 Flux 的一些特性：\n\n一个应用可以拥有多个Store\n多个Store间可能存在依赖关系\nStore 还封装了处理数据的逻辑\n\n\nStore\nRedux 里面只有一个 Store，整个应用的数据都在这个大 Store 里面。Store 的 State 不能直接修改，每次只能返回一个新的 State。Redux 整了一个 createStore 函数来生成 Store。\n12import &#123; createStore &#125; from &#x27;redux&#x27;;const store = createStore(fn);\nStore 允许使用 store.subscribe 方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。这样不管 View 是用什么实现的，只要把 View 的更新函数 subscribe 一下，就可以实现 State 变化之后，View 自动渲染了。比如在 React 里，把组件的render方法或setState方法订阅进去就行。\nAction\n和 Flux 一样，Redux 里面也有 Action，Action 就是 View 发出的通知，告诉 Store State 要改变。Action 必须有一个 type 属性，代表 Action 的名称，其他可以设置一堆属性，作为参数供 State 变更时参考。\n1234const action = &#123;  type: &#x27;ADD_TODO&#x27;,  payload: &#x27;Learn Redux&#x27;&#125;;\nRedux 可以用 Action Creator 批量来生成一些 Action。\nReducer\nRedux 没有 Dispatcher 的概念，Store 里面已经集成了 dispatch 方法。store.dispatch()是 View 发出 Action 的唯一方法。\n1234567import &#123; createStore &#125; from &#x27;redux&#x27;;const store = createStore(fn);store.dispatch(&#123;  type: &#x27;ADD_TODO&#x27;,  payload: &#x27;Learn Redux&#x27;&#125;);\nRedux 用一个叫做 Reducer 的纯函数来处理事件。Store 收到 Action 以后，必须给出一个新的 State（就是刚才说的Store 的 State 不能直接修改，每次只能返回一个新的 State），这样 View 才会发生变化。这种 State 的计算过程就叫做 Reduce\n\n纯函数，即没有任何副作用\n\n对于相同的输入，永远都只会有相同发输出\n不会影响挖补的变量，也不会被外部变量影响\n不能改写参数\n\n\nRedux根据应用的状态和当前的 action 推导出新的 state：(previousState, action) =&gt; newState\n类比 Flux：(state, action) =&gt; state\n123question: 为什么叫做 Reducer 呢?—— reduce 是一个函数式编程的概念，经常和 map 放在一起说，简单来说，map 就是映射，reduce 就是归纳。映射就是把一个列表按照一定规则映射成另一个列表，而 reduce 是把一个列表通过一定规则进行合并，也可以理解为对初始值进行一系列的操作，返回一个新的值\n整体流程\n1、用户通过 View 发出 Action：\n1store.dispatch(action);\n2、然后 Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State 。\n1let nextState = xxxReducer(previousState, action);\n3、State 一旦有变化，Store 就会调用监听函数。\n1store.subscribe(listener);\n4、listener可以通过 store.getState() 得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。\n1234function listerner() &#123;  let newState = store.getState();  component.setState(newState);   &#125;\n对比 Flux\n和 Flux 比较一下：Flux 中 Store 是各自为战的，每个 Store 只对对应的 View 负责，每次更新都只通知对应的View：\n\nRedux 中各子 Reducer 都是由根 Reducer 统一管理的，每个子 Reducer 的变化都要经过根 Reducer 的整合：\n\n简单来说，Redux有三大原则： 单一数据源：Flux 的数据源可以是多个。 State 是只读的：Flux 的 State 可以随便改。 * 使用纯函数来执行修改：Flux 执行修改的不一定是纯函数。\nRedux 和 Flux 一样都是单向数据流\n与React 关系\nRedux 和 Flux 类似，只是一种思想或者规范，它和 React 之间没有关系。Redux 支持 React、Angular、Ember、jQuery 甚至纯 JavaScript。\n但是因为 React 包含函数式的思想，也是单向数据流，和 Redux 很搭，所以一般都用 Redux 来进行状态管理。为了简单处理 Redux 和 React UI 的绑定，一般通过一个叫 react-redux 的库和 React 配合使用，这个是 react 官方出的（如果不用 react-redux，那么手动处理 Redux 和 UI 的绑定，需要写很多重复的代码，很容易出错，而且有很多 UI 渲染逻辑的优化不一定能处理好）。\nRedux将React组件分为容器型组件和展示型组件，容器型组件一般通过connect函数生成，它订阅了全局状态的变化，通过mapStateToProps函数，可以对全局状态进行过滤，而展示型组件不直接从global state获取数据，其数据来源于父组件。\n\n如果一个组件既需要UI呈现，又需要业务逻辑处理，那就得拆，拆成一个容器组件包着一个展示组件。\nRedux-saga\nRedux处理异步操作，添加中间件后的产物\n官方文档：Redux-Saga\nDva\n官方定义：dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架\n简单理解，就是让使用 react-redux 和 redux-saga 编写的代码组织起来更合理，维护起来更方便\n\n之前我们聊了 redux、react-redux、redux-saga 之类的概念，大家肯定觉得头昏脑涨的，什么 action、reducer、saga 之类的，写一个功能要在这些js文件里面不停的切换。dva 做的事情很简单，就是让这些东西可以写到一起，不用分开来写了\n\n比如：\n123456789101112131415161718192021222324252627282930313233343536// 以前书写的方式是创建 sagas/products.js, reducers/products.js 和actions/products.js，然后把 saga、action、reducer 啥的分开来写，来回切换app.model(&#123;  // namespace - 对应 reducer 在 combine 到 rootReducer 时的 key 值  namespace: &#x27;products&#x27;,  // state - 对应 reducer 的 initialState  state: &#123;    list: [],    loading: false,  &#125;,  // subscription - 在 dom ready 后执行  subscriptions: [    function(dispatch) &#123;      dispatch(&#123;type: &#x27;products/query&#x27;&#125;);    &#125;,  ],  // effects - 对应 saga，并简化了使用  effects: &#123;    [&#x27;products/query&#x27;]: function*() &#123;      yield call(delay(800));      yield put(&#123;        type: &#x27;products/query/success&#x27;,        payload: [&#x27;ant-tool&#x27;, &#x27;roof&#x27;],      &#125;);    &#125;,  &#125;,  // reducers - 就是传统的 reducers  reducers: &#123;    [&#x27;products/query&#x27;](state) &#123;      return &#123; ...state, loading: true, &#125;;    &#125;,    [&#x27;products/query/success&#x27;](state, &#123; payload &#125;) &#123;      return &#123; ...state, loading: false, list: payload &#125;;    &#125;,  &#125;,&#125;);\nMobX\n官网：MobX 中文文档\n对比 Flux 体系的单向数据流方案，Mobx 的思想则是 ：任何源自应用状态的东西都应该自动地获得 ——状态只要一变，其他用到状态的地方就都跟着自动变\n\nFlux 或者说 Redux 的思想主要就是函数式编程（FP）的思想，所以学习起来会觉得累一些。而 MobX 更接近于面向对象编程，它把 state 包装成可观察的对象，这个对象会驱动各种改变。什么是可观察？就是 MobX 老大哥在看着 state 呢。state 只要一改变，所有用到它的地方就都跟着改变了。这样整个 View 可以被 state 来驱动。\n1234567891011const obj = observable(&#123;    a: 1,    b: 2&#125;)autoRun(() =&gt; &#123;    console.log(obj.a)&#125;)obj.b = 3 // 什么都没有发生obj.a = 2 // observe 函数的回调触发了，控制台输出：2\n上面的obj，他的 obj.a 属性被使用了，那么只要 obj.a 属性一变，所有使用的地方都会被调用。autoRun 就是这个老大哥，他看着所有依赖 obj.a 的地方，也就是收集所有对 obj.a 的依赖。当 obj.a 改变时，老大哥就会触发所有依赖去更新\nMobX 和 Flux、Redux 一样，都是和具体的前端框架无关的，也就是说可以用于 React（mobx-react) 或者 Vue（mobx-vue)。一般来说，用到 React 比较常见，很少用于 Vue，因为 Vuex 本身就类似 MobX，很灵活。如果我们把 MobX 用于 React 或者 Vue，可以看到很多 setState() 和 this.state.xxx = 这样的处理都可以省了。\n参考\nVuex、Flux、Redux、Redux-saga、Dva、MobX\n","plink":"https://becase.top/post/b1934196b4f0/"},{"title":"http协议的发展历程","date":"2022-05-26T14:02:58.000Z","date_formatted":{"ll":"May 26, 2022","L":"05/26/2022","MM-DD":"05-26"},"updated":"2024-03-11T03:21:43.674Z","content":"http1 的缺点\nhttp1.1 提出支持长链接和管道化。\n长链接：即可以在一个 http 连接上传输多个请求&amp;响应（http1.1 之前每个 http 链接只可以传输一对请求&amp;响应然后就断开链接）。\b 在没有管道化的情况下，一个连接上的下一个请求需要在前一个响应返回后再发出。（并发请求只能通过同时建立多个连接实现）\n问题：\n\n串行传输\nhttp同域并发连接限制带来的阻塞（6~8）个\n\n管道化：可以在一个 http 链接上同时发送多个请求 （可以克服同域并行连接限制带来的阻塞）\n\n服务器可以同时处理多个请求，但是必须按照请求的顺序返回结果（即使后面的请求先处理完成也还是需要缓存起来，等前面的请求处理完返回之后再返回）（对头阻塞：如果前一个请求处理的时间过长或者被无线挂起，那么后面的请求就会排队等待）\n\n问题：\n\nHTTP 请求无法很好地利用多路复用，不允许一个连接上的多个响应数据交错返回(多路复用)。因而一个响应必须完全返回后，下一个响应才会开始传输。\n对头阻塞\n\n线头阻塞\nHTTP 管线化要求服务器按照接收到的请求顺序进行响应，如果管线化中的单个请求执行得很慢，客户端的后续 响应 也会相应的延迟下去\n\n解决办法\n客户端在主机上建立多个 TCP 连接\n\n连接的开销并没有消失\n\n再加上 ssl/tls 的加密通信使用，大多数浏览器设置了 最大可能同时连接数 来寻求平衡\n为什么限制并发连接数？\n\n每个连接都需要占用一些服务器的资源，服务器需要维持每一个连接请求的信息，因此过多的连接数意味着服务器的负担很大。\nDos 攻击：DOS(A Denial of Service) 攻击意味着让服务器忙于跟你打交道，以至于他无法跟其他客户端打交道。当其他客户端无法连接，这就是 DOS。\n\nhttp2\n多路复用\n在 HTTP/1.X 中数据是基于文本的有序传输，不能并行传输而且接收端也不知道数据包的顺序。但 HTTP/2 中新的二进制分帧层突破了这些限制，实现了完整的请求和响应复用: 客户端和服务器可以将 HTTP 消息分解为互不依赖的帧，然后交错发送，最后再在另一端把它们重新组装起来。\n\n并行交错地发送多个请求，请求之间互不影响。\n并行交错地发送多个响应，响应之间互不干扰。\n使用一个连接并行发送多个请求和响应。\n消除不必要的延迟和提高现有网络容量的利用率，从而减少页面加载时间\n\n针对队头阻塞\n\n谷歌在 2008 年发布了 Chrome 浏览器，这种浏览器因其快速和创新而迅速流行。它使谷歌在互联网技术问题上获得了强大的话语权。在 2010 年代初期，谷歌在 Chrome 中增加了对其 Web 协议 SPDY 的支持。\nHTTP/2 标准基于 SPDY，并进行了一些改进\n\nHTTP/2 通过在单个打开的 TCP 连接上多路复用 HTTP 请求，解决了线头阻塞问题\n这允许服务器以任何顺序响应请求，然后客户端可以在接收到响应时重新组合响应，从而在单个连接中加快整个交换的速度。\n\n\n实际上，使用 HTTP/2 服务器甚至可以在请求之前就将资源提供给客户端！举个例子，如果服务器知道客户端很可能需要样式表来显示 HTML 页面，它可以将 CSS“推”到客户端，而无需等待相应的请求。虽然这从理论上讲是有益的，但此功能在实践中很少见，因为它需要服务器了解其服务的 HTML 结构，但这种情况很少发生。\n\nTCP 队头阻塞\n\n\nTCP 的队头阻塞并没有彻底解决： TCP 为了保证可靠传输，有一个“超时重传”机制，丢失的包必须等待重传确认\n\n\nhttp2 虽然很好的解决了 HTTP 队头阻塞的问题。但是 http2 仍然会存在 TCP 队头阻塞的问题，因为 http2 还是基于 TCP 协议  实现的。\nTCP 传输过程中会把数据拆分成一个一个小的有序的数据包，然后经过路由器、集线器、交换机等中间设备转发，最终到达目的地。如果其中某一个数据包没有按序到达，接收端就会保持连接等待数据包返回。这时就会阻塞后续的请求，就造成了 TCP 队头阻塞。\nHTTP/1.1 管道化持久连接也是使得同一个 TCP 连接可以被多个 HTTP 使用，但是 HTTP/1.1 中规定一个域名可以有 6 个 TCP 连接\n而 HTTP/2 中，同一个域名只使用一个 TCP 连接，一旦 HTTP/2 中 TCP 队头阻塞所造成的影响会更大，因为 HTTP/2 的多路复用技术使得多个请求其实是基于同一个 TCP 连接的，如果某一个请求造成了 TCP 队头阻塞，那么多个请求都会受到影响。\n建立连接时间长\n多路复用容易 Timeout： 大批量的请求同时发送，由于 HTTP2 连接内存在多个并行的流，而网络带宽和服务器资源有限，每个流的资源会被稀释，虽然它们开始时间相差更短，但却都可能超时\nhttp3\n针对tcp队头阻塞\nTCP协议在收到数据包之后，这部分数据可能是乱序到达的，但是TCP必须将所有数据收集排序整合后给上层使用，如果其中某个包丢失了，就必须等待重传，从而出现某个丢包数据阻塞整个连接的数据使用。\nQUIC协议是基于UDP协议实现的，在一条链接上可以有多个流，流与流之间是互不影响的，当一个流出现丢包影响范围非常小，从而解决队头阻塞问题。\n针对http2的tcp连接时间长\n前面说到 HTTP2 连接基本上要花到2~3个RTT才能完成连接，但QUIC基本上可以实现1或0RTT去完成连接的。\n如果是首次需要花1RTT去完成连接，但如果非首次连接0RTT就可以完成了，这是因为首次连接时会缓存配置文件，后续再连接时就可以直接使用，从而跳过1RTT，实现0RTT的业务数据交互\n自身特点\n\n实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。\n集成了 TLS 加密功能。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。\n实现了 HTTP/2 中的多路复用功能。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。\n\n落地的一些困难\n\n动了底层协议，所以 HTTP/3 的增长会比较缓慢，这和 HTTP/2 有着本质的区别\n\n第一，从目前的情况来看，服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持。Chrome 虽然在数年前就开始支持 Google 版本的 QUIC，但是这个版本的 QUIC 和官方的 QUIC 存在着非常大的差异。\n第二，部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。\n第三，中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～7% 的丢包率。\n三个版本在数据传输上的体现\nHTTP/1.1\n\nHTTP/2\n\nQUIC\n\nRTT和RTO\n\nRTT(Round Trip Time)：一个连接的往返时间，即数据发送时刻到接收到确认的时刻的差值；\nRTO(Retransmission Time Out)：重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传, RTO协议实现值最小1s\n\nRTT 和 RTO 的关系是：由于网络波动的不确定性，每个RTT都是动态变化的，所以 RTO 也应随着 RTT 动态变化。\n\n当 RTO &lt; RTT 时, 将会触发大量的重传, 当 RTO &gt; RTT 时候, 如果频繁出现丢包, 重传不及时, 又会造成网络的反应慢, 最好的结果是 RTO 略大于 RTT.\n\n参考\n从 HTTP 到 HTTP/3 的发展简史_文化\nHTTP/2、HTTP/3的一些新特性及优缺点 - 掘金\n","plink":"https://becase.top/post/1a3bc5791c68/"},{"title":"关于js中一些看上去简单又不会写的题","date":"2022-05-13T14:08:08.000Z","date_formatted":{"ll":"May 13, 2022","L":"05/13/2022","MM-DD":"05-13"},"updated":"2024-03-11T03:21:43.678Z","content":"x !== x 返回true\n1234const x = ? // Please fill in the value of &quot;x?if (x !== x) &#123;  console.log(&#x27;hello fatfish&#x27;)&#125;\n如果你有仔细阅读 es6 的教程的话，就知道这个问题是一个典型的demo\n1234567const x = NaN // Please fill in the value of &quot;x?if (x !== x) &#123;  console.log(&#x27;hello fatfish&#x27;)&#125;console.log(NaN === NaN) // falseconsole.log(x !== x) // trueconsole.log(Number.isNaN(x)) // true\n(!isNan(x) &amp;&amp; x !== x) 返回 true\n现在难度提高\n1234const x = ? // Please fill in the value of &quot;x?if(!isNaN(x) &amp;&amp; x !== x) &#123;  console.log(&#x27;hello fatfish&#x27;)&#125;\n你知道 Object.defineProperty() 吗？\n请参考Object.defineProperty() - JavaScript | MDN\n123456789window.x = 0 // Any value is OKObject.defineProperty(window, &#x27;x&#x27;, &#123;  get () &#123;    return Math.random()  &#125;&#125;)console.log(x) // 0.12259077808826002console.log(x === x) // falseconsole.log(x !== x) // true\n如何使得 x === x+1\n使用极大值  Number.MAX_SAFE_INTERGER\n参考 Number.MAX_SAFE_INTEGER - JavaScript | MDN\n1234const x =  Number.MAX_SAFE_INTEGER + 1// Please fill in the value of &quot;x?if (x === x + 1) &#123;  console.log(&#x27;hello fatfish&#x27;)&#125;\n如何使得 x &gt; x\n使用 Symbol.toPrimitive\n1234567891011const x = &#123; // Please fill in the value of &quot;x?  value: 1,  [ Symbol.toPrimitive ] () &#123;    console.log(&#x27;x&#x27;, this.value)    return --this.value  &#125;&#125;if (x &gt; x) &#123;  console.log(&#x27;hello fatfish&#x27;)&#125;\n实现 typeof x === ‘undefined’ &amp;&amp; x.length &gt; 0\n答案是 document.all()\n12345678const x = document.all // Please fill in the value of &quot;x?if(typeof x === &#x27;undefined&#x27; &amp;&amp; x.length &gt; 0) &#123;  console.log(&#x27;hello fatfish&#x27;)&#125;console.log(x)console.log(typeof x)console.log(x === undefined)\n参考 javascript - Why is document.all falsy? - Stack Overflow\n","plink":"https://becase.top/post/ea74b6772450/"},{"title":"为Vue组件添加非响应式数据","date":"2022-04-27T13:47:50.000Z","date_formatted":{"ll":"Apr 27, 2022","L":"04/27/2022","MM-DD":"04-27"},"updated":"2024-03-11T03:21:43.677Z","content":"\nvue的数据来源包括 data，computed，自定义options(vm.$options)，实例外(export default外)\n\n在vue组件中data内函数返回的对象默认是响应式的，这种响应式被用在模板更新、watch变更、computed依赖\n此外还有一种场景，数据本身并不需要响应式，多见于 常量 或者一些第三方库，这里就总结下添加非响应式数据的几种方式\n避免把数据挂载到data内函数返回的对象上\n1. 将数据定义在export default之外\n123456const bigData = &#123;  ...&#125;export default &#123;  ...&#125;\n\n不能在模板内使用\n其中一个实例对象的内改变数据，另一个对象内的数据也会被改变\n\n实质是定义在组件这个类上面的，是类的内部变量，被所有实例对象共享\n\n\n\n应用场景：不需要在模板内使用的常量、不变配置项等\n2. 将数据定义在组件的自定义属性中\n1234567891011export default &#123;  ···  bigData: &#123; // 自定义属性    ....  &#125;,  methods: &#123;    doSomething() &#123;      return this.$options.bigData // 访问方式    &#125;  &#125;&#125;\n\n弊端在于数据的定义被分在了2个地方，添加的自定义属性对不了解的人会产生误解，使用时也会增加调用链\n如果数据更改，需要手动调用this.$forceUpdate()才能使模板更新\n\n利用Vue无法检测对象属性的添加来实现\n\n受现代 JavaScript 的限制 (而且 Object.observe 也已经被废弃)，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的\n\n3. 在created或者mounted中使用 this.bigData\n待实例完成初始化observe后，加入属性\n1234567891011export default &#123;  data() &#123;    return &#123;&#125;  &#125;,  created() &#123;    this.bigData = &#123;      ···    &#125;  &#125;  ···&#125;\n\n同样的，数据的定义被分在了2个地方\n\n剖析observe函数来寻找办法\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122function initData (vm: Component) &#123;  let data = vm.$options.data  data = vm._data = typeof data === &#x27;function&#x27;    ? getData(data, vm)    : data || &#123;&#125;  if (!isPlainObject(data)) &#123;    data = &#123;&#125;    process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(      &#x27;data functions should return an object:\\n&#x27; +      &#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;,      vm    )  &#125;  // proxy data on instance  const keys = Object.keys(data)  const props = vm.$options.props  const methods = vm.$options.methods  let i = keys.length  while (i--) &#123;    const key = keys[i]    if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;      if (methods &amp;&amp; hasOwn(methods, key)) &#123;        warn(          `Method &quot;$&#123;key&#125;&quot; has already been defined as a data property.`,          vm        )      &#125;    &#125;    if (props &amp;&amp; hasOwn(props, key)) &#123;      process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(        `The data property &quot;$&#123;key&#125;&quot; is already declared as a prop. ` +        `Use prop default value instead.`,        vm      )    &#125; else if (!isReserved(key)) &#123;      proxy(vm, `_data`, key)    &#125;  &#125;  // observe data  observe(data, true /* asRootData */)&#125;export class Observer &#123;  value: any;  dep: Dep;  vmCount: number; // number of vms that have this object as root $data  constructor (value: any) &#123;    this.value = value    this.dep = new Dep()    this.vmCount = 0    def(value, &#x27;__ob__&#x27;, this)    if (Array.isArray(value)) &#123;      if (hasProto) &#123;        protoAugment(value, arrayMethods)      &#125; else &#123;        copyAugment(value, arrayMethods, arrayKeys)      &#125;      this.observeArray(value)    &#125; else &#123;      this.walk(value)    &#125;  &#125;  /**   * Walk through all properties and convert them into   * getter/setters. This method should only be called when   * value type is Object.   */  walk (obj: Object) &#123;    const keys = Object.keys(obj)  // 切入口2    for (let i = 0; i &lt; keys.length; i++) &#123;      defineReactive(obj, keys[i])    &#125;  &#125;  // 省略&#125;  /** * Define a reactive property on an Object. */export function defineReactive (  obj: Object,  key: string,  val: any,  customSetter?: ?Function,  shallow?: boolean) &#123;  const dep = new Dep()  const property = Object.getOwnPropertyDescriptor(obj, key)  if (property &amp;&amp; property.configurable === false) &#123;  // 切入口3    return  &#125;  // 省略响应式处理代码&#125;/** * Attempt to create an observer instance for a value, * returns the new observer if successfully observed, * or the existing observer if the value already has one. */export function observe (value: any, asRootData: ?boolean): Observer | void &#123;  if (!isObject(value) || value instanceof VNode) &#123;    return  &#125;  let ob: Observer | void  if (hasOwn(value, &#x27;__ob__&#x27;) &amp;&amp; value.__ob__ instanceof Observer) &#123;    ob = value.__ob__  &#125; else if (    shouldObserve &amp;&amp;    !isServerRendering() &amp;&amp;    (Array.isArray(value) || isPlainObject(value)) &amp;&amp;    Object.isExtensible(value) &amp;&amp;  // 切入口1    !value._isVue  ) &#123;    ob = new Observer(value)  &#125;  if (asRootData &amp;&amp; ob) &#123;    ob.vmCount++  &#125;  return ob&#125;\n4. 使用Object.preventExtensions和Object.seal\n\nObject.isExtensible(value)返回为false\n\npreventExtensions\n123456789export default &#123;  data() &#123;    return &#123;      bigData: Object.preventExtensions(&#123;        ···      &#125;)    &#125;  &#125;&#125;\nObject.freeze()\n123456789101112131415161718192021222324let a = &#123; prop: 1, prop2: 2 &#125; // undefinedObject.freeze(a) // &#123;prop: 1, prop2: 2&#125;a.prop = 3 // 3a // &#123;prop: 1, prop2: 2&#125;// Object.freeze()冻结的是值，仍然可以将变量的引用替换掉a = &#123;prop44: 44&#125; // &#123;prop44: 44&#125;a // &#123;prop44: 44&#125;// 注意区分const和Object.freeze// const表示声明常量 不能再赋值 且声明时必须初始化const TEST = 1TEST = 2 // 报错:TypeError: Assignment to constant variable.function deepFreeze (obj) &#123;  let names = Object.getOwnPropertyNames(obj)  names.forEach(name =&gt; &#123;    var property = obj[name]    if (typeof(property) === &#x27;object&#x27; &amp;&amp; property !== null) &#123;      deepFreeze(property)    &#125;    return Object.freeze(property)  &#125;)&#125;\n当bigData值改变时，都需要重新调用一次\n123updateBigData (newBigData) &#123;    this.bigData = Object.preventExtensions(newBigData)  &#125;\n这种写法bigData属性是响应式的，值改变后模板会自动更新；当然如果是bigData某个属性改变，仍然需要手动调用this.$forceUpdate()\n5. 使属性不可枚举\n\n使挂载的数据key不在Object.keys(obj)返回的数组中\n\n1234567891011121314export default &#123;  data() &#123;    const data = &#123;      bigData: &#123;        ···      &#125;      ··· // 其他属性    &#125;    Object.defineProperty(data, &#x27;bigData&#x27;, &#123;      enumerable: false    &#125;)    return data  &#125;&#125;\n整体对比\n\n参考\nObject.freeze() - JavaScript | MDN\nObject.isFrozen() - JavaScript | MDN\nvue性能提升-非响应式数据\n","plink":"https://becase.top/post/2dcec0d0fdc0/"},{"title":"vue转react快速上手","date":"2022-04-25T13:52:01.000Z","date_formatted":{"ll":"Apr 25, 2022","L":"04/25/2022","MM-DD":"04-25"},"updated":"2024-03-11T03:21:43.676Z","content":"JSX\n先介绍 React 唯一的一个语法糖：JSX。\n1234&lt;div class=&#x27;box&#x27; id=&#x27;content&#x27;&gt;  &lt;div class=&#x27;title&#x27;&gt;Hello&lt;/div&gt;  &lt;button&gt;Click&lt;/button&gt;&lt;/div&gt;\n上面的 DOM 结构可以看出，要每个标签只有 3 个信息：标签名、属性、子元素，所以上面等同于下面的 JSON 结构：\n12345678910111213141516&#123;  tag: &#x27;div&#x27;,  attrs: &#123; className: &#x27;box&#x27;, id: &#x27;content&#x27;&#125;,  children: [    &#123;      tag: &#x27;div&#x27;,      arrts: &#123; className: &#x27;title&#x27; &#125;,      children: [&#x27;Hello&#x27;]    &#125;,    &#123;      tag: &#x27;button&#x27;,      attrs: null,      children: [&#x27;Click&#x27;]    &#125;  ]&#125;\n当你写下这个 React 组件时：\n12345import React from &#x27;react&#x27;;function MyComponent(props) &#123;    return &lt;div&gt;&#123;props.hello&#125;&lt;/div&gt;&#125;\n最终会被自动工具翻译成：\n12345import React from &#x27;react&#x27;;function MyComponent(props) &#123;    return React.createElement(&#x27;div&#x27;, null, props.hello);&#125;\n理解 JSX 语法并不困难，简单记住一句话，遇到 &#123;&#125; 符号内部解析为 JS 代码，遇到成对的 &lt;&gt; 符号内部解析为 HTML 代码。React 就是通过这个小小语法糖，实现在 JS 里面写 HTML，可能有小伙伴会说 HTML 与 JS 分离不是更好吗？责职分明，混合只会更乱。但当你体验到代码自动提示，自动检查，以及调试时精确定位到一行代码的好处时，就清楚 React 和 Vue 的差距了。\n语法糖转换\n习惯 Vue 的同学都知道很多语法糖，比如 v-if、v-for、v-bind、v-on 等，相比 Vue，React 只有一个语法糖，那就是 jsx/tsx。v-if 这些功能在 React 上都是通过原生 javascript 实现的，慢慢你会发现，其实你学的不是 React，而是 Javascipt，React 赋予你通过 js 完整控制组件的能力，这部分明显比 Vue 的语法糖更加灵活，糖太多容易引来虫子（Bug）。 \nv-if 条件渲染\nvue 中写法是这样：\n123456789101112131415161718&lt;template&gt;  &lt;div&gt;    &lt;h1 v-if=&quot;awesome1&quot;&gt;Vue is awesome!&lt;/h1&gt;    &lt;h1 v-else&gt;else&lt;/h1&gt;    &lt;h1 v-if=&quot;awesome2&quot;&gt;Oh no&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123;  data: function() &#123;    return &#123;      awesome1: true,      awesome2: false,    &#125;  &#125;&#125;&lt;/script&gt;\n在 React 函数组件中只需这样：\n123456789101112131415import React, &#123; useState &#125; from &#x27;react&#x27;;function Index() &#123;  const [awesome1, setAwesome1] = useState(true);  const [awesome2, setAwesome2] = useState(false);  return (    &lt;div&gt;      &#123;awesome1 ? &lt;h1&gt;React is awesome!&lt;/h1&gt; : &lt;h1&gt;Oh no&lt;/h1&gt;&#125;      &#123;awesome2 &amp;&amp; &lt;h1&gt;React is awesome!&lt;/h1&gt;&#125;    &lt;/div&gt;  );&#125;export default Index;\n只需使用 js 三目运算符语法即可完成条件渲染的功能。或者使用 &amp;&amp; 逻辑，记住下面一句话就能过理解了：\n\n遇到 &#123;&#125; 符号内部解析为 JS 代码，遇到成对的 &lt;&gt; 符号内部解析为 HTML 代码\n\nv-for 列表渲染\nVue 中写法：\n1234567891011121314151617&lt;template&gt;  &lt;ul id=&quot;array-rendering&quot;&gt;    &lt;li v-for=&quot;item in items&quot;&gt;      &#123;&#123; item.message &#125;&#125;    &lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123;  data() &#123;    return &#123;      items: [&#123; message: &#x27;Foo&#x27; &#125;, &#123; message: &#x27;Bar&#x27; &#125;]    &#125;  &#125;&#125;&lt;/script&gt;\nReact 写法：\n12345678910111213import React, &#123; useState &#125; from &#x27;react&#x27;;function Index() &#123;  const [items, setItems] = useState([&#123; message: &#x27;Foo&#x27; &#125;, &#123; message: &#x27;Bar&#x27; &#125;]);  return (    &lt;ul id=&quot;array-rendering&quot;&gt;      &#123;items.map((item, id) =&gt; &lt;li key=&#123;id&#125;&gt;&#123;item.message&#125;&lt;/li&gt;)&#125;    &lt;/ul&gt;  );&#125;export default Index;\nReact 通过 js 的数组语法 map，将数据对象映射为 DOM 对象。只需学会 js，无需记住各种指令，如果要做列表过滤，直接使用 items.filter(...).map(...) 链式调用即可，语法上更加灵活，如果为了提高渲染性能，使用 useMemo 进行优化即可，类似 Vue 的 computed。\nv-model\nVue 中 v-model 是一个数据绑定语法糖，本质上还是单向数据流，下面的子组件通过 update:title 同步 title 参数。\n123456789101112app.component(&#x27;my-component&#x27;, &#123;  props: &#123;    title: String  &#125;,  emits: [&#x27;update:title&#x27;],  template: `    &lt;input      type=&quot;text&quot;      :value=&quot;title&quot;      @input=&quot;$emit(&#x27;update:title&#x27;, $event.target.value)&quot;&gt;  `&#125;)\nReact 写法较为简单，不需要像 Vue 一样填鸭代码，记住各种规则，所有数据和事件通过 props 传递就行了：\n1234567891011121314import React from &#x27;react&#x27;;interface Props &#123;  title: string;  onUpdateTitle: (title: string) =&gt; void;&#125;function MyComponent(props: Props) &#123;  return &lt;input    type=&#x27;text&#x27;    value=&#123;props.title&#125;    onInput=&#123;e =&gt; props.onUpdateTitle(e.target.value)&#125;  /&gt;&#125;\n更加容易整合 typescript 实现类型推断，需要的逻辑都由 JS 完成，无需记住各种指令、使用方法，参数命名规则。\n事件处理\nVue 中写法\n12345678910111213141516&lt;template&gt;  &lt;div id=&quot;inline-handler&quot;&gt;    &lt;button @click=&quot;say(&#x27;hi&#x27;)&quot;&gt;Say hi&lt;/button&gt;    &lt;button @click=&quot;say(&#x27;what&#x27;)&quot;&gt;Say what&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123;  methods: &#123;    say(message) &#123;      alert(message)    &#125;  &#125;&#125;&lt;/script&gt;\nReact 写法：\n1234567891011121314import React, &#123; useState &#125; from &#x27;react&#x27;;function Index() &#123;  const onClick = (message) =&gt; () =&gt; alert(message);  return (    &lt;div id=&quot;inline-handler&quot;&gt;      &lt;button onClick=&#123;onClick(&#x27;hi&#x27;)&#125;&gt;Say hi&lt;/button&gt;      &lt;button onClick=&#123;onClick(&#x27;what&#x27;)&#125;&gt;Say what&lt;/button&gt;    &lt;/div&gt;  );&#125;export default Index;\n这里用了函数柯里化，一般事件处理这样就行了：\n12345678910111213import React from &#x27;react&#x27;;function Index() &#123;  const onClick = () =&gt; alert(&#x27;hi&#x27;);  return (    &lt;div id=&quot;inline-handler&quot;&gt;      &lt;button onClick=&#123;onClick&#125;&gt;Say hi&lt;/button&gt;    &lt;/div&gt;  );&#125;export default Index;\n如果需要优化缓存事件处理函数，使用 useCallback 即可。可以看到 Vue 中的事件触发 this.$emit('click') 或者父组件中的代码 v-on=&quot;say('hi')&quot; 都使用了字符串的写法，这样非常不利于类型推断，不利于代码重构。React 的函数写法或者 class 写法都直接使用 js 语法，没有而外的东西，相比 Vue 更容易通过 IDE 进行重构优化。React 中无论方法还是变量，都是采用驼峰命名法，也可以自由定制，Vue 中必须混合小写中隔线、驼峰、字符串组合，不利于统一代码规范。\n插槽\nVue 中写法：\n1234567891011&lt;template&gt;  &lt;button class=&quot;btn-primary&quot;&gt;    &lt;slot&gt;&lt;/slot&gt;  &lt;/button&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123;  methods: &#123;&#125;&#125;&lt;/script&gt;\nReact 写法：\n1234567891011import React from &#x27;react&#x27;;function Index() &#123;  return (    &lt;button classNames=&quot;btn-primary&quot;&gt;      &#123;props.children&#125;    &lt;/button&gt;  );&#125;export default Index;\nReact 的插槽写法没有 Vue 那么复杂，也没有“备用内容”、“具名插槽”、“渲染作用域”、“作用域插槽”、“动态插槽名”，这些概念和特殊情况的处理，一切通过 JS 逻辑搞定就行了，怎么方便怎么来，比如备用内容的实现：\n123456789101112import React from &#x27;react&#x27;;function Index() &#123;  // 默认情况下使用 Summit 作为按钮文字  return (    &lt;button classNames=&quot;btn-primary&quot;&gt;      &#123;props.children === null ? &#x27;Summit&#x27; : props.children&#125;    &lt;/button&gt;  );&#125;export default Index;\n样式 &amp; 属性\n这部分 Vue 的写法实在是太麻烦了。。。每次我都要查查文档具体怎么用，对象语法、数组语法、内联样式，要记住的有点多，Vue 动态修改样式的写法：\n1234567891011121314151617&lt;template&gt;  &lt;div    class=&quot;static&quot;    :class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;  &gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123;  data() &#123;    return &#123;      isActive: true,      hasError: false    &#125;  &#125;&#125;&lt;/script&gt;\nReact 写法：\n1234567891011121314import React, &#123; useState &#125; from &#x27;react&#x27;;function Index() &#123;  const [isActive, setIsActive] = useState(true);  const [hasError, setHasError] = useState(false);  return (    &lt;div      classNames=&#123;`static $&#123;isActive ? &#x27;active&#x27;:&#x27;&#125; $&#123;hasError? &#x27;text-danger&#x27;:&#x27;&#x27;&#125;`&#125;    &gt;&lt;/div&gt;  );&#125;export default Index;\nReact 里面直接采用 JS 的模板字符串语法，如果样式太多，可以使用 classnames 这个 npm 包，优雅传递各种状态，使用非常简单：\n123456classNames(&#x27;foo&#x27;, &#x27;bar&#x27;); // =&gt; &#x27;foo bar&#x27;classNames(&#x27;foo&#x27;, &#123; bar: true &#125;); // =&gt; &#x27;foo bar&#x27;classNames(&#123; &#x27;foo-bar&#x27;: true &#125;); // =&gt; &#x27;foo-bar&#x27;classNames(&#123; &#x27;foo-bar&#x27;: false &#125;); // =&gt; &#x27;&#x27;classNames(&#123; foo: true &#125;, &#123; bar: true &#125;); // =&gt; &#x27;foo bar&#x27;classNames(&#123; foo: true, bar: true &#125;); // =&gt; &#x27;foo bar&#x27;\n状态管理\nVue 的状态管理官方推荐使用 Vuex 也可采用 Redux。\n\n引用官方文档一段话：\n\n如果你是来自 React 的开发者，可能会对 Vuex 和 Redux 间的差异表示关注，Redux 是 React 生态环境中最流行的 Flux 实现。Redux 事实上无法感知视图层，所以它能够轻松的通过一些简单绑定和 Vue 一起使用。Vuex 区别在于它是一个专门为 Vue 应用所设计。这使得它能够更好地和 Vue 进行整合，同时提供简洁的 API 和更好的开发体验。\n\n这段话其实暴露了 Vuex 的一个缺陷，它和 Vue 强绑定，无法独立存在，这种一些项目升级和迁移时会有很大的麻烦。Redux 作为 React 的状态管理方案之一其实不依赖于 React。\nReact 周边的状态管理方案特别多，如 Redux、Mobx、Recoil 等，各有各的亮点，其中使用最多的应该是 Redux。\n\nRedux 周边生态也很丰富，可以更加下图选择不同的方案：\n\n\nredux-thunk\nredux-promise\nredux-saga\nredux-observable\n\n由于这部分代码较多，不详细写，不过如果你熟悉 Vuex 的概念，转到 Redux 应该不难。Vuex + axios 的做法和 Redux + redux-thunk 的写法类似，不过现在 redux-saga 的方案被更多复杂项目采用，其中很重要的原因是 saga 的概念编写异步代码非常优雅，且能够很好地解决竟态问题（如果采用 Vuex + axios 的写法会异常复杂、冗长），高度定制。\n如果你要迁移 Vue 到 React，建议采用的方案是 Redux + saga，saga 的概念不是那么容易懂，学习需要一些时间，但当你学会的时候就会明白这种写法比直接用 Promise 好太多了。\n生命周期\nVue 的生命周期这里不再重复，查询官方文档即可，React 生命周期如图：\n\n图片可以在这里找到。一般情况下 class 写法主要用到 componentDidMount 和 componentWillUnmount 钩子，React 的函数写法下可以用 useEffect 的执行函数和清理函数去模拟 mount 和 unmount 过程：\n1234567891011121314151617import React, &#123; useRef, useEffect &#125; from &#x27;react&#x27;;function Index() &#123;  const ref = useRef(null);    useEffect(() =&gt; &#123;    console.log(&#x27;mounted&#x27;);    return () =&gt; &#123;      console.log(&#x27;will unmount&#x27;);    &#125;;  &#125;, []);  return &lt;input ref=&#123;ref&#125;/&gt;&#125;export default Index;\nuseEffect 的原理这里不多说，可以看看相关文章：轻松学会 React 钩子：以 useEffect() 为例。其实从 React hook 中可以看到，React 在慢慢淡化生命周期的概念，减少自己对用户代码的侵入，将更多控制权交给用户。\n原生 DOM 操作\n这部分 Vue 和 React 都是采用 ref 写法，Vue：\n12345678910111213141516&lt;template&gt;  &lt;input ref=&quot;input&quot; /&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123;  methods: &#123;    focusInput() &#123;      this.$refs.input.focus()    &#125;  &#125;,  mounted() &#123;    this.focusInput()  &#125;&#125;&lt;/script&gt;\nReact 写法：\n12345678910111213import React, &#123; useRef, useEffect &#125; from &#x27;react&#x27;;function Index() &#123;  const ref = useRef(null);    useEffect(() =&gt; &#123;    ref.current?.focuse();  &#125;, []);  return &lt;input ref=&#123;ref&#125;/&gt;&#125;export default Index;\nuseEffect 是 React hook，在依赖数组为空的时候效果类似 componentDidMount 的生命周期函数（类似 Vue 的 mounted）。此外 useRef 不止用在这里，也可以挂载一些其他的东东，实现一些复杂操作，比如 previousValue 和对象属性等。\n路由\n大部分项目都是采用 react-router 这个路由方案，定制能力强、API 丰富。\n插件和工具\n浏览器安装 React Develop tools 和 Redux DevTools 两个插件即可。\n","plink":"https://becase.top/post/89193b3a1f93/"},{"title":"Git 从 0 到 1","date":"2022-02-14T02:13:54.000Z","date_formatted":{"ll":"Feb 14, 2022","L":"02/14/2022","MM-DD":"02-14"},"updated":"2024-03-11T03:21:43.669Z","content":"介绍\nGit (/ɡɪt/) 是一个分布式版本控制软件，于 2005 年以 GPL 协议发布，最初的目的是为了更好管理 Linux 内核开发而设计\n参考：Git - Wikipedia\n特点\n\n版本控制：Git 允许开发团队追踪和管理项目代码的版本。每次代码更改都会被记录，并且可以轻松地回滚到之前的版本\n分布式：Git是一种分布式版本控制系统，每个开发者都有完整的代码仓库副本，可以在没有网络连接的情况下工作，并在需要时将更改推送到共享的中央仓库\n分支管理：Git鼓励使用分支来组织工作流程。你可以创建、合并和删除分支，从而允许并行开发和独立的特性开发\n快速和高效：Git是一个快速和高效的版本控制系统。大多数操作都在本地执行，因此速度很快\n合作协作：多人协作开发时，Git使得代码的合并和冲突解决变得更容易\n开源和免费：Git是一个开源免费的版本控制系统，可以免费使用，并且有广泛的社区支持\n\n\n使用\nGit 工具最常用的命令包括：\n\ngit init：在项目目录中初始化一个新的Git仓库\ngit clone：从远程仓库克隆一个副本到本地\ngit add：将更改添加到暂存区\ngit commit：将暂存区的更改提交到本地仓库\ngit push：将本地仓库的更改推送到远程仓库\ngit pull：从远程仓库拉取并合并更改到本地仓库\ngit branch：管理分支，创建、查看和删除分支\ngit merge：合并分支\ngit status：查看仓库状态，显示已修改、已暂存等信息\ngit log：查看提交历史记录\n\n\n建议根据 场景 来学习使用，以下是几种常见场景\n\n新建项目上传 GitHub\n12345678910111213141516171819202122232425git init // 本地目录会出现 .git 文件夹，用以存储 git 环境操作// 查看本地用户,确认 git 环境存在git config user.namegit config user.email// 链接 GitHub 仓库源git remote add origin &quot;your repository url&quot;// 查看本地源git remote config -v对文件进行增删改// 将文件转入暂存区git add .// 转入版本库git commit -m &quot;commit msg&quot;// 推送版本到远程git push --set-upstream-to origin [branch-name] // 第一次推送需要明确推送的远程分支是哪个// 简写版本 git push -u origin master查看 GitHub 仓库改动情况\n在同一分支协作开发\n12345678910111213// 缓存本地更改，不加 msg 则直接置入栈顶git stash [--save [save-message]]git pull// 将栈顶缓存 pop 或者应用相应的 stashgit stash pop 或者 git stash apply [stash index]解决冲突git commit -m &quot;merge(xxx): xxx&quot;git push\n遇到问题需要回退分支\n回到某个版本\n12345// 定位回退版本，查看 commit-hashgit log --oneline// 回退选项有 soft、mixed、hard 几种，推荐 soft 保留更改git reset [commit-hash] --soft\n撤销某次提交则使用 git revert [commit-hash]\n扩展\nmsg 规范\n12345678910111213// 提交信息的格式通常采用如下形式：&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;body&gt;&lt;footer&gt;- `&lt;type&gt;`：表示提交的类型，比如&quot;feat&quot;（新功能）、&quot;fix&quot;（修复bug）、&quot;docs&quot;（文档更新）等。- `&lt;scope&gt;`：表示本次提交的影响范围，可以是模块名、文件名等。- `&lt;subject&gt;`：简要描述本次提交的主题。- `&lt;body&gt;`：详细描述本次提交的正文内容（可选）。- `&lt;footer&gt;`：脚注信息，包含一些附加信息（可选）\n\nfeat：新功能 feature\nbug：测试反馈 bug 列表中的 bug 号\nfix： 修复 bug\nui：更新UI；\ndocs： 文档注释变更\nstyle： 代码格式(不影响代码运行的变动)；\nrefactor： 重构、优化(既不增加新功能，也不是修复bug)；\nperf： 性能优化;\nrelease：发布；\ndeploy：部署；\ntest： 增加测试\nchore： 构建过程或辅助工具的变动\nrevert： 回退\nbuild： 打包\n\n其他操作\n12345678910111213141516171819202122232425// 设置全局 git 用户git config --global user.name &quot;username&quot;git config --global user.email &quot;email&quot;// 验证连接，常用于判断 ssh 连接是否被墙git -T git@github.com// git使用远程分支git checkout -b &lt;branch-name&gt; origin/&lt;branch-name&gt;// 用来丢弃工作区修改，回退到上一次commitgit checkout -- &lt;file&gt;git checkout .  // 注意有“.” 舍弃工作区当前全部改动// 将文件从缓存区取出，不设置file则默认全部取出git reset HEAD &lt;file&gt;// 不删除工作区的改动，撤销commit，将内容存放在暂存区（add 之后）git reset --soft HEAD^// 删除 untracked 的文件和目录git clean -fd// 删除已经在暂存区的文件git rm &lt;file&gt;\n\n多邮箱管理\n参考：如何给某一类项目统一设置用户名和邮箱\n修改 git 的全局配置文件，一般是用户主目录下的 .gitconfig 文件\n打开文件添加如下配置\n12[includeIf &quot;gitdir:/Users/lee/ent/code/&quot;]  path = .entconfig\n这段配置表示的是所有存放在 /Users/lee/ent/code/ 的仓库将会使用 .entconfig 这个文件里的配置\n那么就新建 .entconfig 文件来配置用户名邮箱，甚至其它的一些 git 配置都是可以的，示例如下\n123[user]  name = entname  email = name@ent.cn\n这样就完成了相应的配置，只需要将代码仓库放在指定目录下就可以了\n图形化工具\n插件：\n\nvscode —— GitLens 插件\nJetbrains 系产品 —— GitBox\n\n软件：\n\nSourceTree \n\n进阶\ngit rebase 和 git merge\n优缺点\n\ngit merge\n\n优点：不会破坏原分支的提交记录。\n缺点：会产生额外的提交记录，并进行两条分支线的合并。\n\n\ngit rebase\n\n优点：无需新增提交记录到目标分支，reabse后可以直接将对象分支的提交历史加到目标分支上，形成线性提交历史记录，更加直观。\n缺点：不能在一个共享分支上进行reabse操作，会带来分支安全问题\n\n\n\ngit merge\n\ngit rebase（git rebase --continue）\n\n正确使用\n\n合代码到公共分支的时候使用git merge，书写正确规范的merge commits留下记录。\n合代码到个人分支的时候使用git rebase，可以不污染分支的历史提交记录，形成简介的线性记录\n\nrebase后的push问题\n\n\npush命令假设你的本地分支和远端分支的唯一区别是你本地有几个新的commit，而远端没有\n\n但是由于进行了rebase操作，现在本地的feat-a分支多了一个之前从没见过的commit，这种情况下是不能进行fast-forwad模式的合并操作的，所以当执行 git push origin feat-a 命令时会报错误。\n要解决这个问题必须确保当前feat-a分支只有你自己在开发，没有其他成员的操作，如果符合这一条件，那么可以直接进行强制推送，执行命令： git push --force origin feat-a\ngit switch和git restore\n不同于gitcheckout切换commit直接提供commithash，使用switch切换commit时需要加-d标志\ngit switch -d f8c540805b7e16753c65619ca3d7514178353f39\n同时切换并新增一个本地分支时需要加-c标志\ngit checkout -b new_branch\ngit switch -c new_branch\n可以将文件的状态恢复到指定的git版本(默认为当前分支)\ngit restore --test.txt\ngit revert和git reset\ngit revert 是撤销某次操作，此次操作之前或之后的commit都会被保留\ngit reset 是撤销某次提交，此次之后的修改都会被退回到暂存区\n\nreset是彻底回退到指定的commit版本，该commit后的所有commit都将被清除，包括提交历史记录；\nrevert仅仅是撤销指定commit的修改，并不影响后续的commit，但所撤销的commit被后续的commit修改了同一地方则会产生冲突；\nreset执行后不会产生记录，revert执行后会产生记录；\nreset执行后无法再次恢复，revert执行后因为不会清除记录，并且会产生新纪录，所以文件不会丢失，你可以多次执行revert恢复到某次改变之前的状态；\nreset执行后HEAD会后移，而revert的HEAD则一直是向前的；\n\n详情参考：一文彻底搞清git reset和revert区别 - 掘金\nreset --hard和reset --soft\n一般我们在使用 reset 命令时，git reset --hard 会被提及的比较多，它能让 commit 记录强制回溯到某一个节点。而 git reset --soft 的作用正如其名，--soft (柔软的) 除了回溯节点外，还会保留节点的修改内容。\ngit tag\n打标签的作用，就是给项目的开发节点，加上语义化的名字，也即功能版本的别名。 打上标签名的同时，写上附带信息，可以方便项目日后维护过程中的回溯和复查\n另外，也可以通过标签记录，大致了解当前项目的向下兼容性、API的修改和迭代情况\n打标签\n12345678// 命令格式git tag -a 标签名 -m &quot;附注信息&quot;// 示例git tag -a v0.1.0 -m &quot;完成了文章a和文章b的撰写，耗费时间2h，感觉棒棒的！&quot;// 为某个commit后的版本打taggit tag -a &lt;标签名&gt; &lt;commitId&gt; -m &#x27;标签内容文字描述&#x27; \n版本基本控制规范\n版本号基本的规范是Major.Minor.Patch，也就是Major 是主版本号、Minor是次版本号、而 Patch 为修订号。每个元素必须以数值来递增。\n例如：1.9.1 -&gt; 1.10.0 -&gt; 1.11.0。只有三个号\n详情查看：语义化版本 2.0.0 | Semantic Versioning\ngit wotktree\n12345678910111213141516# 添加工作树（工作区）git worktree add [&lt;options&gt;] &lt;path&gt; [&lt;commit-ish&gt;]# 查看工作树列表git worktree list [&lt;options&gt;]# 锁定工作区（防止移动或删除）git worktree lock [&lt;options&gt;] &lt;path&gt;# 移动工作区git worktree move &lt;worktree&gt; &lt;new-path&gt;# 清空被删除的工作区信息git worktree prune [&lt;options&gt;]# 删除工作区git worktree remove [&lt;options&gt;] &lt;worktree&gt;# 修复工作区（例：当主工作区移动，副工作区无法连接等情况）git worktree repair [&lt;path&gt;...]# 解锁工作区（对应lock锁定工作区）git worktree unlock &lt;path&gt;\ngit flow\n版本规范其实有许多种工作流形式，有 Git flow，有集中式工作流，有功能分支工作流；\n\nGit Flow是构建在Git之上的一个组织软件开发活动的模型，是在Git之上构建的一项软件开发最佳实践\n\n\n主分支：master、develop\n辅助分支：feature、release、hotfix\n.gitignore不生效\n.gitignore 只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。\n \n 那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交\n12345git rm -r --cached .git add .git commit -m &#x27;update .gitignore&#x27;\n修改已经提交的commit msg\n参考：git 修改 Commit Message - 拾月凄辰 - 博客园\n1234567git log --onelinegit rebase -i [父级commit-id]选择r模式进行替换，然后进入对应窗口修改msg:wq保存退出\n参考\n\nGit - Wikipedia\nA successful Git branching model » nvie.com\n如何利用 Git 中的 tag 管理项目版本号 \nGit、GitHub、GitLab Flow，傻傻分不清？一图看懂各种分支管理模型\n\n","plink":"https://becase.top/post/917bdb2b8ea1/"},{"title":"Redis 快速上手","date":"2021-11-02T16:00:00.000Z","date_formatted":{"ll":"Nov 3, 2021","L":"11/03/2021","MM-DD":"11-03"},"updated":"2024-03-11T03:21:43.675Z","content":"概念\n\nREmote Dictionary Server，key-value 存储系统，是跨平台的非关系型数据库\n\nRedis 是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-value 数据库，并提供多种语言的 API\n特点\n\n支持数据的持久化\n除了简单的 key-value 类型的数据，同时还提供以下数据结构的存储\n\nlist\nset\nzset\nhash\n\n\n支持数据的备份，即 master-slave 模式的数据备份\n\nzset 数据结构\n有序数据集合：保存一个集合，并为集合中的每个元素分配一个分数（score），相比于普通集合，有序集合中的元素可以根据分数进行排序。\n\n类似于 Set 和 Hash 的复合数据结构\n\n底层使用跳跃表（Skip List）来实现\n—— 跳表 = 多层链表 + 二分查找\n使用场景：\n\n排行榜：得分作为排序的 key\n计数器：数目作为 key\n\n应用场景\n\n缓存：Redis 缓存能够提高应用的响应速度，减轻数据库的压力。\n计数器：Redis 可以用来做计数器，比如网站的 UV，PV 等。\n排行榜：Redis 可以用来做排行榜，比如微博的热门微博排行榜，微信的热门文章排行榜等。\n社交网络：Redis 可以用来做社交网络的好友关系，比如微博的关注，粉丝等。\n消息队列：Redis 可以用来做消息队列，比如秒杀系统中的下单队列，支付队列等。\n分布式锁：Redis 可以用来做分布式锁，比如秒杀系统中的分布式锁。\n分布式 Session：Redis 可以用来做分布式 Session，比如网站的购物车，购物记录等。\n其他：还有很多应用场景，比如：分布式 ID 生成器，分布式任务调度等。\nRedis 的应用场景还在不断的扩展中，比如：Redis 可以用来做分布式任务调度，比如 Celery，Resque 等。\n\n关于社交网络\nRedis 可以通过使用 Sorted Set 数据结构来存储用户之间的好友关系。每个用户都被视为一个元素，而他们之间的关系则通过分数字段进行表示。\n例如，如果用户 A 关注了用户 B，那么可以将 A 的 ID 作为 Sorted Set 中的一个元素，将 B 的 ID 作为另一个元素，然后将 B 的 ID 分配给 A 的元素作为分数字段，这样就可以表示出 A 关注了 B 这个关系。\n同时，还可以使用 Sorted Set 的交集运算和并集运算等功能来实现好友推荐、查找共同好友等高级功能。\n关于消息队列\nRedis 在消息队列（Message Queue）中的应用主要是通过实现 Redis List 来实现的。Redis List 可以看做是一个支持双向插入和删除操作的链表，它可以存储多个字符串元素，并且可以快速地从两端插入或者弹出元素。\n利用 Redis List 的这些特性，我们可以将其作为消息队列的底层数据结构。具体地，当生产者需要发送消息时，它可以将消息写入到 Redis List 的尾部；而消费者则可以从 Redis List 的头部获取消息并进行处理。由于 Redis 的高效读写以及原子操作的支持，可以保证消息队列的高吞吐量和低延迟。\n除了基本的消息传送功能，Redis 还支持一些其他的高级特性，例如：\n\nPub/Sub：Redis 支持发布/订阅模式，它可以让多个客户端同时监听同一个消息频道，并且实时地接收到新发布的消息。\n消息持久化：Redis 提供了多种消息持久化方式，包括 RDB 快照、AOF 日志等，可以确保消息在重启或者故障恢复后不会丢失。\n阻塞式操作：Redis 提供了阻塞式操作，例如 BRPOP 和 BLPOP 命令，可以让消费者在没有消息可处理时自动等待并阻塞，避免了轮询和忙等待的开销。\n\n优缺点\n\n优点：\n\n性能极高 – Redis 能读的速度是 110000 次/s,写的速度是 81000 次/s 。\n丰富的数据类型 – Redis 支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。\n原子 – Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作全并后的原子性执行。\n丰富的特性 – Redis 还支持 publish/subscribe, 通知, key 过期等等特性。\n\n\n缺点：\n\n单线程 – Redis 的所有操作都是单线程的，这样会导致在高并发的情况下，Redis 会成为性能的瓶颈。\n不支持复杂的查询 – Redis 虽然提供了丰富的数据类型，但是还是不支持复杂的查询。\n数据不是真正的删除，而是被清除 – Redis 删除某个 key 后，会立即释放内存，但是对于大 key 来说，内存释放会比较慢。\n\n\n\n扩展\nRedis 的持久化\n\nRDB：Redis 默认的持久化方式，会在指定的时间间隔内将内存中的数据集快照写入磁盘。\nAOF：Redis 的另一种持久化方式，会将每个收到的写命令追加到文件中，Redis 重启时会重新执行这些命令来恢复数据。\n混合持久化：RDB 和 AOF 两种持久化方式的结合。\n\nRedis 内部的数据结构\n\nRedis 的数据结构主要有三种：简单动态字符串（SDS）、双端链表（deque）、字典（dict）。\nSDS：简单动态字符串，是 Redis 的基本数据结构，是 Redis 的字符串实现。\ndeque：双端链表，是 Redis 的基本数据结构，是 Redis 的列表实现。\ndict：字典，是 Redis 的基本数据结构，是 Redis 的哈希实现\n\nRedis 的主从复制\n主从复制是 Redis 的高可用方案，主从复制的原理是：主节点会将数据同步到从节点，从节点可以是只读的，也可以是可读可写的。\n\n主从复制的优点：\n\n读写分离：主节点负责处理写请求，从节点负责处理读请求，从而实现读写分离。\n高可用：主节点宕机后，从节点会自动提升为主节点，从而实现高可用。\n数据冗余：主从复制可以实现数据冗余，从而实现数据的安全。\n\n\n主从复制的缺点：\n\n主从复制的延迟：主从复制的延迟是主节点写入数据后，从节点才能读到数据的时间差。\n主从复制的数据不一致：主从复制的数据不一致是指主节点和从节点的数据不一致。\n主从复制的故障转移：主从复制的故障转移是指主节点宕机后，从节点提升为主节点的过程\n\n\n\n哨兵模式\n哨兵模式是 Redis 的高可用方案，哨兵模式的原理是：哨兵会监控主节点和从节点的运行状态，当主节点宕机后，哨兵会自动将从节点提升为主节点，从而实现高可用\n","plink":"https://becase.top/post/eabb6094f334/"},{"title":"devops/strapi实践","date":"2021-04-23T03:53:04.000Z","date_formatted":{"ll":"Apr 23, 2021","L":"04/23/2021","MM-DD":"04-23"},"updated":"2024-03-11T03:21:43.675Z","content":"背景\n因为需要一个上传图片的接口，自己又不想为了一个接口专门去开一个后端项目来写，之前有接触过strapi，一直没去深入了解，趁这个机会就学学 strapi\n\nstrapi 是什么？\n一句话总结：一个可以简单、快速、自动生成安全可靠后端 api 的框架，前端开发一大利器\n\n概述\n官网：strapi ，这个名字取自 bootstrap 的后缀 strap，然后因为它是一个提供快速生成安全可靠的 api 架构，然后再加了一个 i，合并就是 strapi，bootstrap 的有启动的意\n使用\n可以先跟着这篇博客简单做个 demo\n——新手入坑：strapi官网教程的简单示例学习\n具体api\n数据库配置\nstrapi在默认下是安装了sqlite数据库，并且默认把数据放在.tmp/data.db中，并且被gitignore了\n官方配置文档：Strapi Developer Docs\n数据库的配置在config/database.js中，这里贴出mysql的配置文件\n——需要在数据库中先创建数据库\n——需要 mysql 的npm包，npm i mysql --save\n12345678910111213141516171819module.exports = (&#123; env &#125;) =&gt; (&#123;  defaultConnection: &#x27;default&#x27;,  connections: &#123;    default: &#123;      connector: &#x27;bookshelf&#x27;,      settings: &#123;        client: &#x27;mysql&#x27;,        host: &#x27;数据库ip地址&#x27;,        port:  3306,        database: &#x27;test&#x27;,        username: &#x27;用户名&#x27;,        password: &#x27;密码&#x27;,      &#125;,      options: &#123;        useNullAsDefault: true,      &#125;,    &#125;,  &#125;,&#125;);\n重启服务后就会发现数据库中多了几张表\n\n同时原先的数据也会消失，因为数据的引用关系已经从 sqlite的db文件转为本地数据库\n\nhttp请求说明\n\n关于通过ajax post/put relation数据的，根据设置一对多/一对一，字段的类型为number[]/number，填入对应数据的id即可\n路由配置\n\n\nmethod 就是请求的方法\npath 请求的路径\nhandler 请求用到的方法，在这里为relation.find，表示会用到在relation文件夹下的controllers/&#123;表名&#125;.js中的find函数。但默认下find函数已经在系统中存在了，所以controllers/&#123;表名&#125;.js中没有find函数\n\n上传图片\n兜兜转转找了很久才发现，并不能直接通过 strapi 的一般方式上传图片，这里的一般方式指的是 （创建实体表——开放权限——发布——接口请求）\n原因——strapi 不支持设置请求头（Content-type）为 multipart/form-data 后发起 POST 请求上传图片\n\n可以看看这个 Issues ：POST multipart/form-data on generated API for file upload · Issue #1316 · strapi/strapi · GitHub\n解决办法：直接使用 strapi 的插件 upload模块\nupload模块位置\n\n\n配置请求头和body参数\n\n\n成功获取到返回数据\n\n项目会在 public/uploads 目录下转存图片，其实你通过 http://[ip]:[port]/upload  访问的图片就是这里的图片，项目本身只是提供了一层映射关系\n参考\nPOST multipart/form-data on generated API for file upload · Issue #1316 · strapi/strapi · GitHub\nstrapi入门\nStrapi Developer Docs\nstrapi的使用\n","thumbnail":"https://cdn.jsdelivr.net/gh/jiechen257/gallery@main/img/202304272135444.png","plink":"https://becase.top/post/186089d667ee/"},{"title":"Java中的集合","date":"2021-04-17T12:55:40.000Z","date_formatted":{"ll":"Apr 17, 2021","L":"04/17/2021","MM-DD":"04-17"},"updated":"2024-03-11T03:21:43.670Z","content":"记述一下 Java 中的部分相关接口与具体实现类：\n\n具体容器分类\n\n\n非同步集合：在并发访问的时候，是非线程安全的；但是由于它们没有同步策略(加锁机制)，它们的效率更高\n同步集合：对每个方法都进行同步加锁，保证线程安全\n\n\n非同步集合：ArrayList、HashSet、HashMap、LinkedList、TreeSet、TreeMap、PriorityQueue\n同步集合：HashTable、Vector、Stack\n同步包装器 : [ Collections.synchronizedMap(), Collections.synchronizedList() ]\nJava 集合类中非线程安全的集合可以用同步包装器使集合变成线程安全，其实实现原理就是相当于对每个方法加多一层同步锁而已，比如：\n\nHashMap --&gt; Collections.synchronizedMap(new HashMap())\nArrayList --&gt; Collections.synchronizedList(new ArrayList&lt;&gt;())\n\n并发集合：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、CopyOnWriteArrayList、CopyOnWriteArraySet、ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、LinkedBlockingDeque、ConcurrentLinkedQueue\n同步集合类和并发集合类的区别\n不管是同步集合还是并发集合他们都支持线程安全，他们之间主要的区别体现在性能和可扩展性，还有他们如何实现的线程安全。\n同步集合类，Hashtable 和 Vector 还有同步集合包装类，Collections.synchronizedMap()和 Collections.synchronizedList()，相比并发的实现(比如：ConcurrentHashMap, CopyOnWriteArrayList, CopyOnWriteHashSet)会慢得多。\n造成如此慢的主要原因是锁， 同步集合会把整个 Map 或 List 锁起来，每个操作都是串行的操作，同一时刻只有一个线程能操作。而并发集合不会，并发集合实现线程安全是通过使用先进的和成熟的技术把锁剥离。\n比如 ConcurrentHashMap 会把整个 Map 划分成几个片段，只对相关的几个片段上锁，同时允许多线程访问其他未上锁的片段。\nCopyOnWriteArrayList 允许多个线程以非同步的方式读，当有线程写的时候它会将整个 List 复制一个副本给它。如果在读多写少这种对并发集合有利的条件下使用并发集合，这会比使用同步集合更具有可伸缩性\nQueue 接口\nQueue 接口包括 Collection 接口的所有方法。 这是因为 Collection 是 Queue 的超级接口。\nQueue 接口的一些常用方法是：\n\nadd() - 将指定的元素插入队列。如果任务成功，则 add()返回 true，否则将引发异常。\noffer() - 将指定的元素插入队列。如果任务成功，则 offer()返回 true，否则返回 false。\nelement() - 返回队列的开头。如果队列为空，则引发异常。\npeek() - 返回队列的开头。 如果队列为空，则返回 null。\nremove() - 返回并删除队列的头部。如果队列为空，则引发异常。\npoll() - 返回并删除队列的开头。 如果队列为空，则返回 null。\n\nDeque 接口\n在常规队列中，元素是从后面添加的，而从前面删除的。但是，在双端队列中，我们可以从前后插入和删除元素\n\n除了 Queue 接口中可用的方法之外，Deque 界面还包括以下方法：\n\naddFirst() - 在双端队列的开头添加指定的元素。如果双端队列已满，则引发异常。\naddLast() - 在双端队列的末尾添加指定的元素。如果双端队列已满，则引发异常。\nofferFirst() - 在双端队列的开头添加指定的元素。如果双端队列已满，则返回 false。\nofferLast() - 在双端队列的末尾添加指定的元素。如果双端队列已满，则返回 false。\n等等\n\nLinkedList 类\nJava 中的链表具体实现类，对比 ArrayList 的增加和删除的效率更高，而查找和修改的的效率较低\nArrayDeque 类\n实现了 Queue 接口 和 Deque 接口\n\nStack 类\nStack&lt;T&gt; stack = new Stack&lt;&gt;();\n\n\nboolean empty()\n测试堆栈是否为空。\n\n\nObject peek( )\n查看堆栈顶部的对象，但不从堆栈中移除它。\n\n\nObject pop( )\n移除堆栈顶部的对象，并作为此函数的值返回该对象。\n\n\nObject push(Object element)\n把项压入堆栈顶部。\n\n\nint search(Object element)\n返回对象在堆栈中的位置，以 1 为基数。\n\n\n\nJava 集合框架中没有 Stack 接口，仅有 java 早期遗留的一个 Stack 类\n\n因为集成子 Vector，所以 Stack 类是同步的，效率不高，推荐用 ArrayDeque 代替\n\n\n","plink":"https://becase.top/post/10b6ef040f64/"},{"title":"Hello World","date":"2021-03-16T10:15:27.000Z","date_formatted":{"ll":"Mar 16, 2021","L":"03/16/2021","MM-DD":"03-16"},"updated":"2024-03-11T03:21:43.674Z","content":"🌱 Keep learning, hoping to learn unlimited possibilities in a limited time\n","thumbnail":"https://cdn.jsdelivr.net/gh/jiechen257/gallery@main/img/202304281414202.jpeg","plink":"https://becase.top/post/e23e83943c2e/"},{"title":"我最近","date":"2024-03-23T15:37:55.449Z","date_formatted":{"ll":"Mar 23, 2024","L":"03/23/2024","MM-DD":"03-23"},"updated":"2024-03-23T15:37:55.449Z","content":"\n你会继承某一个人的时间，在这条无边无垠的长河里继续流淌下去\n\n\n\n\n\n\n买的那对世界树碎了，连着碎了两次\n\n我用胶水粘了两次（世界破破烂烂，缝缝补补接着过\n\n\n梅开二度，我真是 SB\n连着加了三周周六的班（三周周末跟没有一样\n打游戏也一直输，世界究竟怎么了\n一个人去玩了剧本杀\n\n被 DM 的叨叨叨（信神明、吐槽暗网）劝退\n这回不是带道具回家，而是差点把衣服落在场馆\n\n\n报名了上半年的软考\n准备研发新人的开场 show\n\n\n  更新于 2024.3.23 日\n\n过去式\n\n2024-03-05\n2024-02-26\n2024-01-25\n2024-01-09\n2024-01-04\n2023-12-17\n\n","plink":"https://becase.top/now/"},{"title":"关于我","date":"2024-03-12T02:23:01.847Z","date_formatted":{"ll":"Mar 12, 2024","L":"03/12/2024","MM-DD":"03-12"},"updated":"2024-03-12T02:23:01.847Z","content":"\n生命好在无意义，才容得下各自赋予意义。假如生命是有意义的，这个意义却不符合我的志趣，那才尴尬狼狈\n\nEnglish | 英文版本\n一句话\n00 后 ENFJ 人格，天蝎男(不造谣，不信谣，不传谣)，来自长沙\n多讲几句\n首先是一名铲屎官，供养两只猫崽，一只美短，一直蓝白英短\n其次是 Front-End Engineer（天天被 cue &quot;前端已死&quot;😅），目标是 Independent Developer，业余时间主要逛 推特 和 bilibili\nACGM 通吃，MOBA、桌游通玩 🤖，爱好音乐，有玩 🎸，只要有约，立马背上行囊\n厌恶饭圈，杜绝女拳，自由至上，理解万岁！\n一些收录\n点这里\n一些标签\n（👇 记得点开左边的小箭头哦…）\n\n  ACGM玩家\n   🎶 民谣 & 浪漫摇滚\n   📖 江南(杨志爬)、韩寒、还有意林\n   📺 宫崎骏、新海诚、若森数字\n   🎮 top-king，shy sensi\n   🎥 豆瓣 top 250、美剧(老友记)\n\n\n  各种玩\n   🪀 密室、蹦极、德州、狼人杀、剧本杀~\n   😋 约饭、旅游（希望人没事） \n\n\n  技术向\n   ⌨️ vimer + 双拼，效率至上\n   👻 面对技术栈的选择，一向是都试试\n   👨‍💻 终身学习\n\n\n  欲养老而不为\n   😪 想要早睡，可是不困  \n   🌧️ 想要跑步，可是下雨 \n   🌶️ 不能吃辣，被迫达成 \n\n\n  battle\n   🌝 可以理论，但不要恼火\n   🙊 派系分明，理解万岁\n\n\n  小目标\n   🌅 一趟西藏，一趟北欧 \n   🎹 电子钢琴  \n\n","plink":"https://becase.top/about/"},{"title":"工作流 | 实用工具","date":"2024-03-25T05:51:50.416Z","date_formatted":{"ll":"Mar 25, 2024","L":"03/25/2024","MM-DD":"03-25"},"updated":"2024-03-25T05:51:50.416Z","content":"网站\n\n图片制作\nIT book\n壁纸\n\n环境\n\nArc Browser\nNavicat + Apifox\nFinalShell\nWarp + iTerm2 + ranger\nCharles + Reqable\n\n文档\n\nObsidian + PicGO + Github\nTypora + Sublime text\n\n输入\n\nVim\n小鹤双拼\n\n插件\n\nRaycast\nTraffic monitor + iStatus menu\nSnipaste + paste\nclash + clashX\nflux\nLoop(MacOS)\n\n软件\n\nPotplayer\nIINA\n\n","plink":"https://becase.top/tools/"},{"title":"技术之外","date":"2022-03-17T13:53:04.000Z","date_formatted":{"ll":"Mar 17, 2022","L":"03/17/2022","MM-DD":"03-17"},"updated":"2024-03-27T03:35:01.470Z","content":"\n我没有看到个性和自我的过剩，我看到了表达的过剩\n\n📜 杂文（我讲给你听\n一些思考和理解\n\n2024-03-10 认识你自己\n2023-03-17 学校-学生-学习\n2022-06-02 卖弱现象\n2021-10-12 消失的附近\n\n📃 随笔（我说\n类似备忘录\n\n2024-03-17 所谓命运\n2024-01-06 矛盾的自己\n2023-08-25 打工人的自我修养\n2023-06-15 小男孩\n2022-12-15 小阳人的自我修养\n\n📄 摘录（他们说\n收集自己在各种论坛上看到有价值的长文或者帖子\n\n2024-03-02 我们失去长文阅读能力了吗\n2024-02-06 独行的栈道\n2024-01-10 他的 2023\n2023-12-11 计算 · 序\n2023-09-05 为什么卸载抖音\n2023-07-29 关于学习那些事\n2023-05-27 如何听到时间的声音\n2023-02-22 为什么是绘梨衣\n2023-02-13 平台的垃圾化\n2022-06-12 刻奇国里说刻奇\n2022-03-27 大唐三百年\n2021-07-07 语文高考作文可以写负能量吗\n2021-05-05 给青年添个堵\n2021-12-22 情书\n2021-03-22 生于焦虑，死于自律\n\n🏷️ 清单（我在看\n记录下过程，希望自己能一直阅读下去\n\n\n分类\n清单\ntodo\ning\n\n\n\n\n书籍\n书籍清单\n-\n零下一度\n\n\n影视\n影视清单\n重庆森林\n-\n\n\n⏳ 工具（我在用\n点这里\n","plink":"https://becase.top/resources/"},{"title":"About Me","date":"2024-03-12T02:26:47.645Z","date_formatted":{"ll":"Mar 12, 2024","L":"03/12/2024","MM-DD":"03-12"},"updated":"2024-03-12T02:26:47.645Z","content":"\nLife is fortunate in its meaninglessness, for it allows room for us to each assign our own meanings. If life were to have a predefined meaning that didn’t align with our interests, that would indeed be awkward and uncomfortable.\n\nChinese | 中文版本\nOne-liner\nPost-2000s ENFJ personality, Scorpio male (Don’t spread rumors, don’t believe rumors, don’t pass on rumors), hailing from Changsha.\nSay a few more words\nFirst and foremost, a cat’s servant, raising two kittens, one American Shorthair, and one Blue Bicolor British Shorthair.\nNext up, a Front-End Engineer (constantly reminded that “frontend is dead” 😅), aiming to be an Independent Developer. In my spare time, you can find me browsing Twitter and bilibili.\nACGM enthusiast, master of MOBA, board games aficionado 🤖. I love music, play the guitar 🎸, and always ready to pack my bags for a trip.\nDetest fan circles, avoid female fighting, freedom above all, long live understanding!\nSome Collections\nClick here\nSome Tags\n(👇 Remember to click on the little arrow on the left…)\n\n  ACGM Player\n   🎶 Folk & Romantic Rock\n   📖 Jiangnan (Yang Zhipa), Han Han, and Yilin\n   📺 Miyazaki Hayao, Shinkai Makoto, Ruoshen Digital\n   🎮 Top-king, shy sensi\n   🎥 Douban top 250, American TV series (Friends)\n\n\n  Various Hobbies\n   🪀 Escape room, bungee jumping, Texas hold'em, Werewolf Kill, script killing~\n   😋 Dinner dates, travel (hopefully people are okay)\n\n\n  Technical\n   ⌨️ Vimer + Double Pinyin, efficiency first\n   👻 Always try different technology stacks\n   👨‍💻 Lifelong learner\n\n\n  Aspiring to Age Gracefully\n   😪 Want to sleep early but not tired\n   🌧️ Want to run, but it's raining\n   🌶️ Can't eat spicy, reluctantly agreed\n\n\n  Battle\n   🌝 Can argue in theory, but don't get angry\n   🙊 Clear factions, long live understanding\n\n\n  Small Goals\n   🌅 A trip to Tibet, a trip to Northern Europe\n   🎹 Electronic piano\n\n","plink":"https://becase.top/about/about_en/"},{"title":"","date":"2024-03-11T03:17:20.589Z","date_formatted":{"ll":"Mar 11, 2024","L":"03/11/2024","MM-DD":"03-11"},"updated":"2024-03-11T03:17:20.589Z","content":"长沙旅游攻略\n\n先大概看下方案，文末带有地图截图，最后是需要讨论 or 确定的点\n\n出行\n\n出发：周五晚上 18.42 - 23. 【车次 G1365】\n回来：周日晚上 18.31 - 23. 【车次 G1308】\n\n住\n先选地段，再定附近的酒店或者民宿\n\n五一广场附近\n\n优点：紧挨五一广场，晚上酒吧玩累了可以直接回\n缺点：附近全是商业街，会很吵\n\n\n迎宾路口附近\n\n优点：靠近五一广场，但有距离，晚上休息不会吵闹\n缺点：暂无\n\n\n万家丽附近\n\n优点：地铁离高铁站相对近一点，附近有很大的夜市 - 杨帆\n缺点：在酒吧那个晚上回家不方便\n\n\n\n打卡点\n\n\n时间\n周五晚上\n周六\n周日\n\n\n\n\n路线\n万家丽\n橘子洲 &gt; 岳麓山 &gt; 五一广场 &gt; Hib-Hub\n开福寺 or 松雅湖 or 李自健美术馆\n\n\n途中可选\n暂无\n省美术馆(岳麓山脚下)\n省博物馆、湖南广电\n\n\n小吃\n金栗门板栗、杨帆夜市\n(主要在五一广场)天马牛肉饼、文和友臭豆腐\n暂无\n\n\n吃饭\n(估计晚上十二点到，吃夜宵？)\n费大厨 or 笨萝卜 &gt; 南门小吃街\n(吾悦广场)美怡香港菜\n\n\n注意：\n\n长沙地铁周末的停运时间在 11:00 - 11:30 中间（大致范围\n杨帆夜市营业时间在 18:00 - 24:00\n需要预约的地方\n\n橘子洲、岳麓山、开福寺和李自健美术馆需要线上预约\n\n\n周三的打卡地点有两种方向，近的在开福寺，另外两个(松雅湖和美术馆)很远，将近两小时地铁\n\n可以转完开福寺后再回五一广场\n\n\n\n解放西 - Hib Hub 公社\n晚上六点开始营业，有小吃\n概览\n\nTODO\n\n住的选择\n高铁票还没开售，待买\n有什么其他想去的地方或者想吃的美食，再补充\n\n","plink":"https://becase.top/strategy/travel/ChangSha/"},{"title":"为什么是绘梨衣","date":"2023-02-21T16:00:00.000Z","date_formatted":{"ll":"Feb 22, 2023","L":"02/22/2023","MM-DD":"02-22"},"updated":"2024-03-11T03:17:20.561Z","content":"\n多少中二少年挥之不去的小女孩\n\n你去山沟沟里旅游，遇到一个妹子，她特喜欢你，啥都想着分你一份\n你心不在焉，心里有着另一个人，你认为这只是你人生中的过客\n你知道，你终究会离开，这段故事也是你人生中的插曲而已\n她是个傻子，也许是先天的，也许是后天的，这不重要，重要的是，她是被卖到这里的\n买家知道她傻，也放心，让她自由活动，而这时候，刚好遇到了你\n此时，她还有三天，就要和买家的傻儿子结婚\n这一切，你都知道，而且，你刚好有一个警察局的朋友，有能力把她带走，不用害怕什么，就是他们来的晚，你要把她带走或者藏起来，会被狠狠打一顿\n你们度过了一段很美好的时光，起码，在那个傻子看来，是这样的\n因为她傻，她一直被关在屋里，这次偶然走出去，就被人贩子卖到了这里\n她什么都不知道，她只知道，你对她很好，你是她唯一的 “朋友”，当然，对于常年关在家里的她，就连这个词都很陌生。\n这段时光并不漫长，但，足够美好\n不过，你终究还是走了，天气预报说，山里将有一场大雨，气温骤降，你没有带厚衣服，而且，刚好你的朋友要过生日\n你没有带走她，你也要生活，带走她，无论如何是个麻烦，你知道这样不对，可是你的生活也不容易，你不想在折腾了\n火车将外面的一切远远的甩在身后，你望着窗外，陷入了回想，\n你想到了她，打开了手机，搜索一些，买家善待人贩子购买来的媳妇的故事，努力给自己一点安慰\n手机没电了，还好这所火车上有插口，你打开背包，准备拿充电器出来，就在这时，你看到了一抹淡红\n你迟疑了一下，拿起了它\n你知道，这是那个傻子最珍贵的东西，是她父母在庙里给她祈福得来的，她一戴就是十多年，颜色都淡了，还舍不得丢掉\n你突然慌了，这条红绳就像一盆冷水，将你的所有幻想都击碎，让你瞬间就清醒了起来，\n你给你在警察局的好友打了电话，让他赶紧带着人来，而你在下个站点就下了车，买了最快的车票，踏上了返程\n你觉得，一切都来得及，下雨天，虽然是婚期，也不好结婚的，你知道哪里的人都迷信，干什么都要图个吉利\n你开始想，怎么帮她找父母，以后每年要去看她几次， 你甚至在想，她被侵犯以后，你应该怎么帮她走出阴影\n你终于到了，同时到的，还有两辆警车，与你的朋友\n地上撒着些许的红纸，还有鞭炮的碎屑，你心里一沉，你知道，最坏的结果出现了，不过出人意料的是，她并不在买家的房子里\n你去问了邻居，你知道了一切，你找到了她\n她就躺在哪里，头发散乱，双目无神，从发间流出的血液已经凝固，可并没有让她显的狰狞，反而给她常年见不到阳光而发白的脸蛋增添了几分血色\n她的衣服皱巴巴的，你知道，她不喜欢这样，她最喜欢整齐了，每次皱了一点，她都要小心翼翼的抚平\n不过，她终究不能再次抚平衣服上的褶皱了，她的脖子上有个洞，从里面流出的东西染红了她的衣服\n听说，是她被那个傻子吓到了，挣扎的太厉害，那个傻子一急，就用剪刀给了她几下\n你还听说，她挣扎的时候，喊的是你的名字\n你愣住了\n剪刀已经被收回去了，因为是他们的财产，他们都叫她是赔钱货，不仅一个孩子都没生下，还给屋子里添了几分血色\n“多不吉利”，你听到他们对这个女孩做出了最后的评价\n此刻，愤怒充斥着你的心，投毒，纵火，你有无数种点子，让他们死于非命，不过，下一刻，你鼻子一酸\n你知道，你的女孩永远回不来了，她没法抚平自己的衣裳，没法再叫一次你的名字，也没法傻乎乎的看着看发笑了\n她的手腕有一道伤口，是将她拖来的时候，刺藤伤的\n就像一条红绳一般\n\n\n转载自：龙族-绘梨衣\n\n","plink":"https://becase.top/resources/extract/为什么是绘梨衣/"},{"title":"为什么卸载抖音","date":"2024-03-11T03:17:20.560Z","date_formatted":{"ll":"Mar 11, 2024","L":"03/11/2024","MM-DD":"03-11"},"updated":"2024-03-11T03:17:20.560Z","content":"\n我不玩抖音这类短视频，一是觉得浮夸且降智，二是不想时间被碎片化\n\n你为什么卸载今日头条和抖音？\n在大城市里\n搞废一个人的方式特别简单\n给你一个安静狭小的空间\n给你一根网线\n最好再加一个外卖电话\n好了，你开始废了\n绝不危言耸听\n一个人待在不用思考的舒适区里\n累了，点一顿外卖\n困了，来一盘游戏\n闷了，刷一波抖音\n不但不寂寞，反而更有安全感。\n过了一段时间以后\n感官逐渐变得钝化\n眼界也日益局限\n再也不愿抬头去看向手机外的世界\n不想回到令人畏缩的现实\n这就是重复感给你的毒药\n重复让人麻醉\n只有变化叫人惊醒。\n如果你找不到这个变化的出口\n你可能一辈子\n都会在一边刷抖音一边埋怨没时间\n一边熬着夜一边害怕着猝死的世界里\n彷徨、徘徊、痛不欲生。\n抖音、快手这种算法推荐的声色娱乐 App\n最大的特点是无声无息地消耗你的心智\n难怪，《娱乐至死》中有一句经典的谶语：\n“毁掉我们的不是我们所憎恨的东西、\n而恰恰是我们所热爱的东西。”\n推荐算法是最剧毒的麻醉剂\n现在这个时代\n已经彻底沦为“有机时代”。\n手机成了我们的一个器官。\n被动地接受着手机的推送成了一种时尚\n——不用思考，不用烧脑，看声像，看动图。\n但事实上这个“自动推送”的算法的黑洞有多深呢——\n算法一手抓内容。\n图文、视频、小视频、问答、微头条，每种内容有自己的特征；\n另一只手抓用户。\n兴趣、职业、年龄、性别、机型……然后刻画出的你的各种隐藏兴趣；\n三抓环境特征。\n不同的时间、地点、场景(工作/通勤/旅游等)，对应用户不同的兴趣点。\n听上去好像很复杂。\n复杂就对了，你不懂就对了。\n因为它掌握了大数据，大数据剥光了你。\n这种大数据下的世界\n你只能接触到所有人都爱上的东西，\n比如“震惊！”、“刚刚！”、“定了！”\n比如变脸、手势舞、海草海草……\n视觉冲击、声乐冲击刺激着你的神经。\n你兴奋，你痛快，你的多巴胺上升到极值；\n你也麻痹，你也顺从，你再也不会思考了。\n想到这里，我不自觉地握了握手中的手机\n想起了刘震云说的一句话：\n“现在是哪儿还有净土呢，是一机在手，在劫难逃。”\n夸张一点地说，在你用抖音连上网络那一刻\n你别再指望时间属于你\n甚至，你也不再能指望\n你的心智属于你，你的爱好属于你。\n你已经被这个 App 所控制。\n为什么抖音会让我们上瘾？\n心理学博士亚当 · 阿尔特写的\n《欲罢不能：刷屏时代如何摆脱行为上瘾》一书中\n列举了六项行为上瘾的构成要素，分别是：\n诱人的目标\n无法抵挡且无法预知的积极反馈\n渐进改善的感觉\n越来越困难的任务\n需要解决却暂未解决的紧张感\n强大的社会联系\n以上这些，抖音一键全包。\n首先，无法预知的下一页\n和动漫游戏一模一样\n你永远不会知道抖音刷一下\n下一个画面是什么\n这就是一种“无法预知的积极反馈”。\n它就像吊着一根红萝卜引诱兔子\n它永远追不上，又永远痴迷。\n特么太刺激了，无法预料的事情\n就是一颗诱人的巧克力\n其次，超级便利的互动\n更让人无可抵挡的是\n点赞这个小心心\n点一下太容易了，双击 666，\n“即时就反馈”。\n便利的互动让人无法拒绝\n第三，高音重复音乐反复播\n不得不说，抖音的音乐全是洗脑式的“神曲”\n朗朗上口，娇萌可爱\n不用 1 秒你就被节奏带进去了。\n无需搜索，不用思考\n音乐的节奏让人进入半催眠状态\n有某一刻你也许怀疑，自己到底身在何方。\n1979 年，精神病学家科奈利乌斯·埃克特（Cornelius Eckert）将这种现象命名为“耳朵虫”（earworm）现象。它指，\n一段长度为 20 秒左右的音乐在当事人毫无意识的情况下\n突然在脑内反复循环\n可以在人的大脑里面持续时间通常为数小时至数天不等\n科学家进一步的研究表明\n三类人最容易被“耳朵虫”找上门：\n神经官能症患者\n精神压力较大的人\n处于极度疲劳状态的人\n好吧，我知道，说的就是你。\n你就是那个在“耳朵虫”的引诱下越走越远\n直到手机低电量的提示音像个闹钟一样提示你不能再玩的傻白甜。\n当我假装卸载了抖音…\n颜之推说：\n“天下事以难而废者十之一，以惰而废者十之九。”\n是的，我就是那个以惰而废的人。\n我曾经“假装”卸载了抖音\n决心决意每天都不再碰它。\n然而三天之后\n我又以“研究新媒体动态”为借口\n无法自拔地沉迷进去。\n一刷三小时，稿子也没法写了\n深深陷入了“假装不理他”—“还是会想他”—“真的离不开他”—“从此恨透了他”—“又假装不理他”的死循环。\n相比之下\n有一个普通的工地妇女——马慧娟则比我牛多了。\n她和很多很多的你我一样\n时时刻刻都在看手机\n工作时看，吃饭时看，睡觉也看。\n乍看，似乎应该是抖音迷、快手王、今日头条之星\n可谁能猜到，她其实是在利用手机在写作。\n家境贫穷的她没能念完初中\n婚后才拥有第一部手机\n拿到手机后的几年里\n她没有在抖音快手这种十八线城市必备品里沉迷\n反而一直坚持在手机上撰写自己的文章\n最后洋洋洒洒写下一百多万字\n出版了散文集《溪风絮语》\n归根结底，手机吸引懒人\n培养懒人，摧毁的也是懒人\n所以，重要的不是你卸不卸载抖音\n而是你拿着手机那一刻，心中有志，眼里有事\n\n\n转载自：文/维小维生素\n\n","plink":"https://becase.top/resources/extract/为什么卸载抖音/"},{"title":"关于学习那些事","date":"2024-03-11T03:17:20.565Z","date_formatted":{"ll":"Mar 11, 2024","L":"03/11/2024","MM-DD":"03-11"},"updated":"2024-03-11T03:17:20.565Z","content":"关于学习，我们最大的三个困惑是：学习是为了什么？我该学什么？我该怎么学？对应到 6W 分析法中，分别是 Why？What？How？我们一个一个聊。\n我们为什么要学习呢？这个问题听起来很简单，但深究一下，也没有那么简单。\n是为了回应父母的期待吗？是为了拿到 offer，获得一份高薪的工作吗？为了打败他人，享受人上人的感觉吗？\n亦或者是为了中华崛起，实现中华民族伟大复兴吗？是为了离开当下的环境，看到更高的风景吗？是为了实现自己的理想，实现个人价值吗？再或者是为了帮助他人获得幸福快乐吗？\n在我们上学的很长一段时间里，我们并不需要给出自己的答案，父母、老师、同学、甚至社会、国家都给了我们答案，我们甚至不需要认可这些答案，只用按部就班、学习考试就行。\n但也正是因为这样的环境，我觉得很多人失去了对这个问题的思考，以至于不知不觉间，将学习本身当成了目的。遇到困难，我去学习就好了，等我学完，这些困难一定就能解决了吧？父母对我的成绩不满意，我去学习就好了，我把所有的时间都用来学习上，这下他们不能再伤心了吧？学来学去就是没有什么进展，哪还能有什么办法，我只有更刻苦自律，把每分每秒都用到学习才行。\n而学习的终点是考试，是 offer，是……，所以当到达终点时，很多人也就不再学习，这也就是为什么高考结束后，有那么多的学生都会撕书以示“庆祝”。\n你可能想，我都已经毕业了，才不会犯这样的错误。可是你回想下过往的学习经历，你是否经常破釜沉舟般的推掉所有事情，把时间砸到学习上，但实际学习的效率却很低，一天到头也没干成啥事？也许有一两天学习效率很高，但大部分的时间是不是在分神、发呆、休息、精神涣散中度过？\n如果是这样，也许你就是在“假装学习”。 这像极了小时候的我们，父母管教严格，去干学习之外的事情都会被说教禁止，于是我们形成了“不管学什么，学的怎么样，我只用表面是在看书就行了”的潜意识，而我们在面对低下的学习成果的时候，我们也容易安慰自己，“我并没有把时间花在其他的地方，我可一直在努力学习，至少我要比那些去玩耍的人强吧……”\n所以你看，我们并没有追求真的学到什么，我们追求的是学习这个行为本身，是自己学习的姿态，是为这样的姿态而感到的心理满足和迷恋。\n那么你可能问我，你认为学习的目的是什么？说真的，前面说的那么多目的其实都可以成立，因人而异。但我想说的是，倒也不需要想那么远，学习的目的不就应该是为了解决问题吗？\n你可能会说，你这不是废话吗？难道我现在的学习不是为了解决问题吗？\n那还真不一定。\n我认为中国的传统教育中，特别强调输入，让大家死记硬背，期望通过叠加阅读量，量变达成质变，而所谓知识的实践则体现为考试中的各种变种题目。至于我们用学到的知识解决了什么实际的问题，其实并不重要。\n这种重输入轻实践的教育倾向，也让学习的我们，过分看重知识的学到，而不是知识的应用。\n但是问题在于，如果一个人只是坐着，即便他的思绪已经破涛汹涌，但对于这个世界而言，他只是在那里坐着，其影响只是零而已。因为你对于世界的影响是靠行动做出来的，而不是单纯的思考，就算你在脑海中解出了哥德巴赫猜想，你也要写出论文发在期刊上，这才算是对世界产生了影响不是？所以你什么也不做，亦或者只是思考，写了一堆笔记日记，也只是对自己有益，你对于这个世界、对于他人依然没有什么影响，你也不会产生任何价值。\n但我们就是如此，学习一个知识学到了 50 分，感觉不够，通过刻苦的学习将其提高了 100 分，但到这里也只是满足个人的精神洁癖而言，无论学到了多少分，你只是在那里坐着，对于这个世界的影响依然是 0，依然不会产生任何价值，只有当你输出了东西，才可能会产生价值，但很多人如此轻视输出这件事情，以至于即便学到了 100 分，最终对于世界的影响依然停留在了 50 分，那这刻苦学习提高到 100 分的意义是什么呢？\n我们经常看到这样的评论 ——“收藏即学会”，我知道这是戏谑，大家也都知道这是假的，但学到即学会，大家却实在的认可这是真的，并且真的这样做。\n其实古人就说过“学以致用”，我们已经不是学生了，不需要再去参加纸面上的考试，更需要的是实践上的应用。但太多的人还停留在上学时的学习习惯，知道强迫自己学习，但疏于让自己实践输出，最后时光流逝，刻苦学习却什么也没有改变。\n所以有个段子叫：“你每天看耶鲁公开课，上 3W 咖啡听创业讲座，知乎果壳关注无数，36 氪每日必读，对马云的创业史了如指掌，对张小龙的贪嗔痴如数家珍，喜欢罗振宇胜过乔布斯，逢人便谈互联网思维……但你还在每天挤地铁。”\n智慧可以让我们在某些方面做得出色，但知识本身并不会产生价值。\n接下来我们说说学什么，对于大部分同学而言，学习前端知识，选择的是所谓的“系统学习”，于是各种去找资料，网上正好有一大堆所谓的“前端学习路线”、“前端知识图谱”，我在很早以前也写过系统学习前端的知乎回答：怎样系统地自学前端？，至今还有同学点赞。\n放到现在的我看来，我对于这个问题本身就有些疑惑，我们为什么要追求系统的学习呢？\n其实如果是刚开始要学习前端的同学，我觉得跟着一门看似系统的课程学习倒没有什么问题，你什么都没有学过，跟着系统教程走可以避免一些弯路。但如果是已经做前端一段时间了，工作都能做上手了，再跟着所谓的系统教程走，多少有点舍近求远了。\n我们之所以想要系统学习，我认为这跟我们一直以来的教育习惯有关系。无论是小学、初中、高中、乃至大学，都是在固定的知识范围里学习、出题，以至于让大家以为我们学习的内容是有边界的，只要我们系统完整的学习完内容，我们就可以考一个高分，拿一个好成绩。\n但前端的学习并不是这样的，它涉及的知识范围非常广，并且可以无限延伸，就算完整的学习了所有内容，受制于当下的公司、环境，能用到的知识，其范围也是有限的。大部分的知识只是学过就忘记而已，这样看来，所谓“系统完整的学习”其本质就是一个给自己找自信的过程，以为自己“系统学习”了就能抗得了所有项目中遇到的难题。\n如果我们学习的目标是为了解决我们实际中遇到的问题，所谓的“系统学习”就更像是让我们全部学习一遍后，然后根据实际遇到的问题再发挥我们学到的知识，就像我们上学的时候，把知识都学习了一遍再去考试，但这是低效的做法，因为我们实际遇到的问题已经遇到了，就相当于我们已经拿到了考卷，为什么不认真的答题，却非要去完整学习一遍再来答题呢？\n在我刚开始工作的时候，我虽然已经能够应付工作，但当我接触的东西越多，我就越觉得自己只是学了一堆 API，所谓基础、底层、源码层面的东西也想看懂，但学来学去，就是摸不到门道。终于有一天，在煎熬之下，我认真的思索了，目前想要掌握的知识点。不是一个具体的方向，比如 React，而是具体的知识点，如原型、作用链、diff 算法等。\n我写了上百个我认为需要掌握的知识点，写满了一张纸，然后又将其分类，去除掉一些觉得用不到相对价值小的内容，最终划分为了四类，JavaScript 底层，JavaScrit 功能（防抖、节流这些）、ES6、React。\n后面我就按照这些知识点，一个一个去查资料去学习，将这些知识点一个个划去。实际上，在学习的时候还会产生新的点，那就再加入其中就好了。可能你要说了，你这不还是“知识图谱”、“系统学习路线”吗？确实如此，我们学习是一定要有一个路线规划的，这很正常，你能搜到的那些图谱最大的问题是，他们总是求大而全，而你压根就跟不下来，当然你也没有必要跟下来，你要做的是，结合自己的目标和实际工作，确定自己的学习方向，在打实基础之外，学习有可能应用到你工作中的知识点。\n也许你会反驳，但是面试需要我全能全知呀。这很明显是一个对面试的误解，如果你去搜面试题，那真的是什么问题都问过，为什么会这样呢，我想这应该是面试者的背景截然不同，所以才根据简历，问了各种各样的问题。\n如果你去面试淘宝，虽然淘宝的主技术栈是类 React，但这并不是说只会 Vue 的同学就不行，实际上，如果你能对 Vue 的底层非常了解，这依然体现出了你的能力。越是大厂的面试，对于通用能力即学习、实践、思维、沟通等能力的要求就会越看重，如果你能把项目做好，远比你迎合对方的技术栈要加分的多。\n而关于具体学习的技巧，费曼学习法就是一个很好的方法，其实回过头来，我当时每一个知识点都写了一篇文章，无形中也是实践了费曼学习法。\n作为一个非常知名、备受推崇的学习法，非常有必要了解和学习一下。哪怕你没有用上，但是很多理念也许就在无形中改变了你的学习方式。\n作为一名物理学家，费曼因自己独特的教学方式广为人知，深受推崇。他总是能深入浅出地将复杂的专业理论讲得通俗易懂，深受学生喜爱，后来，越来越多的人便采用他的这种方法学习，最终形成了人们众所周知的“费曼学习法”。所以费曼本身并没有将这些内容理论化，这些原则是由无数的追随者和思维学家整理而成。\n所以不像“番茄工作法”，你可以阅读番茄工作法的作者亲自写的说明书，关于费曼学习法，虽然有很多文章，但还是推荐更系统全面的书籍，就比如微信读书上的《费曼学习法》，尽管这本书很多人吐槽将几千字的内容扩展成一本书，以及还是不知道怎么实践，但我还是阅读了 2 遍。\n我们阅读的很多书籍，其核心观点不过几百字而已，但如果你只看这几百字，你不会有什么大的认知改变，只有将这些观点不断地扩充，在你阅读的时候，反复提及、论证、拓展，你才有可能真的理解或者顿悟这些观点，所以我觉得这本书依然值得阅读。很多文章虽然写的也好，但相比起来还是单薄了些。\n而所谓的费曼学习法其实很简单，它的核心是——当你准备学习一门新知识时，必须站在传授者的立场，假设自己要向别人讲解这门知识。那么你一定要用最简洁、清晰和易于理解的语言表达出来，才能让行外的人也能听懂。费曼说：“最好是几岁的小孩也能明白你在说什么。”\n再简单来说，费曼学习法强调输出，当你学习完一遍的时候，尝试向别人讲解你学习到的知识。再说白了，以教为学，虽然表面是在教别人，其实你也是在以教的方式逼迫自己查漏补缺。\n我们都知道有这样一个学习效率金字塔：如果只是听别人讲，内容留存率只有 5%，如果是自己阅读，则为 10%，视觉 + 听觉，则为 20%，与别人讨论，则为 50%，讲知识用于实践，则为 75%，讲知识教授给他人，则为 90%。\n这个数据是否准确倒不重要，重要的是，它说明了，如果你能教授他人学会，说明你才是真的学会了。所以费曼学习法格外重视“输出”的作用，而输出就是复述你所学到并理解到的知识并让听者理解。\n输出落实到具体的形式，则可能有多种，给自己讲解、给他人讲解、写博客、做视频等等都是，很多人采用的是写博客的形式，这很不错，也是我采取的方法。\n但我发现很多同学虽然也写了，但只是写在笔记软件里，并不愿意分享出来，理由也很简单，觉得写的简单，大量珠玉在前，害怕献丑，想着等以后厉害了再发出来。\n通常害怕分为三个层次，一是害怕事情，二是害怕事情带来的后果，三是害怕自己无力承担事情带来的后果。 以写作发文为例，一是害怕发文，二是害怕发文被冷嘲热讽，三是害怕自己无力承担自己发的文章被冷嘲热讽。再或者是，一是害怕发文，二是害怕发文后无人问津，三是害怕自己无法接受自己如此失败的事实。\n其实冷嘲热讽倒还好，实际上我写的第一个系列是被冷嘲热讽最多的一个系列，但时间会为你洗刷掉这些，最糟糕的可能是无人问津吧，但我是认为，如果你遇到了一个问题或者阻塞的难点，你将其写出并分享，终有一天会帮助到其他遇到相同问题的同学，尽管可能不是在当下。\n写作这种东西呢，也不要有完美主义倾向，好的文笔是练出来的，好文章是改出来的。当下可能确实有点差，但随着你不断地写作，收到大家的反馈，你会写的越来越好。如果只是放在自己的草稿箱里，你并不会有什么长进。“等我厉害了，准备好了”只是一个给自己逃避不做的理由而已。\n最一开始写作，也不用写太多，可以从讲清一个知识点，阐明一个观点开始。\n也有同学跟我说，有些文章写的太好了，感觉无法超越。实际上，你写文章首先是为了帮助自己梳理知识，其次，这也是一种完美主义倾向，潜意识里不就是“如果写得不好，超越不了别人，那不如不写”嘛，完全没有必要，再者，感觉无法超越，多是因为自己对这个问题的理解已经被这篇文章带着走了，你可以再阅读一些其他相关的文章，等积累的多了，也许你就有自己的切入点了。\n以上是我认为的，关于学习的第一个要点 —— 以教为学，而学习的第二个要点，我认为是 —— 困难的地方就是你弯道超车的地方。\n稻盛和夫说过：“你不会的东西，觉得难的东西，一定不要躲，先搞明白，后精湛，你就比别人优秀了。因为大部分人都不舍得花力气去钻研，自动淘汰，所以你执着的努力，就占了大便宜”。 所以学习时，遇到困难的地方，不要很本能的就去逃避、跳过，在困难的地方浅尝辄止，在简单的地方反复横跳，最终荒废的只有你的时光。\n遇到难点，你应该感到兴奋，如同发现了一条可以快速超越的弯道，并且下定决心、不惜一切攻克它。这样劈荆斩棘的学习姿态反而是最为高效的学习方法。很多东西就是很难的，就比如读源码，没有什么简单高效的方式，你啃得下来就显得厉害一分，啃不下来就只能仰望他人。\n如果这个过程中还有什么技巧的话，那就是找寻自己的拉伸区不断训练。很多人总想着一蹴而就，直接就选了困难区的东西，结果学不懂，最后铩羽而归。如果牵涉到的概念太多，看不懂也学不下去，说明是困难区，那就换种简单的方式。想学编译原理，然后就去啃龙书、虎书，那不如从看简单的文章做一个简单的编译器开始。看书看文档看不下去，那就去看看视频教程。很多事情做不下来，那就思考下有什么简单一点、更能接受的方式去开始，退一步不是认怂，反而是智慧的表现。也不要总是强求自己去做下来，最糟糕的是，时间浪费了，热情也消磨了，最后还产生了逆反心理。\n学习的第三个要点 —— 以慢为快。我们经常会追求高效学习，但高效学习并不应该指几个小时就看完一本书，或者能够 2 倍速刷完一个视频。学习是学习者在已有认知的基础上，接纳新的知识，巩固或者改变原有的认知，形成新的认知的过程。 很多知识它就是需要时间来消化理解的，过快的速度只会破坏这个过程，没有对于概念的深度考究和思考，就只是记住一些概念而已，所以对于所谓“学的快的”同学，也不用羡慕，我们比的从来不是多快能学完一个课程，而是大家对于这个课程的理解程度。\n而在学习过程中，一开始的学习一定要慢，换句话说，一定要扎实，因为如果前面的学习有很多漏洞和盲区，后面所有建立在这些基础之上的知识就会摇摇欲坠。之前的漏洞和盲区若是得不到彻底的解决，之后就会一直受此影响，学习上的新问题和新漏洞也会越来越多，最后人只能在焦躁、失望、消沉中选择放弃。\n以上三点，是我认为学习过程中应有的认知，换句话说，我认为这是学习之道。但在具体的学习中，依然有一些想法可以讨论，我想再讲 4 点：\n第一点是所谓“坚定的信念”。我在很长的一段时间里都在思考人生的意义，人生的目标（当然现在我也会思考），我之所以会这样想，是因为我潜意识里觉得，如果我能找到人生的目标，我就能看清方向，拥有无限热情，刻苦努力、严格自律、专注高效，学习更是绰绰有余，甚至会涌现一种使命感。\n尽管我的理智很容易辩驳这个想法，但我潜意识里还是禁不住这样想。你说这个想法正确吗？对我个人而言，我完全无法证伪，因为连第一步，找到目标我都没有做到，怎么证明我在拥有目标就会如此呢？\n但我依然愿意这样想，并觉得应该建立起一个“坚定的信念”，于是看书思考，研究前人智慧，思考古往今来，深刻剖析自己，发掘天赋兴趣，你说这些有帮助吗？我不能否认，它确实有一些帮助，但最终落到具体的学习的时候，我依然会拖延、懈怠，分神，禁不住诱惑，会挫败、失落、低沉、惶恐不安。\n我希望“坚定的信念”能让我顺势而下，势如破竹的解决所有问题，我也总想把遇到的所有问题都推到“坚定的信念”上。然而学习就是学习，信念目标可以一定程度上解决内驱的问题，但学习就是会讲究方法、技巧、环境、能力等等，信念带来的“意志力”并不是取之不竭的，如果学习是一个系统，“信念”只是一环而已，单靠“意志力”是做不到的。我们真正要做的是，建立起一个学习的系统，引导出自己做事的兴趣、热情和成就感，这样你才会越做越起劲，最后不断地运转下去。\n第二点是学习的“反人性”问题。你觉得学习“反人性”吗？很多人认为，自律、学习都是“反人性”，所以“你越逆人性，你就越厉害”。这样的看法不可置否，但我个人并不持这样的观点，因为在我看来，人性是复杂的，毛姆的《月亮与六便士》中：“卑鄙与高尚，邪恶与善良，仇恨与热爱，可以并存于同一颗心灵中”，马斯洛也有需求层次理论，从生理安全到自我实现，皆为人性。\n所以人是有趋利避害、短视懒惰的一面，但人也有好奇求知、知羞耻荣辱的一面，所以学不下去，贪图享受是你的人性，但好奇求知，为了理想也是你的人性，刷一天抖音是你的人性，刷完后的空虚和悔恨也是你的人性。我们要做的并不是在痛苦的时候再压自己一把，这样只会彻底的引起心理反感，我们要做的是，发挥和引导人性中积极的一面，向着阳光走，阴影自然就会留在身后。\n第三点是即时反馈。为什么打游戏刷短视频会很爽，一刷就停不下来呢？因为游戏有即时反馈，你每一个操作都会让你知道自己在变强变弱，从而立刻调整，看到成效，而短视频因为时长比较短，十几秒一个，而且易操作，只要手指不停滑动，感兴趣的内容就会源源不断的推送到眼前，即时反馈，及时满足，而短视频背后的算法还会根据你的每一个行为推测你的喜好，最终比你还要了解你自己，视频带来的满足感就会更强烈。\n但学习不是这样，它的反馈周期长，而且从反馈的程度来看，也会弱很多。举个例子，如果你想通过认真的学习，然后做一个小项目，整个过程因为时间周期太长，你中间看不到任何反馈，你很容易就放弃了，而过程中你实现了某个小目标，虽然感受到了自己的“优秀”，但这种反馈又比较温和，一个东西花时间又久又看不到什么大的成效，出于人趋利避害的本性，人自然就会去逃避放弃。\n反过来，知道了即时反馈的原理，我们也可以调整学习的方式。一方面是缩短学习周期，就像做产品也是从 MVP 开始，学习的时候也应该明确的建立起小目标，采用小步快走的方式，及时获得反馈。以写书为例，如果成就感只来自于最后的出版，因为周期太长，做着做着就没了兴致，所以可以从平时的写作做起，感受每一个小目标的完成、每一篇文章带来的外部反馈。另一方面则是增加反馈感，在每一个目标或小目标完成的时候，不仅仅是感受完成的满足感，更要给自己带来更多的奖励，或者是发条朋友圈，或者是送自己想要的一个东西，无论是什么，都是为了让你的大脑增加目标完成时的多巴胺，这才会增加大脑上瘾的几率。\n个人成长的时候，最容易出现的就是没有明确的完结时间点，然后一门心思的往前跑。我们经常把人生想象成一场马拉松，仿佛只有冲过终点才算完结，但其实我们也可以把人生想象成一场一场的短跑，每场短跑都有一个明确的完结点，都有一个明确的结束仪式，都有一个明确的奖励，都有一个明确的休息，这样你反而能更有活力的完成旅程。如果只是在心中守着永远在未来的成就节点，只会在实现的路途上，心力交瘁，半途而废。\n第四个是关于合适的环境和氛围。先说环境，正如图书馆比寝室更适合专注，干净整洁的地方比杂乱无章的地方更容易专注，作用单一的地方比作用多样的地方更容易专注。最后这个，举个例子，如果你坚持床是用来睡觉和睡觉的地方，那么你的大脑就不会对床和玩手机产生联系，你就更容易早点睡觉。\n而关于氛围，有一句非常经典的话，叫做**“一个人走的快，但一群人走的更远”**。在群体的作用下，因为彼此有共同语言，加上相互肯定，人们就容易坚持住一个习惯。当我们看到他人的努力时，我们也会受到感染，坚定信心，所以找一些志同道合的朋友，加入一些好的社群都是不错的选择。我经常以我社群的一些活动为例，举得太多了，就不多讲了。\n最后总结一下，我们学习是为了自己，是为了真正的解决问题，切忌“假装学习”。虽然系统学习看起来很不错，但从自己的兴趣和工作出发，是更好的学习方向。在具体的学习中，应强调输出，以教为学，每一个困难的地方都是超车的机会，以慢为快，踏实的打牢基础知识点。\n学习是一个系统，我们不能总是依赖意志力，要讲究方法、技巧、环境等，引导自己做事的兴趣、热情和成就感，这样你才会越做越起劲，最后不断地运转下去。\n\n\n转载自：冴羽答读者问：如何学习更有计划性、提升更稳更快？\n\n","plink":"https://becase.top/resources/extract/关于学习那些事/"},{"title":"刻奇国里说刻奇","date":"2024-03-25T06:30:06.375Z","date_formatted":{"ll":"Mar 25, 2024","L":"03/25/2024","MM-DD":"03-25"},"updated":"2024-03-25T06:30:06.375Z","content":"一个人的自我欺骗叫做矫情，一群人的自我欺骗叫做刻奇。\n我们从小到大都处于刻奇之中：小时候写作文“看着胸前的红领巾我骄傲地笑了”，军训结束之后抱着教官哭得稀里哗啦，在人山人海的地方求婚，引来千人围观如同商场促销。\n这些时刻的共同点是：当事人带着激动和赞美看着自己的灵魂，感慨自己的崇高。\n刻奇，是一切真实的反面。\n捷克作家米兰·昆德拉在《生命中不能承受之轻》当中，给了刻奇新的含义：\n看到一个小孩子在草地上奔跑，第一颗眼泪说：孩子在草地上跑，太感动了！第二颗眼泪说：和所有的人类在一起，被草地上奔跑的孩子们所感动，多好啊——使刻奇成为刻奇的，是那第二颗眼泪。\n在昆德拉的口中，刻奇不仅是一种艺术表现方式，而是成为了一种情感——\n一种能够被分享的情感。\n格林伯格认为刻奇的反面是艺术，而昆德拉认为刻奇的反面是粪便。\n昆德拉小时候看到一本木刻插画的《圣经》，看到上帝的形象，想如果他有嘴，就得吃东西；如果吃东西，就有肠子。这个想法让他不寒而栗：一种上帝和粪便共存的事实。\n一个刻奇的世界，就是一个既不承认粪便，也不承认亚当和夏娃之间有性亢奋的世界。一个刻奇的世界，是为了扩张领土而发动战争，然而把战争的目的包装得崇高而神圣的世界。\n昆德拉对于刻奇的反对，与其说是道德层面的，不如说是美学层面的。他反感统治者在检阅台上高高在上的笑容，同样反感抗议者的热泪与激情。\n一个二十多岁拿起枪去山区参加游击队的男青年，与其说是受到某种召唤，不如说是被自己的形象迷住：在一个汇聚着成千上万目光注视下的伟大舞台。\n刻奇是自我迷恋，是灵魂的膨胀。昆德拉写道：“促使人举起拳头，握住枪，共同保卫正义的或者非正义的事业的，不是理智，而是恶性膨胀的灵魂。它就是碳氢燃料。没有这碳氢燃料，历史的发动机就不能转动。”\n《华尔街日报》曾经刊载过一篇名为《为什么独裁者爱刻奇》的文章。文章中配了一幅图：金正日端坐在巨幅图画前，画中是奔流的瀑布和几只小鸟。\n报道说，这幅画就是典型的刻奇艺术，采取的是非常浅白的隐喻：奔流而猛烈的瀑布象征着领导人的绝对力量，而几只小鸟象征着乐园中的人民。\n属于刻奇艺术的，还有伊拉克前总统萨达姆修建的“胜利之手”的雕塑。两只巨大的手按照萨达姆的手建造，各握一只巨大的剑在天空中汇合。同样被批评为“幼稚的刻奇”的，还有普京裸着上身蝶泳和骑马的照片，“显示出自己超级汉子，而且把自己视为超越常人的象征”。\n刻奇，作为一种宣传，是不惜一切讨好所有人的态度。为了说服所有人，它让生命超越自身，呈现出一种不自然的美感。\n人们期待得到高于自身的人物的赞扬，在很久之前，这个评价的人是神、是上帝、是高于自己的生命体。文艺复兴和科学的发展，把人们从上帝那里解救出来。没有了上帝，我们要在日常生活中寻找一个上帝的化身，所以要赋予生命一个崇高而神圣的意义，一个热泪盈眶的理由，一个感觉自己与其他人类同在的时刻。\n然而，在大多数时候，这种神圣的时刻并没有出现。所以我们只能自我欺骗，并寻求认同。\n我们寻找容易擦掉的眼泪：韩剧中得绝症死掉的女主角，电影里妻离子散、母子分离得哭天抢地、妈妈的白发和爸爸的驼背；我们寻找成本极低的崇高：在微博上呐喊“不转不是中国人”“这一夜我们都是 ×× 人”；我们寻找轻而易举的共鸣：“能哼出《黑猫警长》的主题歌说明你老了”“还记得小时候拍过的‘圣斗士星矢动画片吗？”\n欺骗是对别人掩盖真情，自欺是对自己掩盖真情。自我欺骗很难克服，因为它如同气球爆炸一样在瞬间发生，自身甚至毫无察觉。\n克服刻奇，首先要做到的是克服孤独。当其他人共同感动、流泪、愤怒、快乐的时候，要有足够的勇气不与他人同悲同喜。\n克服刻奇，并不是靠嘲笑他人“刻奇”来实现，而是靠捍卫自身的情感，如同捍卫自己的城堡。\n\n\n《刻奇国里说刻奇》 —— 蒋方舟\n\n","plink":"https://becase.top/resources/extract/刻奇国里说刻奇/"},{"title":"大唐三百年","date":"2024-03-11T03:17:20.565Z","date_formatted":{"ll":"Mar 11, 2024","L":"03/11/2024","MM-DD":"03-11"},"updated":"2024-03-11T03:17:20.565Z","content":"\n因为这个场景，对这个词影响深刻 视频链接\n\n依山傍水房数间，行也安然，坐也安然。\n一头耕牛半顷田，收也凭天，荒也凭天。\n雨过天晴驾小船，鱼在一边，酒在一边。\n路逢骚客问诗篇，好也几言，歹也几言。\n布衣得暖胜丝棉，新也可穿，旧也可穿。\n粗茶淡饭饱三餐，早也香甜，晚也香甜。\n夜归妻子话灯前，今也谈谈，古也谈谈。\n一觉睡到日三竿，不是神仙，胜似神仙！\n\n\n《闲居即兴》作者：萧锦忠\n\n","plink":"https://becase.top/resources/extract/大唐三百年/"},{"title":"如何听到时间的声音","date":"2024-03-11T03:17:20.567Z","date_formatted":{"ll":"Mar 11, 2024","L":"03/11/2024","MM-DD":"03-11"},"updated":"2024-03-11T03:17:20.567Z","content":"\n“我怎么叫呀？叫妈妈，对啦！”\n“怎么又拉一裤兜子！孩他爹，屎裤子拿一下！”\n“自行车让你爸教你！让他带着你骑！”\n“饭盒别忘了带！给你做了青椒面！哎呦，水瓶哪儿去了？”\n“又没及格？你还敢学我签字儿啊你！”\n“吃点橘子！吃点排骨！吃点青椒别老吃面！”\n“中考能考好，我就把电脑给你买了！”\n“怎么又打架？我看看，哎呦…”\n“妈给你报了个班，你看看去呗？”\n“大学别考北京了，那里太远，妈不放心！”\n“钱带的够吗？北京食堂卖青椒面不？”\n“一年你才回来一趟，不是寒假吗？怎么才十天呀……”\n“学校工作分配吗？妈也给你找了个公务员的班，就在咱们镇口！可好啦！”\n“那领导对你满意吗？没挑你刺吧，安全吗？北京地铁人多不多？”\n“升职啦！哎呦，哎呦，真好，真好，真好。”\n“你看看你过年也没回来，还不让唠叨几句！”\n“哪里认识的对象呀，那边家里是独苗吗？家长人咋样？”\n“你现在要孩子，你妈还没老，还能帮你带带。”\n“家里还有些钱，能给你凑个首付，买好的，买好的。”\n“你爸爸他……”\n“你多给妈打些电话，妈家里一个人待着，闷。”\n“过年还回来吗？带着娘俩来家里，妈给你做青椒面。”\n“妈能去北京看看你吗？过几年走不动啦。”\n“你回来啦，推轮椅带你妈出去转转……”\n“他们家卖青椒的也走了，妈每年底都收一捆，你没回，那椒一年就坏一捆。”\n“你说时间怎么过这么快呢，一转眼，你都这么大了……”\n“……”\n“…… 我怎么叫呀？叫爸爸，对啦……”\n\n你会继承某一个人的时间 在这条无边无垠的长河里继续流淌下去\n\n\n转载自：如何听到时间的声音\n\n","plink":"https://becase.top/resources/extract/如何听到时间的声音/"},{"title":"寒门贵子","date":"2024-03-11T03:17:20.567Z","date_formatted":{"ll":"Mar 11, 2024","L":"03/11/2024","MM-DD":"03-11"},"updated":"2024-03-11T03:17:20.567Z","content":"我三岁识了千字 九岁定了心智 五十岁考了千次 都没过一场乡试\n诸位切 莫笑 莫笑 聒噪  想我那年年少 也寒门贵子之貌\n我年幼时便聪慧 横扫了我的同辈 自学堂前那一跪 是少有过的干脆\n因爹娘卖了老牛 方在那学院长留 我与那老牛不熟 却犹记它的回眸\n我望它有些可怜 被换了几两银钱 它望我亦是生怜 要熬它几个十年\n老牛的体弱多病 在此刻犹如明镜  我想是我俩的命 皆难由自己来定\n十五岁写了一篇赋传在了十里八乡路 我人生中的高处 似唯有这道帷幕\n我成了族中之傲 几代人围我而绕 说此子虽是年少 已是寒门贵子之貌\n可读了九年私塾后所谓的天资已旧 那八股文我读的透 难解那朱门酒臭\n说来也是少年志 可笑我三千二百日  以为读书人的事 只有那四书五字\n两个富有的同窗 买到了两篇文章 三个阔绰的同乡 已高中到了北方\n那金榜上的俗人  明日会天下有闻 用银两换的俗文  被传成恰似有神\n年少的自命不凡 我用了三十年还 那功名二字不难 难在了寒门的寒\n我没能名落孙山 都没配在拿尾端 只听闻那位考官 将价码升了两翻\n我不服那位状元郎不觉得文章比我强 可他也自有他的狂 比如那添的偏房\n书中记的圣人言 我苦苦读了三十年 可书本中的圣贤 又哪会在过眼前\n父辈对我的期望 是别和他们一样 应也算不得失望 我怎配一模一样\n这半百岁的老玉 早没了缚鸡之力 我倒想耕一辈子地  可是这长衫难去\n我又见到了那头牛  它真是与我不熟 竟以为我也会低头 也跪那座座高楼\n我岂是那等俗人  要求着谁去听闻 自有那一段千古文 来破了这座寒门\n且看我昂首跨马行 去金榜旁上留个名 写尽我心中不平 去论一论那输赢\n我生在寒门又怎样 这世道不公又怎样 若半步也不曾让 也自可乘风而上\n再待我写一个春秋 让天下以此为羞 写到这四海九州 也明白覆水难收\n再与我共饮三千杯 莫道那岁月难追 就让我手中笔再挥 让当年那个少年归\n就用我笔下这一章来做这世上剩的光 愿可算是水一汪 泼给这天下的脏\n今日这酒楼一醉 也扶手道个诸位  一路山水无畏  问心无愧\n\n> 转载自：[《寒门贵子》如果你是那个古代书生！](https://www.bilibili.com/video/BV1ih4y1P769/?share_source=copy_web&vd_source=0a3a68371bef904c2d6aee415d4d8785)","plink":"https://becase.top/resources/extract/寒门贵子/"},{"title":"平台的垃圾化","date":"2024-03-11T03:17:20.568Z","date_formatted":{"ll":"Mar 11, 2024","L":"03/11/2024","MM-DD":"03-11"},"updated":"2024-03-11T03:17:20.568Z","content":"\n点名抖音等短视频平台\n\n\n平台是这么死掉的：一开始它们对用户很好；然后它们滥用用户来讨好自己的商业客户；最后，它们滥用这些商业客户，把所有的价值都追讨回来。接着，它们就完蛋了。\n我称之为“enshittification”（垃圾化），这是个看似不可避免的结果，因为改变平台对价值的分配方式很容易，再加上“双边市场”的性质，平台位于买家和卖家之间，可以劫持一方作为另一方的人质，从而抽取在二者间传递的价值，而且份额越来越大。\n一个平台起步的时候需要用户，所以它要让自己显得对用户有价值。不妨看看亚马逊：多年来，它一直处在亏损状态，利用其接触资本市场的渠道来补贴你购买的一切。它以低于成本的价格出售商品，并以低于成本的价格给你运输东西。它运营着干净且有用的搜索。如果你搜索一件产品，亚马逊会尽最大努力把它放在搜索结果的顶部。\n这对于亚马逊的客户来说是笔划算的交易。我们当中的很多人都蜂拥而至，以致许多实体零售商都倒闭死亡，很难有活路。亚马逊卖电子书和有声读物给我们，但这些电子书和有声读物是通过 DRM 永久锁定在它的平台上的，因此如果我们删除亚马逊及其 app 的话，我们在媒体上花费的每一块钱都是我们被迫放弃的一块钱。亚马逊向我们出售 Prime，让我们预付一年的运费。Prime 客户会从亚马逊开始自己的购物，在 90% 的时间内，他们都不会跑到其他任何地方去搜索商品。\n这吸引了许多商业客户——将亚马逊变成它从一开始就承诺要成为的“万货商店”（everything store）的交易市场卖家。随着这些卖家的涌入，亚马逊的补贴对象变成了供应商。Kindle 和 Audible 的创作者拿到了丰厚的报酬。交易市场卖家能接触到大量受众，亚马逊只向他们收取很低的佣金。\n这种策略意味着购物者想要在亚马逊以外的任何地方找到东西会变得越来越难，而这又意味着他们只能在亚马逊上搜索，进而意味着卖家必须在亚马逊上面卖东西。这时候，亚马逊开始把从自己的商业客户那里收获的盈余转给亚马逊股东。现如今，Amazon Marketplace 卖家的售价里面有超过 45% 是交给亚马逊的各种杂七杂八的费用（junk fees）。亚马逊耗资 310 亿美元打造的“广告”计划，实际上是一个让卖家相互竞争的付费计划，迫使他们为了争取成为你搜索的首选而互相抬价。\n如今搜索亚马逊不会生成与你的搜索最匹配的产品列表，它显示的是这样一个产品清单，那些产品之所以出现在上面，是因为卖家出的钱最多，所以可以占据搜索的顶部位置。但这些费用也包含进你为产品支付的成本之中了，而亚马逊对卖家给予的“最惠国待遇”要求意味着他们不能在其他地方以更便宜的价格卖自己的商品，这样一来亚马逊就把每一家零售商的价格都抬高了。\n在亚马逊上搜索“猫床”，第一页的屏幕全都是广告，其中就包括亚马逊山寨产品的广告，导致其他卖家被赶出市场（第三方必须向亚马逊支付 45% 的“苛捐杂税”，但亚马逊不会对自己收取这些）。总而言之，“猫床”搜索结果的前五页屏幕有 50% 都是广告。\n这就是 enshittification（垃圾化）：盈余先是返还给用户；然后，一旦用户被锁定住，盈余就会流向供应商；然后一旦供应商也被锁定了，盈余就会交给股东，而平台就会变成一坨没用的垃圾。从移动应用商店到 Steam，从 Facebook 到 Twitter，都是这么一个垃圾化（enshittification）的生命周期。\n就像 Cat Valente 圣诞前写的那篇权威大作描述的那样，这就是为什么像 Prodigy 这样的平台会在一夜之间摇身一变，从一个你去社交的地方，变成了一个对你的期望是“停止互相交谈，并开始买东西的地方”。\n这种盈余的骗局就是发生在 Facebook 身上的事情。一开始，Facebook 对你很好：它向你展示了你热爱与关心之人必须要说的话。这造成了一种相互劫持的局面：一旦你关心的人在 Facebook 上达到了临界数量，实际上你就不可能离开那里了，因为你必须说服他们所有人也离开那里，并就去哪里达成一致。你可能爱你的朋友，但如果有一半的时间你们都不能就看什么电影和去哪里吃晚饭达成一致的话，那就算了吧。\n然后，它开始往你的动态消息里面硬塞你根本都没关注的帐户的帖子。一开始，是媒体公司的帖子，这是 Facebook 给用户优选的精神食粮，好让他们点击文章并把流量返给报纸、杂志和博客。然后，一旦这些发行商依赖起 Facebook 的流量，它就开始减少流量。一开始，它的对象是那些用 Facebook 来展示带有自己网站链接的摘录的发行商，Facebook 切断了它们的流量，以此作为推动发行商在 Facebook 的围墙花园内提供全文动态消息的一种手段。\n这导致发行商只能完全依赖于 Facebook——他们的读者不再访问发行商的网站，他们只在 Facebook 上关注它们。发行商被那些读者挟持了，而读者又互相挟持了。然后，Facebook 不再向读者显示出版商的文章，调整 The Algorithm（算法）来抑制发行商的帖子，除非他们交钱给 Facebook、面向明确订阅了自己的读者“boost”（推广）他们的文章，并要求 Facebook 将它们放进他们的动态消息里。\n现在，Facebook 开始往动态消息里面塞进更多的广告，把你想看到的人的内容和想占据你眼球的陌生人的广告混在一起。它给了那些广告商很划算的买卖，只收取微薄的费用，让他们根据从你那里窃取的个人数据档案来发送定向广告。\n卖家对 Facebook 也开始形成依赖，因为如果无法访问那些定向推销的话，他们就无法开展业务。这时候 Facebook 开始暗示要抬高广告价格，不再担心广告欺诈，并与谷歌勾结一气，通过名为 Jedi Blue 的非法程序操纵广告市场。\n时至今日，Facebook 已经完全被垃圾化了，不管你是用户、媒体公司还是广告商，这个地方都很糟糕。这是一家故意对很大一部分发行商进行“拆家”的公司（那可是 Facebook 的依靠啊），用一则视频在 Facebook 用户当中很受欢迎的虚假声明，欺骗那些公司 “向视频转型”。结果在投入了数十亿美元之后，而受众从未变现，媒体机构一批批地倒闭。\n但 Facebook 现在有了一个新的推销手段。它声称这个东西叫做 Meta，这个东西要求我们在余下的日子里，用不长腿、没有性、受到严密监视的低多边形卡通人物的身份活着。它已向为这个元宇宙制作 app 的公司许诺，它不会像对待旧日 Facebook 上的发行商那样对待他们。有没有人为此买账还有待观察。正如马克·扎克伯格曾经向一位同行坦承的那样，他对所有那些将个人信息发到他的新网站“TheFacebook”的哈佛同学感到惊讶：\n\n我不知道为什么。\n他们“相信我”\n一群蠢货。\n\n一旦你了解了这种垃圾化的模式，许多平台之谜就会自行解决。想想 SEO 市场，或者一整个活跃的，花费了无数时间研究无用的平台克里姆林宫学（Kremlinology）的在线创作者世界，他们一门心思想要发现那一根根算法的绊线，因为碰到那根绊线的话，他们投入了金钱、时间和精力创作出来的作品就会失败。\n为平台工作就像给老板打工，他会因为你违反了各项规则而从你的每一笔薪水里面扣钱，但他不会告诉你这些规则是什么，因为如果他告诉你规则的话，你就会知道如何在他不注意和不扣你工资的情况下违反这些规则。内容审核是唯一将隐蔽性视为安全最佳实践的领域。\n现在的形势已经非常严峻，以至于像 Tracking Exposed 这样的组织开始招募一支人类志愿者大军以及一支由无头浏览器组成的机器人大军，试图解开 The Algorithm（算法）这台随心所欲的机器判决背后的逻辑，这既是为了让用户可以选择去调整他们收到的推荐，也是为了帮助创作者避免因为秘密屏蔽而导致工资被盗。\n但是，如果根本就没有底层逻辑该怎么办？或者，更重要的是，如果这种底层逻辑会根据平台的优先级而发生变化该怎么办？在你去赶集的途中，你也许会发现一些可怜的傻瓜整天带着一只巨大的泰迪熊走来走去，那是他们投篮中了三个球赢得的。\n这个投篮游戏被操纵了。巡回演艺团的人可以用一个隐藏开关让球弹出篮筐。除非他们希望你赢，否则没人能赢得一只大泰迪熊玩偶。为什么游乐场的人会让傻瓜赢得一个大泰迪熊？这样傻瓜就可以整天带着它，说服其他傻瓜掏出五美元，来获得赢得一个大泰迪熊的机会。\n这个巡回演艺团给那个可怜的傻瓜分了一个大泰迪熊，就像平台将盈余分给关键的表演者一样——他们是一个“大商店”骗局的说服者，是吸引来给平台创作内容的其他傻瓜的手段，从而把他们自己和他们的受众都给拴住。\n这让我想到了 TikTok。TikTok 有很多面，“为靠手机生活的青少年提供的免费的 Adobe Premiere”是其中之一。但它在早期之所以如此成功，是因为推荐系统的强大。从一开始，TikTok 就非常非常擅长向用户推荐内容。好得出奇。\n通过为它认为用户会喜欢的东西做出诚挚推荐，TikTok 建立了一个庞大的受众群体，比很多人想象的都要大——鉴于竞争对手像 YouTube、Instagram 等把用户拽得这么紧。现在 TikTok 有了受众，它正在夯实自己的收益，并试图挖走那些仍然顽固地抓住 YouTube 和 Insta 不放的媒体公司和创作者。\n前段时间，《福布斯》的 Emily Baker-White 对 TikTok 的母公司字节跳动来了一次精彩爆料，让我们得以窥见其内部实际的运作方式，文章揭露了 TikTok 员工会用“预热工具”（heating tool）把特定账号的视频推送到数百万受众的动态消息里面。\n这些视频会进入到 TikTok 用户的 For You（推荐页面）动态消息上， TikTok 称这些视频是“算法根据你在 app 的行为预测你的兴趣进行排名的”。实际上，For You 只是有时候由 TikTok 认为会给你的体验增加价值的视频组成——其余时候都是 TikTok 植入的视频，目的是让创作者认为 TikTok 是个接触受众的好地方。\n\n“消息人士告诉《福布斯》，TikTok 经常利用预热工具来吸引网红和品牌，通过夸大视频的观看次数来吸引他们建立合作伙伴关系。这表明预热可能会让部分网红和品牌受益——这是 TikTok 寻求与之建立商业关系的人——与之没有商业关系的则成为代价。”\n\n换句话说，TikTok 正在分发大泰迪熊。\n但 TikTok 并不从事赠送大泰迪熊的业务。尽管 TikTok 是个起源于中国的经济体，但它不过是又一个将人类视为不便的肠道菌群的人工有机体罢了，其目的还是回形针最大化（编者注：一个关于人工智能反乌托邦的隐喻，如果人工智能的目标是实现回形针产量的最大化的话，最终整个宇宙都会变成回形针的天下）。TikTok 只会将免费注意力引导到它想要诱捕的人身上，等到他们掉进了陷阱，它就会收回这种注意力，并开始将其货币化。\n“货币化”这个词很糟糕，它默认了不存在所谓的“注意力经济”。你不能将注意力用作交换媒介。你不能将其用作价值存储。你不能把它当作记帐单位。注意力就像加密货币：一种毫无价值的代币，只有在你可以欺骗或胁迫某人放弃“法定”货币来换取它时才有价值。你必须把它“货币化”——也就是说，你必须用假钱换真钱。\n就加密货币而言，其主要的货币化策略建立在欺骗的基础上。交易所和“项目”分发了一大堆的大泰迪熊，从而打造出一支由忠实信徒犹大山羊（注：Judas goats，畜牧员在圈养山羊时，会专门训练一只强壮的山羊为领头羊，利用山羊的从众跟随特性，在将要进行屠宰时，会事先通过给领头羊好处，利用它诱骗其他山羊进入屠宰场，而后畜牧员让犹大山羊溜之大吉）组成的军队，去说服同行者把钱交给他们，然后试着投中一些球进篮筐。\n但欺骗能产生的“流动性供应”只有那么多。最终，傻瓜会被你用完。要让很多人尝试投篮，你需要的是胁迫，而不是说服。想想看，美国公司是如何停掉保证你有尊严地退休的固定福利养老金，而用市场化的 401（k）养老金取而代之的，你被迫将积蓄押在被操纵的赌场上，这样你就变成了赌桌上的傻瓜，等着被人收割。\n早期加密货币的流动性来自勒索软件。一群绝望、惊慌失措的公司和个人的数据被犯罪分子窃取，这为加密货币的流动性建立了基准，因为他们只能通过用真钱换取加密货币假钱来取回数据。\n加密货币胁迫的下一阶段是 Web3：web 被弄成一系列的收费站，你只能靠用真钱换取加密货币假钱才能通行。互联网是必需品，而不是锦上添花，它是充分参与就业、教育、家庭生活、健康、政治、公民甚至浪漫的先决条件。通过持有所有这些东西去赎回加密收费站后面的东西，持有人希望将他们的代币兑换成真金白银。\n对于 TikTok 来说，“预热”持怀疑态度的表演者与媒体公司发布的视频是一种手段，免费发放泰迪熊是将他们变成忠实信徒的一种手段，这样这些信徒就会把所有的筹码都推到桌子中间，放弃他们在其他平台上建立受众群体的努力（TikTok 的格式与众不同也起到了帮助作用，这样就很难把视频重新用于在 TikTok 的竞争对手平台上传播）。\n一旦这些表演者和媒体公司被迷住后，就进入下一阶段：TikTok 会撤回“预热”，不再把他们的视频贴到从未听说过他们、也没有对看看他们的视频提出请求的人面前。TikTok 在这里表演的是一种很微妙的舞蹈：用户的动态消息上他们能折腾的垃圾化（enshittification）就只有这么多，而且 TikTok 上面还有很多其他的表演者是他们想派发大泰迪熊的。\nTikTok 不仅会通过算法降低表演者的优先级来剥夺赋予他们的“免费”注意力，还会通过“投递视频给订户失败”来主动惩罚他们。毕竟，每当 TikTok 给你看了你要求看的视频时，它就失去了给你看它想让你看的视频的机会，因为你的注意力是一个大泰迪熊，它也可以把它送给它正在追求的表演者。\n这正是 Twitter 在向垃圾化（enshittification）迈进的过程中的所为：由于它的“货币化”的改变，大多数关注你的人将永远也看不到你发布的内容。我在 Twitter 上面大概有 50 万粉丝，我的帖子过去的阅读量经常都有数十万甚至数百万。而今天，这个数字只有几百，或几千。\n我刚刚淘了 8 美元给 Twitter，为了换取 Twitter Blue 的资格，因为这家公司给我发出了强烈暗示：如果我支付赎金的话，它只会向提出要求的人展示我发布的内容。这是互联网上酝酿时间最长的战争之一的最新战役：一场争夺端到端的战斗。\n刚开始的时候，是 Bellheads 与 Netheads 之争。Bellheads 派为大型电信公司效力，他们认为网络的一切价值理所当然属于运营商。如果有人发明了一项新功能（比方说，来电显示），则只能以让运营商每月向你收取使用费的方式推出。这就是软件即服务，贝尔大妈（Ma Bell）风格的 SaaS。\n而 Netheads 派则认为价值应该转移给网络的边缘——应该是分散的、多元化的。从理论上来说，Compuserve 本来也可以实现自己版本的来电显示“货币化”（编者注：来电显示这项收费业务让你可以在接听前知道对方是谁），通过让你额外支付 2.99 美元，然后就可以在打开邮件之前看看电子邮件的“发件人”是谁，但是他们没有这么做。\nNetheads 希望建立起多样化的网络，上面应该有很多产品和服务，有大量竞争，并且切换到不同竞争对手之间应该是很轻松、成本很低的（因为具备互操作性）。有的之所以想要这样的网络，是因为他们相信有朝一日这张网会编织进这个世界，他们不想生活在一个由寻租的地主主导的世界里。有的则坚信市场竞争是创新的源泉。有的是这两样都信。不管是哪一种，他们都看到了网络捕获（network capture）的风险，看到靠诡计和胁迫实现货币化的驱动力，他们想阻止这种风险，遏制这种动机。\n他们构思了端到端的原则：即网络的设计理念应该是让愿意发言的人的消息尽可能快速可靠地传递到愿意收听的人的端结点。也就是说，不管网络运营商能不能通过向你发送想要接收的数据来赚钱，它的职责都是为你提供你想要查看的数据。\n在今天的服务层上，端到端原则已经寿终正寝。右翼那些有用的白痴被骗了，他们认为 Twitter 管理不善的风险是“唤醒了秘密屏蔽（shadowbanning，影子禁令，限流）”，也就是你讲的话不会发给要求听到它们的人，因为 Twitter 的深层机构（deep state）不喜欢你的意见。当然了，真正的风险是你说的话不会发给要求听的人，因为 Twitter 可以通过让他们的动态消息垃圾化（enshittification），然后向你收赎金换取获得（你的话）被纳入其中的特权，从而赚取更多的钱。\n正如我在本文开头所说的那样，垃圾化（enshittification）对平台资本主义施加了近乎不可抗拒的引力。把垃圾化（enshittification）的拨盘调到 11 太容易了。Twitter 把大部分的技术熟练工都解雇掉，仍然可以一直在转动拨号盘，即便拨动的是一群绝望、士气低落，拿着 H1B 的员工，因为面临被驱逐出境的威胁，他们已经被绑在 Twitter 这艘正在沉没的船上。\n垃圾化的诱惑还被互操作性的阻碍放大：当 Twitter 禁止可互操作的客户端、弱化（nerfs，最早指在游戏中，游戏开发或运营商在游戏版本更新时对于游戏的某些游戏内容进行削弱的调整行为）它的 API、并定期通过暂停账号来恐吓把自己的 Mastodon 账号放到个人档案的用户时，离开 Twitter 变得难上加难，从而增加了可以强制喂消息而无拂袖而去风险的垃圾化用户的数量。\nTwitter 不会变成一个“协议”。像 Bluesky 这样的项目在这个平台上没人会真的买账，我敢打赌，因为如果实施了 Bluesky（Twitter 的去中心化社交媒体协议），并且 Twitter 用户可以订购自己的动态消息，以便实现垃圾化（enshittification）的最小化，并在不牺牲自己的社交网络的情况下离开该服务的话，Twitter 大部分的“货币化”策略就要失效了。\n只有在适度的情况下，垃圾化（enshittification）策略才会成功。即使是被锁定得最牢的用户最终也会突破爆发点而走开，或者被推开。正如《屋顶上的小提琴手》（Fiddler on the Roof）中，安那特夫卡（Anatevka）的村民在最终被迫逃往克拉科夫、纽约和芝加哥之前，已经忍受了哥萨克人的暴力袭击和大屠杀多年。\n对于那些已经被垃圾化搞得一团糟的公司来说，这种适度是很难达到的。个别产品经理、高管以及激进股东往往都愿意以牺牲可持续性为代价来获得快速回报，并且个个都争先恐后，看谁能先吃掉他们的谷种。垃圾化（Enshittification）只能持续这么久，因为互联网已经退化成“五个巨型网站，而且每个网站上都充斥着其他四个网站的屏幕截图。”\n随着（碎片化的）市场被一群互相勾结的垄断者缝合，不会突然冒出更好的选择并引诱我们离开了，如果确实出现了这种情况的话，垄断者就会干脆把对方买下，并将其整合到垃圾化（enshittification）策略之中，就像马克·扎克伯格注意到大量出走的 Facebook 用户原来是跑到了 Instagram 上面之后，于是他就收购了 Instagram。正如扎克伯格所说的那样，“与其竞争，不如收购”。\n这是 Amazon Smile 兴衰背后隐藏的动态，当你在那里购物时，亚马逊会向你选定的慈善机构捐赠少量资金，但前提是你用亚马逊自己的搜索工具找到你要买的产品。这让亚马逊客户有动力去使用其自身日益垃圾化的搜索，里面也许塞满了被迫支付贿赂的卖家的产品，以及它自己的山寨产品。另一种办法是用谷歌，它的搜索工具会直接引导你渠去到要找的产品，然后向亚马逊收取把你送到它那里去的佣金。\nAmazon Smile 的关闭恰逢 Google Search（谷歌搜索）的日益垃圾化，后者是谷歌内部开发出来的唯一一款成功产品。它所有其他的成功产品都是从其他公司买来的：视频、文档、云计算、广告、移动等都是买来的，而它自己的产品要么像 Google Video 一样砰然倒下，要么是山寨别人的（Gmail 是 Hotmail 的克隆），或者改编自其他公司的产品，如 Chrome。\nGoogle Search 的开发原则是创始人拉里·佩奇（Larry Page）与谢尔盖·布林（Sergey Brin）制定的。他们在 1998 年的那篇具有里程碑意义的论文《大规模超文本网络搜索引擎剖析》中对此进行了阐述：“广告资助的搜索引擎内在地会偏向广告商而远离消费者的需求。”\n即便对垃圾化（enshittification）具备了根本理解，谷歌也无法抗拒它的塞壬之歌。今天的谷歌搜索结果是一个越来越无用的泥潭，里面充斥着指向其自家产品的链接、不够好没法靠自己爬到搜索结果头部的产品广告，以及寄生在前者身上的 SEO 垃圾。\n垃圾化很有杀伤力。谷歌刚刚裁掉了 12000 名员工，出于对“AI”聊天机器人兴起陷入的全面“恐慌” ，谷歌正在全力打造一款 AI 驱动的搜索工具——也就是一款不会向你展示你要求的内容，而是它认为你应该看到的内容的搜索工具。\n现在，你可以想象这样一个工具会给出很好的推荐，就像 TikTok“垃圾化”之前的算法所做的那样。但鉴于产品经理、高管和股东有强烈的动机将结果垃圾化到这样一个精确的阈值，就是让用户生气到几乎想要离开，但又不是很决绝的程度，你很难看出谷歌怎么才能设计出一个非垃圾化的搜索聊天机器人前端。\n即使它设法解决了这个问题，这种几乎没用但又不是一点用都没有的平衡也是十分脆弱的。任何的外来冲击——像 TikTok 这样穿透大型科技公司的反竞争“护城河和围墙”的新生竞争对手、隐私丑闻、员工造反等——都可能令其陷入剧烈震荡。\n垃圾化（Enshittification）确实是平台的灭亡之道。其实这没什么。我们不需要互联网有永恒的统治者。出现新的想法和新的工作方式是可以的。立法的和政策制定者的重点不应该是延缓垂死平台的暮年垂老。相反，我们的政策重点应该是在这些公司到期时最大限度地降低用户的成本：像端到端这样的权利意味着不管僵尸平台的自噬性变得有多强，愿意发声的和愿意倾听的仍然可以彼此相连。\n政策制定者应该关注退出的自由——用户要有离开正在沉没的平台，同时继续与离开的社区保持联系、享受所购买的媒体和 app，并保留所创建的数据的权利。\nNetheads 派是对的：技术自决与科技企业的自然要求不一致。当他们剥夺我们的自由——我们说话、离开、联系的自由时，他们可以赚更多的钱。\n多年来，即便是 TikTok 的批评者也不得不承认，不管怎么说，它确实很擅长猜测你想看什么。但 TikTok 无法抗拒这种诱惑：向你展示它想让你看的而不是你想看的。垃圾化已经开始（enshittification），而且现在已不大可能停止。\n\n\n转载自：平台的垃圾化\n\n","plink":"https://becase.top/resources/extract/平台的垃圾化/"},{"title":"情书","date":"2021-12-21T16:00:00.000Z","date_formatted":{"ll":"Dec 22, 2021","L":"12/22/2021","MM-DD":"12-22"},"updated":"2024-03-11T03:17:20.569Z","content":"\n我曾经想过跟你私奔，于是在地图上挑选了几个城市，厦门是第一个跳入脑海里的选择，符合一个想要私奔的人的理想居所----海边，清新，文艺加上可以找到稳定且不错的收入。\n但是转念一想我又担心你觉得庸俗，我更担心海边的风浪会卷走你对我的爱意，于是，我又开始寻找，我挑了几个城市，并列上选择的理由和不尽如人意的地方。\n昆明，我喜欢那儿的阳光和远离中土的喧嚣，云南菜倒是蛮符合我的品味不知道对你如何，但是那儿治安看起来不好，城里的小青年品味让人堪忧。\n长沙，我没去过但是听说那儿生活惬意夜晚热闹，可我担心常年吃辣会对肠胃不好，且我听不懂那里人说的话，也不喜欢湖南卫视的主持人们。\n成都，同样也是生活悠闲，同样也是辣的城市，我喜欢那儿，但是又担心气候，我知道你怕热怕出汗怕地震。\n我也曾想过北方的小城，比如青岛和大连，但我受够了那里的寒冷，或者你觉得是不是我们可以去拉萨和南疆，但是亲爱的，我想跟你生活在一起，而不是片刻的停下再出发。\n我算过我们的积蓄，可以买个大点的房子，不一定要新盖的，哪怕老旧一点或者偏远一些。因为我想你可能需要一个工作室，在你找不到工作的时候，你可能需要画图或者卖字来维持我们的生活。或者我也可以去找个朝九晚五的工作，但你知道我更爱每天做一道永不重复的菜来喂饱你。\n我希望墙和屋顶都是白色的，雪一样的洁白，那样搭配原木色的家具比较美。家具我们也不需要很多，一张床一个衣柜一个书桌还有几把椅子，水曲柳的材质或者干脆 从旧货市场找一些老式但保养良好的，我们拆了自己打造。我不介意学习如何做个木匠，但是刨花这种活儿亲爱的还是你来吧。\n床单要水洗棉的，看着舒服，书桌前要永远有一束白色的栀子花。\n地板上要铺一个厚厚的毯子，最好产自伊斯坦布尔，但我也知道尼泊尔那儿有一些相对廉价的货色。不然就长绒毛的跟大地一样的颜色，我们可以在白雪皑皑的冬天躺在上面看落地窗外面的雪。如果是夏天那就粗麻地毯，我们看云，就看上一整天。\n院子里种什么好呢，我说一定要种些香草可以做菜的，还要一些蔬菜和鲜花。我想要一棵苹果树一棵桃树还要一棵樱花树，还想要一条狗和一只猫常年趴在墙角晒太阳。\n我们有满满一墙的书，你会要我不要一直买下去了，而我会故意不听。每个午后，我们会在书房找个角落各自看书，直到天色渐沉，夜幕降临。\n你知道么，这些其实我也可以都不要，只要和你生活在一起，在一个不用繁华的城市。当然我们无法选择更小的城市，因为我们并没有可以傍身的手艺，同时我也希望你可以过的舒服一些。\n我可以坐几站地的公交接你下班，听你同事夸我温柔美貌，我们手拉手穿过公园学校，再在靠近家附近的摊位买上一两种你爱的食物。\n我们不为职称奔忙，我们也不要发财升官，如果可以有一家店支撑每月的饮食生活，那就开一家店，随便一家店。\n我们哪儿也不去，我们谁也不找，这样，谁也就不会走着走着就把谁丢掉了。\n我再也不需要漂亮衣服了，我只要棉质的麻织的，最简单的款式，最纯色的 T 恤。我会把头发挽起，我会从此素颜，只要你还喜欢这样的一张脸。\n春暖花开，风和日丽，窗前白色的幔帏随风飘荡，你写了一首诗给我，写了一封情书给我，你唱我爱的那首歌，我在旁边用钢琴帮你伴奏。\n我们共同完成一幅画作，却要你构思画稿和勾勒，我只管填色。\n我们在夏天时候去海边，在冬日寒冷的夜晚相拥入眠。\n就这样，日复一日年复一年，直到死亡那一天的到来。\n我想，我已经想象了所有的一切，却唯独忘了问你，要不要跟我一起走。\n","plink":"https://becase.top/resources/extract/情书/"},{"title":"我们失去长文阅读能力了吗","date":"2024-02-05T16:00:00.000Z","date_formatted":{"ll":"Feb 6, 2024","L":"02/06/2024","MM-DD":"02-06"},"updated":"2024-03-24T06:11:57.602Z","content":"起因是一次工作后去玩剧本杀，大家面对冗长的文字，纷纷抱怨读得好累，此时一位同事感慨，“我们似乎已经失去长文阅读能力了”\n我不太喜欢这种说法，却发现无法反驳，只能在无可奈何中又默默地背上一顶帽子\n那什么是长文呢？有标准吗，如果按照我们以前高考写作文的字数，姑且认为 800 字就可以算作长文吧，那看来我们以前是有读写长文能力的，现在面对剧本杀动辄上万字的文稿，我们似乎确实已失去了长文阅读能力了吧\n但我还是有疑问，阅读长文，这一再普通不过的技能，为什么会成为自媒体口诛笔伐的对象？难道这是一种稀缺的能力？\n不，实际上是这种所谓” 似乎失去 “的万能句式，有这极大的杀伤力。任何一件事物，只要套上，诸如，” 似乎失去了好好睡觉的能力 “，” 似乎失去了写作的能力 “，” 似乎失去了交友的能力 “等，这些本属于我们自己的日常生活，属于我们的私事，好像就可以被摁到自媒体们的放大镜下，接受鸡蛋里挑骨头般的考核（似乎，还带着一点朦胧诗意的语言🐶）\n走出了这种万能句式给我们设下的陷阱，再重新审视这个问题，有问题总是好的，我们大可不用愧疚，而是就事论事，我们真的有失去长文阅读能力吗？我认为是没有的\n如开头所述的场景中，工作劳累了一天的我们，面对上万字的文本，抱怨两声似乎也无可厚非，大可不用受到这种 pua 式的指责\n阅读长文本质是和注意力挂钩的，当你有足够满格的注意力，并且也不知疲倦，此时哪怕是二十四史在你面前，也都是小菜一碟吧\n就有人问了，那短视频、游戏呢，不是也分走了我们的注意力吗，此时我们是不是就已经失去了阅读长文的能力吗？\n注意力被分走了，但还是会恢复的，只是随着长时间的沉溺，注意力确实很难集中。但这并不代表我们就失去了长文阅读能力啊，哪怕长文，不也是一段段的吗，慢慢读不就行了\n只是在一些人眼中，似乎只要不是一口气读完长文，就不算真正拥有了阅读能力；似乎只要不是整天苦行僧般地学习，就不算真正地自律\n荀子是劝你们要学习了，但他老人家似乎从没要求过要逼迫自己吧，不积跬步，无以至千里，正所谓厚积薄发，慢慢积累就好\n以及，文本的质量，也会影响阅读的效率，这就不多说了，对比下《耶路撒冷三千年》的简中和繁中版本就知道了\n我只希望，那些” 水字数 “的自媒体们，少点心思，多沉下来，” 似乎你们已经失去了写出好文章的能力了 “\n","plink":"https://becase.top/resources/extract/我们失去长文阅读能力了吗/"},{"title":"独行的栈道","date":"2024-03-17T12:14:22.274Z","date_formatted":{"ll":"Mar 17, 2024","L":"03/17/2024","MM-DD":"03-17"},"updated":"2024-03-17T12:14:22.274Z","content":"\n\n\n当重新回到单身的生活后，我会很怕自己没有事情做，因为当自己空闲下来，回忆就会蔓延占领整个脑子，越美好的回忆，杀伤力越大，沉溺就会变成常态，因此我会给自己找些事情来做，也正因如此，我似乎也捡拾起个人的一些兴趣，时常让自己置于另一种状态里，就像刘亮程说的那样：\n\n寒风还是进来了，它比我更熟悉墙上的每一道细微裂缝。（《一个人的村庄》）\n\n人并不知道自己的弱点，只有意识才知道自己的弱点，回忆有的时候恰恰以无意识的形式慢慢扩散，找寻缝隙，比如我在骑行的时候，面对一段平直宽阔的道路，失焦后，这个过程就在发生，这当然是危险的，但是我并不想这样，直到一个物理的刺激或者心理的信号，才将自己拉回现实，对焦后继续行驶。\n并行的状态下如果不同频的话，人是会产生委屈的，近两年的亲密关系，让我深知这一点，就算表面上看上去无比的和谐，你们都清楚那不是真的。\n而独行的轨道意味着只有我自己，我想快就快，想慢就慢，想清醒就清醒，想伤感就伤感，自己能够把握的方面更多一些，自己需要考虑的更少一些，没有保持同频的要求，是很好，但是这时缝隙中进来的风会带来另一种不好的感受，那就是一般意义上的孤独感。不过这种孤独感于我而言并不是什么坏事，它反倒驱使我走向未知的地界。\n轨道意味着工作还得继续，咖啡也得继续喝，在我看来，日常的重复会让自己对旧的东西更加反感，继而去接触陌生的人和事物，去到陌生的地方。\n","plink":"https://becase.top/resources/extract/独行的栈道/"},{"title":"生于焦虑，死于自律","date":"2021-02-21T16:00:00.000Z","date_formatted":{"ll":"Feb 22, 2021","L":"02/22/2021","MM-DD":"02-22"},"updated":"2024-03-11T03:17:20.571Z","content":"\n很贴切，很现实，很无奈\n\n2020 年。\n我听了很多逆袭故事，看了很多学习方法，知道了好多能让我自律的技巧。\n我听的故事，给我震撼，激我共鸣，与我共情，多少次，我幡然醒悟，大梦初醒，热血沸腾，让我又有了莫大的勇气去面对现实，也给我了短暂的慰藉，告诉我亡羊补牢，为时未晚。\n我看的方法，教会我目标规划，精力管理，要我高效记忆，要我极度自律，跟我讲复盘总结的重要性，告诉我深度思考的紧迫性，警醒我碎片信息的危害性。\n底层原理，系统优化，流程拆分。一个个名词把我的学习观打得稀碎。\n我只能，卧槽，牛逼。\n如获至宝，当之如救命稻草。\n但是，多少次，午夜梦回。\n我掏出来手机，还是对沙雕视频，漂亮姐姐，马老师的五连鞭，成华大道的二仙桥，念念不忘。\n被窝里面，我悄悄哈笑 ，却又感夜色悲凉，整个世界都变无聊。\n也是 2020 年。\n有人义愤填膺：这个时代，注意力是我们最宝贵的财富，而所有的 app 都是在收割我们的注意力，用越来越先进的算法最大化占用我们的时间，然后把它们转售给广告商，也就是互联网的赚钱逻辑。\n也有人语重心长：千万不要吸收太多碎片化的信息和知识，这些东西逻辑简单，理解轻松，表达流畅，让安慰式的学习，带给我们短暂而无用的满足感。\n还有人憨里憨气：我跟你嗦要远离高刺激，习惯了高刺激，习惯了高水平的分泌多巴胺，那些不够爽的事情我们就越来越不耐烦了，看书，学习，提高自己，我们越来越难集中注意力在这些，无趣而有用的事情上了。\n知道了这些之后，我本该抵制被动推荐，选择主动搜索。\n我明明应该当个小香猪漫山遍野地跑，拱自己想拱的白菜。\n但是现在，我已经习惯了被动投食，哼哼唧唧，B 站的推荐，知乎的热榜。\n我深明大义，义无反顾，顾头不顾腚。\n一边排斥，一边真香，我清醒又荒唐，好玩又好笑。\n还是 2020 年。\n我 看到了，这个社会越来越两极分化，矛盾越来越大。\n贫富，两性，种族，东西方意识形态。\n不可调和，党同伐异，中门对狙，站队互喷，nmsl。\n贫富差距越来越大，阶级越来越固化，上升的通道越来越窄。\n公司在裁员，学历在贬值。\n焦虑，一时间，好像变成了所有人，通向未来的唯一解。\n以及，慢慢地，汹涌澎湃的 2020，我的情绪也变得越来越钝化了。\n我不再因为万里之外的不幸之人悲伤，我也不再因为千里之外的不公之事而愤怒。\n我看到的现实，赤裸裸，血淋淋，一波又三折，反转又反转。\n我再难感他人的不幸，再难再愤他人之所慨。\n我慢慢开始变得边界分明。开始变得冷漠又麻木。\n疫情过后，生活慢慢一切如常，我却大梦初醒。\n才发现，我其实自己一直都在跑道之上，跑道名曰人生，有人从未停息。\n我前瞻后顾，左顾右盼，好像周围的人，他们都在逆袭。\n但是，我却越来越无力，一种更可怕无力，我明明道理都懂，还是不愿意往前走的无力。\n我一边堕落，一边上进。\n坠落谷底，仰望天空。\n但是，我目力所及的身边也好，还是互联网的众生芸芸，还是有好多人在努力生活，在传递温柔，在朝着自己的目标全力以赴。\n他们跟我说“我们可以改变自己，大脑可以改造，性格可以改变，感性可以朝着理性引导，理性也可以温柔表达”\n没有人想堕落，也没有人想丧失人生的主导权，生活的控制权。\n也没有谁想，把自己变好的愿望，不合理地寄托于看到的某个视频，听到的某个故事，知道的某个道理，掌控的某个方法。\n清醒的人都知道，这虚无缥缈，满纸荒唐。\n我尝试了好多次，我试着做出改变，却屡战屡败。\n我发现，真的好难啊。\n大量碎片化的知识和信息已经不可阻挡地重塑了我的大脑，它变得越来越喜欢简单好玩的，越来越不愿意去思考，越来越不愿意发生改变，也越来越懒得质疑。\n大量高刺激的信息流，知乎抖音 B 站的精准推荐，已经让我适应了高刺激，我的大脑已经越来越难从低刺激的学习阅读里面，得到多巴胺，去得到学习的动力了。我们好像越来越愿意活在当下，越来越不相信未来了。\n在那些社交平台博主分享的视频经历里面，我已经考上北大清华了，也体验了月薪十万百万的生活，我参与过了国家大事，曾经带着俺的键盘冲锋陷阵，有死无生。你说看世界啊，也去过啦，极光海岛，温泉火山。\n醒过来的时候，我呆呆地发现，我还在原地。\n只是，人潮变得越来越拥挤了，我变得更焦虑了。\n身边的人都已经超过我太多太多了。\n因为自尊也好，虚荣也好，好胜不甘心也好，我还是觉得，现在就躺平，认了所谓虚无缥缈的命，我舍不得，不可能，不愿意！\n但是我是一个很难因为认同什么，因为什么共鸣去持续努力的人，我需要那种能够说服我去努力的底层原理。\n身边的人都已经超过我太多太多了。\n因为自尊也好，虚荣也好，好胜不甘心也好，我还是觉得，现在就躺平，认了所谓虚无缥缈的命，我舍不得，不可能，不愿意！\n但是我是一个很难因为认同什么，因为什么共鸣去持续努力的人，我需要那种能够说服我去努力的底层原理。\n最后，我找到了，三句话。\n第一句，”人是自我编制意义之网的生物，人只有在不快乐的时候才会思考意义，也只有在闲下来的时候才会寻找意义。“\n第二句，”我们对时间的感知其实非常主观，我们越习惯于我们的生活方式，生活里面的新鲜感就越少，我们对时间的感知就越快，生命就越短。“\n第三句，”人生应该走向“相对自由”适量选择的自律，而不是“绝对自由”无限选择的混乱。自律是自由的最终形态，在规则内我们才能最大化地感知自由。”\n我写下来这一段话：\n活着，不可能停下来，因为停下来我们就会适应刺激。\n所以我要不停地去新的地方，遇见新的人，去追求追逐下一个目标。\n去扩展新的认知边界，去接受新的知识，接受新的观念。\n永远不要满足，永远都不要自以为是，永远都在路上。\n要活得更长，活着更久，活得更有意义。\n我只能永远活在未知，活在挑战，活在成长里面。\n我终于决定改变，我知道我之前很烂，所以我只能慢慢改。\n我把改变分成了三段。\n开始早睡早起，因为作息是高效的底层保障。\n关闭了朋友圈退出了社交平台，不想太关注于别人，因为别人消耗太多精力和情绪，因为圈子之外的”极端“和”典型“而焦虑。\n换了小屏手机，删掉了所有的社交娱乐 app，逃离高刺激。\n第一幕：一个人的咸鱼程度正比于，从醒来到起床，从上床到睡觉的时间和。\n关于早起。\n用早起的仪式感，给一天的开始赋能，然后去完成最有挑战性的事情，能得到一种极大的满足感和成就感。\n以及，关于”痛苦的早起“基调的奠定，一天的情绪氛围会稍微发生一些改变，也就是会有一种”使命感“，大概就是相信，我是来吃苦的。\n今天已经努力早起了，我今天不能懈怠，要努力冲冲冲！\n以及，悄悄改变的核心，让我相信我可以掌控我的一天，”我比大多数人都起得早“，还来得及，还追得上，抚平了我的很多焦虑。\n关于早睡。\n晚上容易感性，负面情绪会变多。华灯初上，我们跟外界的交流切断，就会转向自我，审视，思虑。而同时，身体的疲惫，一天的学习和工作，导致稳定情绪的血清素浓度降低，就更容易被情绪主导，顾影自怜，苛责自我，后悔苦恼。\n而偏偏，大部分人都会选择延长这一份独独属于自己的时间，包括我。\n白天的时间是属于别人的，晚上的时间是属于我的，晚一点睡觉，因为我想要一点掌控感。\n白天什么都没有做，荒废了一天，晚上多撑一会，因为我想多一点理所当然。\n同时，信息焦虑，对信息高刺激的依赖，睡前大量刷视频看文字，睡觉的时候更难平复心绪，反而带着一种更大的空虚和焦虑以及负罪感。\n我突然发现，这个时代，已经让我对信息刺激，极端敏感，极度依赖。乃至于，我们连睡前片刻的「屏蔽」，短暂地脱离，都做不到。\n对早睡，我定下的原则是，不带手机上床，睡前避免高刺激。\n我知道，规律作息不一定能让我逆袭，但是，堕落，一定是从作息不规律开始的。\n开始早睡早起，让我相信了我可以改变，让我相信了我可以重新掌控生活，让我相信了我还来得及，追得上。\n第二幕：圈子之外的人，其实不用在意，圈子之内的人，也可以不用那么关注。\n圈子之外的人，带给我们大多是焦虑。\n幸福感其实一定程度上是来自于比较的，以前我们的比较标准仅仅来源于我们目力所及之人。\n而现在我们的比较标准，被“人生赢家们”被“分享者们”无限拔高了。\n不知道从什么时候开始，社交平台变成了一个橱窗，里面装点精致。\n透过深深的滤镜，他们生活灿烂，情绪热烈，人设完美。\n其实，我们是清楚这种虚幻的不真实感的，而社交平台，恰恰就是有这样的魔力，让我们沉浸。\n我们明明知道，这些逆袭清北上交，这些年入千万百万，这些生活精彩情感丰富，所谓的人生赢家们。\n是“典型”，是“极端”，是“幸存者”们。\n但是他们出现得太频繁了，但是他们展先的形式太粗暴了，以至于，扭曲了我们认知，我们的大脑悄悄把他们当成了常态，当成了标准。\n我们的预期被不断拔高，我们的平均标准也在提高，我们对取得的成就越来越不满意，我们越来越焦虑。\n我们再回头来看我们的一步一步努力，我们的慢慢进步，甚至可能产生”别人已经那样了，我现在才这样，我是不是废物啊”的极端下个发。\n大部分人其实都是，一边挣扎，一边努力，偶尔迷茫，偶尔鸡血。\n这些东西才是生活的常态。\n有些人的生活，其实我们不用看。\n其实，橱窗里面的很多生活，在一边灿烂，在一边腐烂。\n所以，我关闭了，我不想再看了。\n对待圈子之内的人。\n我想说，我们其实并不用因为别人的评价去怀疑自己。\n意见和评价，只是用来参考的，但是标准在我们自己身上。\n有些人的建议，其实我们不用听。\n有自我意识，并不代表去自私，而是在任何时候任何时间都选择尊重自己的情绪，尊重自己的利益。\n没必要博眼球，也没必要找认同。\n如果太在意别人的看法，因为别人的期待而改变。\n但是，不同的人有不同的期待，不同的人有不同的看法，不同的人对你有不同的要求。\n去不停地改变形状，那，我原来的形状是什么？\n我关掉了朋友圈，它对我的意义并非切断社交。\n而是，我想通过这个仪式感来告诉自己，我应该有自己的形状，我可以不那么在意别人的想法。\n第三幕：高刺激，碎片化的信息，只会让人变蠢。但是我打不过，只能跑。\n我们的基因，是几百万前的基因。\n干不过现在的科技。\napp 的推荐算法，推荐机制，可以说，已经从我们的基因层面，生理层面，认知层面，在全方面降维打击我们。\n沙雕视频，漂亮姐姐，这些是人类原始的生理需求，我知道，一刷就停不下来。\n所以，我为了让自己不方便，换了小屏手机。\n我为了让自己更不方便，我还是删掉了所有 app。\n我太知道我是个怕麻烦的人了，一旦我想着要重新下载，还要重新登录，还要在那个逼仄的屏幕内寻求高刺激。\n我就想，算了，还是好好学习。\n其实设置的路径长一点，大脑也许就能反应过来了。\n因为大脑是有两个认知通路的，一个是感性主导的，一个是理性主导的。\n一般来说，感性主导就是我们的第一反应，也就是脑子一热。\n理性主导会慢很多，也就是事后一想。\n给大脑一点时间，让它反应反应。\n也许，它就能做正确的决定了。\n此时此刻。\n我并没有逆袭，但是，我在一步一步变好。\n我心安理得，我开始变得不那么焦虑，我开始对生活有掌控感。\n没有那么热血，没有那么刺激，也没有那么多鸡血。\n有的只是，尊重现实。\n从生理上认知上思维上，去接受自己，对自己的感性少点责备，对自己的低行动力少点强求，对科技多点警惕，打不过就跑。\n借助于工具，借助于仪式，从认知开始，和习惯协调，知行合一，引导自己慢慢自律。\n未来，慢慢来吧。\n最后。\n我想说，这就是我一个普通人。\n重新掌控生活的三步，没有那么热血，也没有那么刺激，也没有逆袭故事。\n有的，只有，更好地去认知自我，对自己的一些行为一些心理少一点责备。\n然后通过工具，通过习惯，慢慢地对自己我进行改造。\n\n\n转载自：生于焦虑，死于自律\n\n","plink":"https://becase.top/resources/extract/生于焦虑-死于自律/"},{"title":"给青年添个堵","date":"2024-03-11T03:17:20.571Z","date_formatted":{"ll":"Mar 11, 2024","L":"03/11/2024","MM-DD":"03-11"},"updated":"2024-03-11T03:17:20.571Z","content":"你们是被赞美的青年。\n但此刻我不想赞美你们。\n你们可以以极低的成本，随时随地用各种方式\n看到、听到、触碰到全人类几千年间孕育出的\n最好的、最壮丽的、最伟大的、最丰富的产物。但你们并不在乎\n你们怀疑一切\n你们说 A 无非是 19 世纪资产阶级的无病呻吟\nB 不过是浪漫主义对传统艺术的不成熟的挑战\nC 受到当时社会中流行的某某观念的局限。\n你们解构一切\n你们一个字一个词地解读小说\n你们一帧一秒地去拆分电影\n你们关注时代背景，作者的故事，风格流派\n你们吸收无数的二手的、三手的、五六手的\n二流解读和戏说。\n但我想问你\n它们究竟让你感受到了什么？\n你有哪些纯粹个人的、具体的、细致的触动？\n你们茫然四顾\n你无从回答。\n你们出生在一个鼓励表达\n奖励个性的时代\n你们拥有无数种笔，无数种话筒\n你们有极强的表现欲和表达欲\n你们急切的让世界听到自己的声音。\n你们是舆论场上的异见者\n激烈的反对庸俗，反抗丑恶\n于是你们留言、评论、私信、转发。\n四处留下话语，\n但它们是什么？\n你们说这不正确，这有问题\n这是一句不该说的话，这不符合身份\n另一个同样的你站出来，说你政治正确，\n你是圣母婊，而这显然又是另一种不正确。\n你们的心被挤压到还不到手机上的 SOC 大\n你们甚至要去管谁谁谁在喝酒抽烟\n你们甚至要去管那些 20 岁出头荷尔蒙满满溢出\n明明和你们一样大的偶像谈不谈恋爱。\n你们到处出击挖坟清算\n用放大镜去寻找别人的漏洞和弱点\n要求一个又一个人道歉。\n逼迫他们说出了占用公共空间。\n但公共空间没有被占用\n让给你们的时候\n你又能往里面放些什么呢？\n你们一腔愤怒无处发泄，\n你们执着于痴迷于宏大的结构，\n但对具体的个人视若无睹。\n你们把一个又ー一个几乎与你们没有差别的个体贴上标签，\n甚至把世界上 50%的另一种性別异化成怪物，\n然后你们重拳出击。\n你们一争论起来就扣帽子\n降低自己人设\n千方百计让对方难堪。\n在这之外\n你们还有没有能力进行正常的\n有基本同理心的、平静的、有价值的交流？\n你们在每一个热点事件出现的时候\n迫不及待的去搜索答案\n你们看不计其数的各种各样的回答\n吸纳了无数的理论和概念\n你们头脑中环绕着 500 个现成的框架\n它们可以依附在每一个新的问题上面。\n但除此之外\n你们是不是在洗澡时，吃饭时，人眠前，谈话中\n还能够诞生出原原本本的源自于你本人的见解？\n哪怕它们简单而朴素？\n你们有着极佳的网感\n你们熟悉每一个梗\n你们嘲笑中年人和下沉群体的老套与过时。\n但去除那些梗\n那些表情包\n那些抽象话\n和粗暴的定义之外\n你们又是怎样一群无聊、空洞、狭隘的人？\n此时此刻你们在弹幕上刷别骂了\n好像这是一句幽默的玩笑话\n那么，没有了这些东西\n你们是否还有能力说出一段言之有物的\n完整的、有趣的话？\n你们知道很多\n你们空无一物。\n这是一个前所未有的物质极大丰富\n价值观和选择多元化的世界\n生活摆在你们面前有无数条路。\n然而，泥泞的路，光滑的路，粗粝的路\n闪光的路，墨绿色的路，散发着海腥味道的路\n在你们看来都是同一种路\n你们不关心别的\n你们只关心它们能延展到多远多高的地方。\n你们看似丰富，多彩，狂野\n但那些只是 RGB 调色盘上 1678 万中选项中的一个\n只有你们知道自己的怂，\n自己的软弱和胆怯。\n你们患得患失\n把一切东西都按照一般等价物去换算\n连出门吃顿饭都要在 AP 上对比 15 家饭馆生怕选错\n你们有微信，有陌陌探探\n但却只敢在愚人节伪装成恶作剧怯懦地发出表白。\n你们被一切的一切的一切的一切東住双脚\n你们裹足不前\n你们蹦迪买潮牌听黑怕，好像对一切都满不在乎\n但你们从学生时代起就战战兢兢\n把求最优解已经内化成了一种生理习惯。\n你们身份证上写的是 20 岁\n说着 10 岁的话\n打着 40 岁的算盘\n像 60 岁一样的行动。\n你们，真的能叫\n青年？\n今天，所有人都在赞颂青年\n但我要说，青年没什么了不起\n青年并不一定优秀，并不一定深刻\n并不一定勇敢，并不一定有创造力\n青年唯一的优势，不过是时间站在你们这边。\n正因为时间尚早，太阳正当空\n你们没有过往的束缚\n你们能够以一双崭新的眼看到无数种可能性\n你们可以说出新的话\n你们有不加掩饰的欲念和期望\n你们想看到更多东西\n做心心念念的事情，让自己变得不一样。\n所以你们才更优秀\n更深刻\n更勇敢\n更有创造力。\n我是 80 年生人，但我是一名青年。\n你呢？\n你是什么样的青年\n\n\n转载自：给青年添个堵\n\n","plink":"https://becase.top/resources/extract/给青年添个堵/"},{"title":"计算 · 序 —— 吴翰清","date":"2024-03-25T06:59:33.681Z","date_formatted":{"ll":"Mar 25, 2024","L":"03/25/2024","MM-DD":"03-25"},"updated":"2024-03-25T06:59:33.681Z","content":"\n在新人培训后讲师赠予的书籍；吴翰清的名字很早就听过，书的序章看了第一段就觉得不一般，然后 google 了下书的背景，即是下文\n\n我干了件从来没有人干过的事情。\n三年前在新冠疫情大爆发期间，当我决心动笔写下第一行文字时，从来没想到过写作《计算》的工程会如此之大。\n它横跨了人类文明三千年的数学史和计算机科学史，从数字的起源一直讲到了今天的 ChatGPT。\n写到一半时我突然发现，市面上能找到的书，如果不是枯燥的工具书和理论书，就是讲数学史的，一般从古希腊讲到了 20 世纪初的现代数学，要么就是讲计算机历史的，往往从图灵开始讲到今天的互联网和人工智能。\n但是几乎找不到一本书涵盖了两个领域，跨越了完整的时间线，用讲人话的方式深入浅出地从数学的本源开始一直讲到今天最前沿的计算机技术。\n而《计算》做到了。\n也因此，《计算》有了一个史诗般气势恢弘的开头：\n“1936 年 5 月 28 日，在阿兰 · 麦席森 · 图灵决定发表论文《论可计算数及其在判定性问题中的应用》的那个下午，他正焦虑于普林斯顿的丘奇已抢先发表了对这个著名希尔伯特问题的证明。此刻距离毕达哥拉斯学派的希帕索斯被投入大海已过去 2500 多年，而 AlphaGo 还要等到 80 年后才能击败李世石，真正把人类的傲慢踩在脚下。”\n爱好文学的读者们应该有一种熟悉的感觉，没错，这里模仿了加西亚 · 马尔克斯的《百年孤独》的开头，在一段话中，嵌入了过去、现在、未来三个时间片段，蕴含了极其丰富的信息。\n自然，《计算》的结尾也是不平凡的，留待读者们自己探索。\n这本书不仅仅是写给理工科生或者程序员看的，也是写给所有人看的。原因在于我认为 “计算技术” 是人类文明三千年来的智慧结晶，它深刻地影响着我们这个时代，与每个人的生活息息相关，因此对计算这一概念的正确解释、澄清和发展就成为一种必要。\n在我写作到一半时，我再次发现，这件事情依然没有人好好做过。所以就由《计算》来做吧。\n于是就有了封底的三句话：\n\n这就是我写作《计算》的初心。\n相应地，为了保持版面和内容整洁，我没有请任何人写推荐语、写序言。\n因为我清楚读者们在市面上看到的大多数书，在封底为其写推荐语的人多半自己都没有读过该书。\n我认为这对读者是不负责任的，因此我不希望《计算》遭此狗皮膏药的厄运。\n难得的是，我的编辑，博文视点的张春雨先生也愿意陪着我胡闹一把，冒着损失销量的风险，没有在书的封面和封底贴任何的狗皮膏药。\n同理，我也没有请人写序，因此本文就权当代序吧。\n如果本书再版时需要有人写推荐语，我认为也应当留给真正读完了此书的普通读者们，而不是找一些有帽子的专家。世人服从权威多过服从真理，我辈读书人当拨乱反正之。\n至于任性到连内容简介都没有附在封底，则纯属我的骄傲了。因此如果当你在书店里拿起此书，却丈二和尚摸不着头脑时，你一定就已经深深地感受到作者我的骄傲了吧！\n《计算》洋洋洒洒四百多页，却只是我想表达的三分之一。我决定通过回答三个问题，来阐述我的计算主义世界观：\n\n\n计算的原理是什么？\n\n\n计算的技术该如何实现？\n\n\n计算会对世界产生什么影响？\n\n\n《计算》写完，只回答了第一个问题。\n因此本书也可以看作是《计算》三部曲的奠基之作。\n有生之年，我会回答清楚这三个问题。\n但反过来说，我狡猾的地方在于，若有任何人想在计算的问题上与我进行辩论，则请先通读这四百页的著作，我们才有辩论的必要，否则这个人要么是傲慢的，要么是无知的。\n我的思想都已经公开摆在这里了，不藏私，请君自取！\n在写作《计算》的过程中，我买遍了几乎我能找到的所有计算机书，其中不乏国内外顶尖专家、学者的作品。\n一方面我从中受益良多，另一方面，居然让我看清楚了这些大神们的思想脉络和水位。\n就像我在攀登一座山峰，我清晰地看到他们都处于山峰上的什么位置，不再遥不可及，他们有的高，有的低，有的也不过如此。这是一种很神奇的感受。写完《计算》后，我认为，《计算》这座山峰应该也足够后人们攀登好一阵子了。\n至少写完《计算》后，我终于明白了什么是数学，计算机将发展去何方。\n说来惭愧，学了这么多年数学，到年近不惑才入了数学的大门。要是能穿越回去，让还在读中学的我读读《计算》，可能我会少走二十年的弯路。\n但普通读者们大可不必对本书望而生畏，虽然本书中有不少数学思想，但几乎没有公式和枯燥的证明过程，所引入的有限公式，也只是因为我觉得它们特别地 “美”。\n正如前所说，这是一本写给每个人看的书。\n本书的正确打开方式为随时随地，随手翻开一页，沉浸享受。\n当然，本书也值得你通读十遍，相信每一遍会有不同的收获。作为读者的我，在阅读身为作者的我写出来的《计算》时，也同样如是。\n而我自己最大的收获，则在于过往模糊的概念变得清晰，过往未知的问题有了答案，即对计算边界的终极探索。\n从数学、物理学、计算机科学和哲学出发，在写作到第三年时，我终于找到了自己的答案，这种求知欲的满足让我欣喜若狂，忍不住分享出来。\n我本人也因此成为了一个彻彻底底的计算主义者，进而以计算的世界观解释万事万物，洞若观火。\n说起对计算的启蒙，我要感谢阿里云的创始人王坚博士，是他每天把计算挂在嘴边，以及工作中对我的不断鞭策，让我理解了什么是计算，什么是计算机，最终才有今天我把计算变成了自己的信仰。\n如果没有我在阿里云的工作经历，《计算》一书是无法写作出来的，而我独特的工程师视角则为我解读 “计算” 提供了诸多帮助，这应当也是本书特殊的地方。\n《计算》写作于阿里云，待到《计算》出版之际，却已不在阿里云，《计算》与阿里云从此只有渊源，再无瓜葛，想来这是阿里云的遗憾了。\n计算，为了可计算的价值！\n","plink":"https://becase.top/resources/extract/计算-序/"},{"title":"语文高考作文可以写负能量作文吗","date":"2021-07-06T16:00:00.000Z","date_formatted":{"ll":"Jul 7, 2021","L":"07/07/2021","MM-DD":"07-07"},"updated":"2024-03-11T03:17:20.574Z","content":"\n算是给过去愤青的自己一个解释\n\n我真的是服你们这群崽子。\n一个个的都是契科夫转世、莫泊桑临凡、欧亨利还魂，茨威格夺舍……\n你们三天没洗的油头上散发的是莎士比亚时代遗留的思想圣光，一月未换的袜子里氤氲着文艺复兴时期的蓬勃蒸汽，龙飞凤舞的狗爬字体饱含着千年中华的伟大传承。\n你们就是鲁迅后院子里的那两棵树，一棵是朴树，另一棵是村上春树，你们的根系绵延不绝，从白鹿原一直聊骚到挪威的森林，阿来匍匐在你们脚下，贾平凹仰望着你们的膝盖，刘慈欣率领的整个三体舰队，都被你们炫彩夺丽的文采所折服，把你们的大作顶在脑壳上一路跪着爬回去的。\n我看你们就差脑壳上刷上几个金光闪闪的烫金大字——爷怀才不遇！\n就一句话，只要你文笔好，三观正，不给法西斯洗地，不给罪犯挡枪，不为封建糟粕招魂，你们爱写什么写什么，想写什么写什么…… 这些都不是问题。\n你要真的才比李太白，文盖托尔斯泰，你的老师也不会是那嫉贤妒能的张士贵，不会针对你这个人民代表大会上的应梦贤臣。\n唯一的问题是:\n锁了房门丢钥匙——您配吗？\n我就想知道，您十八年的人生究竟度过的多么灰暗？才让您的脑子里充满了这宛如七月十五红衣上吊冤死鬼般的怨气，非要在一个人生比重前几名的考试里玩一把个性，赌一把人生？你是昭和日本在中国的遗孤吗？动不动就要皇国兴废，在此一举？\n区区八百字的篇幅，您是打算用什么样的方式组织一个莫名其妙的负能量宣泄？喊麦吗？惊雷，这通天彻底紫金锤？\n你失过业？下过岗？去过夹边沟农场？\n你扛过枪？打过仗？家里上了一炷香？\n你炼过钢？交过粮？吃过红薯拌高粱？\n你贷过款？买过房？女友身边躺老王？\n你有个卵子的负能量？\n校花没喝你拿早餐钱买的奶茶，你就抑郁了？王者连掉十几个段位，你就顿悟了？你哥们放学拉稀没跟你一起走，你就觉得被背叛了？你爹妈随口叮嘱你一句，你就被全世界针对了？\n醒醒吧，你见过什么负能量？奈何桥上你不喝汤孟婆还得掉业绩呢，满月时候嘴里啃坨屎你还乐的像喝了奶一样呢，穿着个开裆裤满床尿尿的时候也没见你单手托腮 cos 个沉思者啊？\n高考作文的难度一降再降，从话题作文到材料作文再到近些年就差给你出个写作攻略的任务驱动型作文，考察的不过是你好好说话的本事。\n可你就是不想好好说话！\n国家贴着钱给你九年义务教育，补着款迎接你去高等学府，就想在作文里听你夸两句怎么了？过分吗？让你赞美个无私奉献夸耀个科技发达听一句积极向上要你的命吗？你就非给人找不痛快？你就非要大年三十送棺材，满月酒上做花圈？\n平常懒得写随笔，模考字数凑不够，名著没翻过几本，拿起手机就忘了娘，掂起笔就石乐志，结果一到考场上你诗情画意全都来了，恨不得洋洋洒洒疾书去，一步三叹不回头？\n你要真的是忧国忧民，文采斐然，就是能在八百字左右的篇幅里控诉出这黑暗的世界、不公的现实，让人读了悲从心起潸然泪下，老师看了齐声喝彩拍案叫绝，整个文学界为之震动…… 那你就不会再乎分数了，你都堪破红尘世俗，洞悉人心宇宙了，还纠结老师给不给你分干嘛？俗气！你追求的应该是 “他年我若为青帝，报与桃花一处开” 的豪迈或者 “残躯徒留红尘里，此身不在五行中” 的洒脱，不是吗？\n\n\n转载自：语文高考作文可以写负能量作文吗\n\n","plink":"https://becase.top/resources/extract/语文高考作文可以写负能量作文吗/"},{"title":"他的2023","date":"2024-01-09T16:00:00.000Z","date_formatted":{"ll":"Jan 10, 2024","L":"01/10/2024","MM-DD":"01-10"},"updated":"2024-03-11T03:17:20.563Z","content":"\n看了很多篇年度总结，最喜欢这篇 —— 真实直接的思想、不加设计的文字\n这样的2023 ，也是我理想的未来\n\n先用坚决的语气说对世界并不好奇，只想宅家只想带娃；正在创业的前老板提了点值得做的事，我寻思好好花时间研究，不能只做消费者。转头，人已经背着包上路。算下来，跑了西北、北欧、几乎整个南方以及中东，加起来 50+ 个城市；读完 62 本书。\n我对生活要求很低，好好活着好好爱人便是好。所以这么一年下来，财富没有增长，事业也没有，却似乎也安心。\n“你的人生目标不是最大化财富，而是最大化人生体验… 相比于浪费人生，人们更加担心钱被花光；你的思维必须倒过来，你最大的恐惧应该是时间与人生被浪费，而不是 ‘到了80岁我还能有多少多少钱’ 这个问题。”（《最优解人生》），我支持这种脑回路，并这么走。\n从背上双肩包去重庆，这一路下来，起起伏伏。\n要收集体验，只要去没去过的地方，做没做过的事，读点不懂的领域甚至不喜欢的书，便可。但体验最大化的度在哪？这个问题随在西安碰面的朋友而来，但我没有答案。苦恼了几天，收起问题，把心重新放在山山水水。直到有天我看儿子在玩停车场的围栏，我怕他因为来车而受伤便问他，“世界上有很多好玩的事，什么是可以玩的，什么不能玩？”，他沉默。如果现在问他，他会说，“不会伤害到别人的可以玩”。这大概就是答案。\n离开西安去了敦煌，主要原因是 —— 天气好。这也几乎成了我今年旅行目的地选择的固定方案 —— 追着阳光走，哪天气好就去哪。\n鸣沙山是一个好地方，我几乎天天跑去看夕阳。有天我去边上的沙漠骑骆驼，五人一队，中途有个滑沙项目，需要多数人想去才会停下，导游问了我前面的四位都说不去。在确认大家不赶时间后，我问假设我请客是不是可以同去，结果我们都获得一次刺激的滑沙体验。我把这种解决问题的方法看成一种隐喻。盯住目标，选择就不会含糊。后来在十月中旬，我把广东的车子送到上海给儿子。邻居说我太宠儿子，大老远，上海又不是没车开。这样的事，实际上无关值得与否，只关乎我唯一的目标 —— 让儿子从事实上得到一辆体验更好的车。\n在敦煌那段时间，我刚好翻完罗素的《论婚姻与道德》，实际上整本书讲的是性道德。他认为 “我想宣扬的理论并不是允许大家去放纵，我的理论中包含了几乎与传统学说同样多的自控。但自控更多的是用在不干预他人的自由上，而不是限制自身的自由”；认为性、爱情和婚姻应该分开来看。在一家足浴店，我在此话题上被上了一课 —— 技师从问我是不是学者问到我正在读的书，最后给我讲了她的故事：离婚带一个女儿，不想轻易再婚，偶尔换男友，在没男友时有固定性伴侣。这不正是罗素所教的？后来我问她几岁，88 年的，还好多年前我意识到自己老大不小后一直保持一个习惯 —— 不轻易叫人阿姨。现在回想《李银河谈爱情》这本书的内容，兴许在性、爱情、婚姻上我们离欧洲并不远。\n甘肃跑了四个城市，都是河西走廊重镇，在兰州黄河边喝着三泡台结束了行程。\n从甘肃回来，便带着儿子踏上了北欧。在夏天的山里玩雪，在中国没有的峡湾地貌游荡，最有趣的当数陪他完成了他人生中第一次途步 —— 5岁，挪威，布道石途步路线，8KM+。想带儿子去欧洲是几年前的一个目标。一个目标突然完成，心里空空。我花了很多时间向书求解，每日与朋友在咖啡店聊天，运动。无果，因为在目标出现之前，所有方法都派不上用场。\n八月中开启了第二次暑假旅行，带着儿子从桂林出发，沿广西、湖南、江西自驾回上海。天伦之乐。期间我发现，孩子们对于世界的理解更接近本质 —— 有玩得来的伙伴，有好玩的事。成人似乎总希望抓住虚无的意义，比如历史名胜、人文景观，好像一旦抓住某种意义，生命便能无悔。假设每天提早一小时去学校门口等孩子放学的体感是幸福的，还需要什么重大意义？\n儿子上学后，我又独自出发，边读书边旅行。\n一路沿着长江跑了安徽，江西，湖南，湖北，贵州，广西，最后在十月份回到深圳。\n我似乎开始享受阅读的乐趣，读了不少好书，在美景和书的世界来回切换。比如《蚱蜢：游戏、生命和乌托邦》 、《不能承受的生命之轻》 、《荒原狼 》。人生是游戏，幸福是重复，而人是多重自我的集合。我们从人、书、想象里学习而拥有不同、独立的自我，拼成了一个我。一个人拥有的自我越多，看到的世界便越丰富。\n后来又从广东自驾，沿海一路向北，到达上海；去了阿联酋过了个 “夏天”；年末在深圳、中山、珠海、顺德跑了一圈；在惠州跨了年。\n这一年下来，大部分时间都是独自旅行，中间有几次有朋友同行，我开始发觉本来习惯的事反而变得不习惯。独自一个人时，想行动时几乎人已在路上。自由的正反面各有代价，有同伴不一定走得远，有时候同伴让人不想出门。\n最让我感到幸福的事是和儿子相处的时光。年初和儿子在公园看星空，他说，“爸爸，满天繁星”，那种感觉，突然把我从忧心他 “何时才长大” 拉到了 “原来他已经这么大了”。他在成长，比想象中快。\n最让我意外的事是在旅行路上被人认出来。\n值得提一嘴的是，今年有个特别明显的变化 —— 那些不情愿的时刻，似乎总能照亮心里最在意的点。这种变化不知道是随时间而来，还是随见识而来，确定的是生命中最重要的点变得越来越明显。\n有天在酒吧聊天，我说自己似乎越来越冷漠。后来我意识到，有些话不能乱说，说多了连自己都相信。如果认真且客观地审视自己，便会发现事实是在生活的不确定性中，我态度更从容了。像《十分钟冥想》里提到的，与其说冥想总能带来快乐，不如说经过冥想训练，在不开心事情的发生时，可以更从容应对。当我们遇到困难，不是本能地回击，而是思考如何理性应对。这种停下来思考的时刻越来越多，我们便可以说自己越来越从容。人要审视世界，也要审视内心。\n回过头来看，似乎一切都在变好。就像在普陀山喝的那杯咖啡上写的 —— Never better。\n…\n接下来怎么走？\n…\n附，推荐几本书：\n《刀锋》、《额尔古纳河右岸》、《最优解人生》、《论婚姻与道德》、《杀死一只知更鸟》、《不能承受的生命之轻》、《荒原狼 》、《埃隆·马斯克传》、《夜晚的潜水艇》、《昨日的世界》、《影响力》、《我们为什么要睡觉》\n\n\n作者 twitter：Sofish\n\n","plink":"https://becase.top/resources/extract/他的2023-我的理想/"},{"title":"20240104","date":"2023-01-04T13:53:04.000Z","date_formatted":{"ll":"Jan 4, 2023","L":"01/04/2023","MM-DD":"01-04"},"updated":"2024-03-11T03:17:20.548Z","content":"\n📺 在看《繁花》\n元旦在家睡大觉 🛏️\n给家里老爹送生日礼物 🎁\n\n","plink":"https://becase.top/now/past/2024-01-04/"},{"title":"20240109","date":"2023-01-09T13:53:04.000Z","date_formatted":{"ll":"Jan 9, 2023","L":"01/09/2023","MM-DD":"01-09"},"updated":"2024-03-11T03:17:20.549Z","content":"\n家里小猫肠胃炎 😿 ，治疗中 :(\n对技术丧失信心 😔\n心里有了小太阳 🔆 :)\n\n","plink":"https://becase.top/now/past/2024-01-09/"},{"title":"","date":"2024-03-11T03:17:20.550Z","date_formatted":{"ll":"Mar 11, 2024","L":"03/11/2024","MM-DD":"03-11"},"updated":"2024-03-11T03:17:20.550Z","content":"\n学会了折纸，还有建德红草莓 🍓\n“阳光明媚吗？洁桑” —— 明媚！ 🌡️\n看了电影 🎬  - 年会不能停, rap和民谣很好听\n大晚上看了爱乐之城 🎼 , 好有感觉的一对\n吃了日式自助餐 🍽️ (月龙吟)，格局打开\n《关于我为了抢票 🚅，下载三个app这件事》\n\n","plink":"https://becase.top/now/past/2024-01-25/"},{"title":"","date":"2024-03-23T15:38:16.826Z","date_formatted":{"ll":"Mar 23, 2024","L":"03/23/2024","MM-DD":"03-23"},"updated":"2024-03-23T15:38:16.826Z","content":"\n\nsay good-bye\n慢慢适应，做出改变\n\n…\n\n还在收拾房子，接着拆快递\n在家锻炼身体，拉力绳卡门事件\n准备报考软考高级\n加班做项目\n\n","plink":"https://becase.top/now/past/2024-03-05/"},{"title":"书籍清单","date":"2023-04-28T16:00:00.000Z","date_formatted":{"ll":"Apr 29, 2023","L":"04/29/2023","MM-DD":"04-29"},"updated":"2024-03-27T03:34:43.446Z","content":"初中时从电子书开始，高中因为学校管制原因多为意林、读者等文刊，偶尔私下买借几本来看\n每当回想起晚自习拿着小说放在课桌上充当学习资料看的时候，心里还是不免咯噔一下，仿佛班主任的死亡凝视微笑就在背后:)\n2024\n\n星期六晚我们去散步吧\n小狗钱钱\n小岛经济学\n鲸鱼安慰了大海\n日本蜡烛经济学\n\n2023\n\n我在北京送快递\n动物凶猛\n1984\n计算\n深入浅出 Node.js\n\n过去\n主体\n\n追风筝的人\n摆渡人\n小王子\n天才在左，疯子在右\n笑场@李诞\n你当像鸟飞往你的山\n人生的智慧@叔本华\n白说@白岩松\n他和她的猫@新海诚\n三体全集\n雪国\n福尔摩斯\n成佛之后，成仁之前\n社会性动物\n\n技术类\n从大学的图书馆伊始\n\nC primer plus.6\n深入理解计算机系统\nJava 核心技术.上\nJavaScript 高级程序设计.4（红宝书\n代码随想录\nCSS 世界\n\n韩寒\n\n1988：我想和这个世界谈谈\n三重门\n青春\n通稿 2003\n\n江南\n\n龙族.全集\n天之炽\n龙与少年游\n此间的少年\n\n卢思浩\n\n时间的答案\n离开前请叫醒我\n你也走了很远的路吧\n\n龙应台\n\n亲爱的安德烈\n目送\n解忧杂货店\n\n东野圭吾\n\n幻夜\n麒麟之翼\n解忧杂货店\n白夜行\n嫌疑人 x 的献身\n\n刘慈欣\n\n三体.全集\n超新星纪元\n2018\n流浪地球\n\n省去那些中二玄幻小说\n","plink":"https://becase.top/resources/list/书籍清单/"},{"title":"","date":"2024-03-11T03:17:20.551Z","date_formatted":{"ll":"Mar 11, 2024","L":"03/11/2024","MM-DD":"03-11"},"updated":"2024-03-11T03:17:20.551Z","content":"\nta 回家装修房子\n为期两周的找房经历\n\n是一开始听到同事找房的事情，意识到自己也要开始找新租房\n先是小红书，然后中介\n\n\n过年回家\n\n回家路上的一波三折\n又是理念上的 battle\n实现假期 KPI 目标：麻将\n\n\n回杭州前去长沙见朋友\n\n吃了海底捞\n\n\n确定新租房，搬家\n\n买家具设备，增加生活气息\n\n\n周末跟同事们搓了麻将(东北麻将)\n考研成绩又出了\n\n\n租房\n理想户型：独卫独厨+朝南阳台，民用水电\n一开始在小红书辗转了三四天，也去线下看了各种房型，发现都是缺斤少两的，或者严重偏贵\n然后寻求中介帮助，有接触两个中介，都还不错，业务挺熟练的\n期间遇到了一些人情世故的新坑\n\n制造房子即将出租的紧张感\n\n常见的就是房东说“我有个朋友或者熟人要租” or “不能延期租的，这个损失可不小”\n\n\n中介的利润，是在签完合同后房租给的，一般是半个月房租\n养猫这件事可以睁一只眼闭一只眼，没必要较真\n跟人合租一定要提前商定好未来发生的种种利益关系，人和人性格如果不合或者计较的事情不一致很容易闹掰（所以还是一个人住香\n\n最后搬到的新房，还是自己的小区，主要从性价比和地段考量（拆迁房价格比商品房实惠，然后小区附近有商业区，小区里面也安静）\n有了大衣柜，买了电脑椅和摇摇椅，买了照片墙，装了宽带，买了冰箱，一套操作也花费大几千了\n都是为了舒服的空间 :)\n过年\n回家路上\n回家是从当天晚上十一点到高铁站，然后凌晨两点转车，凌晨五点到长沙，然后次日中午坐火车，这是一开始的计划\n家里人嫌次日早上到中午时间间隔太长，然后帮我约了顺风车，坐车的这一路可就太难受了\n\n车上全是人 + 堵车 + 旁边人一直在叨叨叨 + 车里有气味 + 自己没吃早餐\n\n直接 buff 叠满了，回到家里随便吃点就倒头睡觉了，实在不想再回想\n唯一好的是路上拍到了冬天的痕迹\n\n麻将\n一开始再除夕前两天线上学了杭州麻将基本规则，然后回家后次日就去实战了，是新类型的麻将（红中 🀄️ 麻将）\n前三把胡两把，果然是新手保护期 :P\n上半段赢，下半段输，综合来看持平\n然后跟对象在线上玩血流麻将，那个类型是真厉害，哐哐哐的胡\nbattle\n希望家里人别把我抓的太紧，细致入微的关照，对我来说压力很大\n气到头了来了一句”如果这样，明年就不回来过年“\n害，自己的任性在他们面前是真压不住呀，还是没长大的样子\n\n","plink":"https://becase.top/now/past/2024-02-26/"},{"title":"影视清单","date":"2022-11-28T16:00:00.000Z","date_formatted":{"ll":"Nov 29, 2022","L":"11/29/2022","MM-DD":"11-29"},"updated":"2024-03-17T11:37:57.318Z","content":"一时无聊，一时好奇，一时想观看不同的人生，一时着急知道结局，总体来说就是闲的\n2024\nTV\n\n繁花\nnormal people\nmodern love(摩登情爱)\n\nMovies\n\n年会不能停\n爱乐之城\n热辣滚烫\n遗愿清单\n死亡诗社\n本杰明巴顿奇事\n\n2023\nTV\n\n绝命毒师\n纸牌屋\n\nMovies\n\n深海\n铃芽之旅\n满江红（x\n剑雨\n布达佩斯大饭店\n奥本海默\n英雄\n师父\n狗神\n\nAnimation\n\n画江湖之不良人 6\n灵能百分百\n\n2023 的过去\n只记录一些印象深刻的，顺序没有先后意义，有些遗忘的后续会补上\n123456格式说明- 无@：表示电影 - movie- @：剧表示动漫 - animation- @@：表示电视 - TV- @@@：表示纪录片 - documentary films- 后缀x：表示不推荐\n\n肖申克的救赎\n坏蛋必须死\n这个杀手不太冷\n@紫罗兰的永恒花园\n@钢之炼金术师\n小丑\n楚门的世界\n三傻大闹宝莱坞\n怦然心动\n放牛班的春天\n楚门的世界\n泰坦尼克号\n海上钢琴师\n喜剧之王\n@@琅琊榜\n@星际牛仔\n@@@浮生一日\n@浪客剑心_追忆篇\n南方车站的聚会\n树先生\n与神同行.1.2\n你好，之华\n情书\n@@庆余年\n@画江湖之不良人 4\n@@请回答 1988\n@@老友记\n@@是，首相\n@@神探夏洛克\n美丽人生\n星际穿越\n盗梦空间\n忠犬八公的故事\n教父.1.2\n我不是药神\n让子弹飞\n了不起的盖茨比\n猫鼠游戏\n闻香识女人\n绿皮书\n黑客帝国.全集\n寄生虫\n@进击的巨人\n@夏目友人账\n白日梦想家\n@东京喰种\n\n宫崎骏和新海诚\n\n你的名字\n言叶之庭\n天气之子\n烟花\n千与千寻\n红猪\n哈尔的移动城堡\n声之形\n\n","plink":"https://becase.top/resources/list/影视清单/"},{"title":"20231217","date":"2023-12-17T13:53:04.000Z","date_formatted":{"ll":"Dec 17, 2023","L":"12/17/2023","MM-DD":"12-17"},"updated":"2024-03-11T03:17:20.547Z","content":"\n认识了 ctt\n玩密室（场馆 NPC 忙不过来就没来我这场，抽象嘞\n看电影 🎬 - 狗神（画面感好强，情绪渲染也拉满\n吃饭 - 烤鱼真香\n又入坑了羽毛球🏸（PanGe带的 :D\n又经历了一波裁员(被暴击\n\n","plink":"https://becase.top/now/past/2023-12-17/"},{"title":"卖弱现象","date":"2024-03-25T06:49:57.491Z","date_formatted":{"ll":"Mar 25, 2024","L":"03/25/2024","MM-DD":"03-25"},"updated":"2024-03-25T06:49:57.491Z","content":"\n如何看待每逢预测结果（考试成绩）时，总有些人卖弱（说自己考砸了）的现象？\n\n有两种：\n\n一种是迷惑行为\n一种是防止被卷\n\n迷惑行为\n差了可以给自己台阶下，高了又可以说自己运气好，反正对他们自己没有任何坏处，毕竟谁也不会在自己没有把握的时候说出必考高分的口号\n用外表的谦虚和懒惰来伪装和保护自己，也可以让你们有所懈怠，何乐而不为~\n但大多时候都是在暗地里较劲…\n防止被卷\n内卷社会学公理：\n\n不被别的大佬卷，是大佬的第一需要\n大佬们都不断地学习和进步，但呆在园子里的总时长保持不变\n\n于是就有了猜疑链：\n\n一个大佬无法判断另一个大佬对自己是学习互助还是学习竞争关系.\n一个大佬无法判断另一个大佬判断自己对另一个大佬是学习互助还是学习竞争关系\n\n以此类推…\n所以，一个大佬无法判断另一个大佬是喜欢卷还是不喜欢卷。一个大佬也无法判断另一个大佬是否准备卷自己\n进而圈里就有了大佬积极通宵，一天一学期的盛景，也就是技术爆炸：\n大佬学习进步的速度和加速度不一定是一致的，在某个课程领先的大佬，很可能会在短时间内另一个大佬超越，进而被卷…\n1234567891011// 所以就有了内卷社会学的图景内卷社会就是一座黑暗森林，每个大佬都是带枪的猎人;像幽灵般潜行于林间，轻轻拨开挡路的树枝，竭力不让脚步发出一点儿声音，连呼吸都必须小心翼翼......大佬必须小心，因为森林中到处都有与他一样潜行的猎人如果他发现了别的大佬，不管是不是猎人，不管是天使还是魔鬼，不管是刚入学的新生还是即将要毕业的学长，能做的只有一件事：卷？在这片森林中，其他大佬就是地狱，就是永恒的威胁;任何暴露自己大佬身份的人都将很快被卷，这就是大佬所面临的困境...\n所以，每一个大佬都需要一个安全声明，这就是对大佬悖论的解释\n╮(╯_╰)╭\n","plink":"https://becase.top/resources/essays/卖弱现象/"},{"title":"学校-学生-学习","date":"2023-03-17T13:53:04.000Z","date_formatted":{"ll":"Mar 17, 2023","L":"03/17/2023","MM-DD":"03-17"},"updated":"2024-03-11T03:17:20.554Z","content":"\n谁又画的出正常和疯狂的分界线，若不是跨过了这条线，又有谁分的清\n\n大学怎么过\n对于刚步入大学的苦逼中学生，都是想要好好过一个有意义且潇洒的大学四年\n想想自己的大学生活，都是尽可能的 潇洒先行，奋斗在后，总是自嘲“玩累了再学”，如果自己心里时刻知道事情的尺度如何，过过这种日子倒也不错\n这里就说下自己心目中的大学四年节奏：\n\n大一多参与社团或者学生会等组织，多认识些人，融入的程度看自己想法（及时止损\n大二多参与竞赛和实验室等活动，开始思考和规划未来，树立目标\n大三朝着明确的目标（考研、就业、考编制等等）开始努力，巴拉巴拉\n大四就结果而言，是否重头再来或者换条赛道，有机会来一次毕业旅行当然更好\n\n就我所学的计算机专业而言，学校的大多课程是枯燥且无意义的，重要的只有那些基础课，掌控好时间和精力上的分配还是很重要的（我一直都是教室倒数三排的常客(:\n技术方向的选型\n作为应用开发人员，大多一开始的技术选型目标都是：\n\n硬件 or 软件\n前端 or 后端\nVue or React &amp;&amp; Java or GoLang\n\n很多人总是把自己拘泥在那一亩三分地中，还没等别人询问便给自己贴上标签 “前端什么垃圾，我选后端”（笑\n大家都是（切图仔 - 前端，crud 工具人 - 后端，sql boy - 运维，调参侠 - 算法）中的一员，技术只有深浅和机遇之分，何来贵贱之别\n首先要明白，我是一个程序开发人员，其次是某某方向的开发。虽然工作可能只会涉及某个方面，但对整体的技术框架都要有所了解。既然如此，每个方向都先浅尝一下也是不错的（就阅读个官方文档和 wiki 的功夫，花不了几天时间\n当建立好宏观上的理论体系后，再决定就某一门进行深入，那就是未来 吃饭 的家伙了\n工具和方法论的重要性\n还是那个程序员的角色，有些人喜欢折腾一些 hacker 一样的工具或者插件，作用要么是用着舒服，要么是效率切实的提高了\n而另外一些人则不理会乃至于不屑去使用这些 toys，他们觉得时间花在实打实的 coding 上更有意义\n这种两极分化的原因一方面是个人性格“偷懒与否”，另一方面是自己平时的圈子影响，我个人是觉得用一些 roi (投入回报比) 高的工具还是很有必要的\n典型的就有：vim 编辑模式\n我自己喜欢去折腾一些工具来打造自己的工作流 —— 通过已有的熟悉的工具乃至 app 来建立一个自己平时工作或者知识积累的办公流程\n例如记知识笔记可以使用 obsidian + vim + picgo + github，包含笔记的编写、文档中图片的图床以及笔记云端存储，这是工作流的一种应用\n还有一个概念是 学习范式，这个术语最开始是在学数据库的时候认识的，后来在一些专业书籍上也频频浏览到，通俗理解就是 学习方法，作为小镇做题家的我们，从一开始就应当开始培养一套属于自己的学习范式，我理解的范式应用逻辑：学习 -&gt; 练习 -&gt; 沉淀 -&gt; 加深学习 -&gt; 继续练习 -&gt; **(循环往复\n工作和生活\n人情世故量力而行，还是多保留一些纯粹的品质吧\n附言\n世界是这样的，没有能力的时候只能先按照现有的规则活下去，然后了解清楚世界的规则之后就利用规则去积累力量，积攒到足够的力量之后就可以最低程度的受到规则的束缚，甚至能够创造新的规则\n","thumbnail":"https://cdn.jsdelivr.net/gh/jiechen257/gallery@main/img/202304281414202.jpeg","plink":"https://becase.top/resources/essays/学校-学生-学习/"},{"title":"消失的附近","date":"2021-10-11T16:00:00.000Z","date_formatted":{"ll":"Oct 12, 2021","L":"10/12/2021","MM-DD":"10-12"},"updated":"2024-03-11T03:17:20.556Z","content":"\n如今的社会，大家对自己周边的世界没有那种要浸淫进去，形成一个叙述的愿望或能力\n\n01 现状\n你在与人交谈的时候是否有一种感觉，现在人们讨论的都是一些仰望不可及的远边，或是建政圈子里的国家大事，或是某某明星的塌房事件\n这些事情的发生与否与自己毫无关联，事件结果对自己也毫无影响，但因为大家都在讨论这样的话题，自己如果什么也不知道，就像是一个局外人\n久而久之，大家的话题开始愈发的遥不可及，换句话说，他们的“附近”正在逐渐消失\n02 背后的原因\n自从互联网开始大数据杀熟之后，人们在荧幕中看到的都是一个个信息茧房中筛选出来的\n\n“时间抹杀了空间”，我们的耐心只有 3 秒，疏离和退避在我们中间深化\n\n“每个个体与另一个个体都通过那个高度抽象的系统来协调”，我们对悬浮于我们之上那个系统高度信任，但回到家，紧闭大门，我们却对身边的邻居没有丝毫的了解\n——公共领域其实在塌陷，网络让公共领域看似延展到整个地球，实际上是缩小到宅在家里——这是一种虚幻的镜像，犹如小小的胶片通过灯光投放到大屏幕上一样，可人只有在与他人的相处之中之中才能确立自己的世界。\n地理意义的“附近”已经转化为数字意义的“附近”。市场是“附近”消失的重要原因。\n选择被精心设计，最后导致了同质化的抑郁；意义被经济逻辑侵蚀，被锻造成广泛的消费样态。自由主义市场的基本观点为资源是必须自由流动的，交易是不应存在障碍的\n——资本叠加技术，对“即时性”的追求正在不断压缩“附近”的空间，但“附近”并非消失而是存在于美团、支付宝、滴滴的各种算法背后，人与人的真实的关系变成了精准计算后的各种“推送”\n即时让人对时间的变化感受更加强烈。“中间”消失了。 “附近”消失了\n03 如何应对\n感受当下，活在当下\n如果觉得抽象理解不了，那你可以读读下面的诗句\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647记得早先少年时Remember the old days大家诚诚恳恳when everyone was sincere说一句 是一句one&#x27;s word is one&#x27;s bond清早上火车站The dawn of the train station长街黑暗无行人the dark street with no sign of pedestrian卖豆浆的小店冒着热气and the steam from the soy-milk stall从前的日色变得慢The nightfalls used to come late in the past车，马，邮件都慢Everything was slow, the bike, the horse, and the post一生只够爱一个人a lifetime was all but enough to be in love with one从前的锁也好看The old-school lock was beautiful钥匙精美有样子and the key exquisite looking你锁了 人家就懂了once locked, the others understood\n","plink":"https://becase.top/resources/essays/消失的附近/"},{"title":"观望即可","date":"2019-12-19T16:00:00.000Z","date_formatted":{"ll":"Dec 20, 2019","L":"12/20/2019","MM-DD":"12-20"},"updated":"2024-03-11T03:17:20.557Z","content":"有句很俗的话，“世事万物都有两面性”。本应该从小就听过的“大道理”，长大后便愈加模糊\n前段时间，我看了几场班与班之间的辩论赛——果然，从荧幕上看还不如实地感受来的实在——看着辩论双方就一个模棱两可的话题辩论来辩论去，下面的观众笑的不亦乐乎，双方都“占山为王”的样子，着实有点可笑。同一个话题，双方只找对自己有利的理论或例子来说明（因为林子大了，什么鸟儿都有），或者站在自己的角度，去将这种理解广泛化，使观众或者评委认同，我想不到有什么实际意义（下意识打出了“杠精”二字）\n同理，相比每天看着那些媒体夸赞社会、国家哪里哪里有多么多么的好，以前的自己也想辩论会台下的观众&quot;笑一笑&quot;，现在嘛，有点愤青的样子了——你得到的信息大都是“国家”希望你看到的，即是一些经过他们美化或者丑化过的，幌子。真正吸收某个信息，得去挖掘那些被“国家”删减或者隐藏的东西\n于我个人而言，那些东西才真正有趣\n如崔永元替私人企业家申诉的千亿煤矿案，再说文革时期中国又有多少冤案是人们不得而知的，又或者那些被国家压下的丑闻。拿今年的港独事件来说，政治媒体只报道了港独分子的表现，并没有谈及其港独原因，莫不是触及了香港人民的利益？只报道港独分子的暴力，莫不是港警没有过格？再说中美贸易战，我要是美国，我早在21世纪刚开始就整中国；想要这么久的发育机会？不可能~ 特朗普就是个局外人，看东西看的很清楚，一上台就搞中国，很聪明\n\n我们不做历史的审判者，只需冷冷的观望\n\n我高中时有一段时间，试着把自己的感觉从当时的生活场景中剥离出来，那时的视角，看东西真通彻呀\n现在已经习惯性的观望了，当然只存在于我理性的时候。偶尔脑子一热，不对，经常脑子一热，胡乱瞎说乱搞，完事后反思来自己的蠢货行为，真想有再给我表现的机会，这样就可以免去不知多少麻烦了。\n\n笔者: 现在回过头看，那时候的自己是真中二且愤青…\n","plink":"https://becase.top/resources/essays/观望即可/"},{"title":"认识你自己","date":"2024-03-09T16:00:00.000Z","date_formatted":{"ll":"Mar 10, 2024","L":"03/10/2024","MM-DD":"03-10"},"updated":"2024-03-24T06:07:25.403Z","content":"\n现在是晚上十点不到一刻，在自己一个人住的租房里，刚把洗衣机里的衣服晾上阳台——爬上床，打开电脑开始写这篇文\n\n背景\n文章标题出自身边一个年入三十有所成就的人的个签，句子完整版本是——“认识你自己，认识你全部的自己”\n当时觉得废话文学，我自己还不知道自己什么样吗？可现在从事后诸葛亮的视角来看，还真是…\n面对别人给我的标签，我一向是先反驳在思考是不是，为什么养成了这样的习惯？因为脑子里潜移默化的观念——我自己清楚我是什么样子，我不需要你来定义\n可当接二连三的乌龙发生的时候，我不由得开始反思，“我就是这样的，为什么要否认自己”\n原因有二：\n\n尚不自知：我还不知道自己真正想要或者喜欢的\n顾 ta 思想\n\n尚不自知\n我明确知道自己喜欢或者想要某个东西的方式，是根据那时候心里的感觉，那种感觉十分美好——纯粹的美好\n但我又很慢热，有时候需要慢慢去接触，偶尔自己又懒，不想去接触，这真的是一种恶性闭环\n顾 ta 思想\n人的心里总会有一杆秤，当两边的砝码开始进行加码的时候，人的行为也会开始摇摆\n而我这搬深情死脑筋尤为不同，我心里的那杆秤就是 ta，所以并不存在任何东西与之相比较，因为 ta 就是天平本身\n也正是因为这样的顾 ta 思想，导致我的行为或者观念总会围绕着 ta 转，正如邯郸学步，而我学的是 ta 喜欢的步\n做出改变\n综上，我还真需要想想怎么去认识自己、认识全部的自己\n为此，我创建了一个题库——ask-yourself【扪心自问】，通过收集各种问题以及自己当下做出的回复，来形成真正的自己的答卷\n希望最终的状态是，在硬币抛起来的那一刻，我心里就已经有了想要的答案\n","plink":"https://becase.top/resources/essays/认识你自己/"},{"title":"小男孩","date":"2023-06-14T16:00:00.000Z","date_formatted":{"ll":"Jun 15, 2023","L":"06/15/2023","MM-DD":"06-15"},"updated":"2024-03-11T03:17:20.580Z","content":"眼下是一条千来层的笔直石阶，远眺望不到头，我走在下山的台阶上。\n本是冲出云层的高山，奇怪的是看不到两侧的瑰丽，路边只有原木做的扶梯。我只顾往下走着，不一会儿就看到前方蹲着一个小孩，他背对着我，带着欢快的笑声。好似发觉了我的存在，他起身也往下赶路，我不理解，便加快了我的步伐，一级台阶本需常人一步，我却两三阶地向下分段跳跃，小孩还是一阶又一阶的走着。按照这种相对速度本应该很快就能追上的，可我们的距离却诡异的保持着不变。\n这样持续了没多久我看到前方又多了两个身影，走近了才知道那是两个小女孩。那个小孩走到她们身边时便停下了脚步，转眼间我也到了。女孩当中有个扎着两个小辫子，开始跟小孩打招呼，我看着他们三莫名其妙地就聊起来了。当我走到和小孩并齐的位置，没等我插嘴她们当中的另一个女孩发觉我的到来后，转向我笑着说“你也来了呀~”我满脸疑惑，侧过头看向小孩，看着这张脸莫名的熟悉，没等我开口问，刚刚的女孩又说到，“哈哈，原来你长大后这么木讷啊”，脸是朝着小孩说的。小孩见状笑得更大声了，一边朝我伸手一边说着：“你好呀，未来~”。\n时间突然定格在了那一刻，各种回忆和思绪突然在我脑海里以幻灯片的形式自动播放，我两步并一步走的习惯是高三养成的，下山时小孩和我的距离不变的原因，是我们年龄差距的时间一直不变，两个小女孩就是我的中学和大学，下山的路是我回到过去的路。\n然后就惊醒了。\n","plink":"https://becase.top/resources/notes/theboy/"},{"title":"所谓命运","date":"2024-03-16T16:00:00.000Z","date_formatted":{"ll":"Mar 17, 2024","L":"03/17/2024","MM-DD":"03-17"},"updated":"2024-03-17T12:04:11.700Z","content":"\n\n\n你或许会在对的时间遇到错的人，你或许会在错的时间遇到对的人，\n但最终会发现一切都是对的时间对的人，没有什么错误之分\n\n所谓命运，就是一场结构庞大的连锁反应\n其中一环发生问题，就会导致全盘发生改变\n它无法被设定，无法被控制，就像生活里从来都没有如果，只有一连串相互交错的意外\n而我们能做的只有接受，并预遇见未来可能会发生的，提前做好准备，就像本杰明一样未雨绸缪\n","plink":"https://becase.top/resources/notes/所谓命运/"},{"title":"矛盾的自己","date":"2024-01-05T16:00:00.000Z","date_formatted":{"ll":"Jan 6, 2024","L":"01/06/2024","MM-DD":"01-06"},"updated":"2024-03-11T03:17:20.585Z","content":"\n\n\n\n罗天诚解剖人性：“做人，要么大俗，要么大雅；徐志摩是大雅，马德保是大俗，但他们都是快乐的人，可你却半俗不雅，内心应该十分痛苦”\n\n“我觉得你很奇怪，你一边说自己梦里遇到的未来有多美好，又说那个未来遥不可期，把问题全抛给了我”\n“你真的很奇怪诶；你都没有想过真的去面对它，没有问我可以帮什么，你就巴拉巴拉讲完了，然后一个人在那哼哧哼哧…”\n真理已经写在书里了，指路的手早已抬起，正路就在眼前，我现在需要的不是思考，是执念\n","plink":"https://becase.top/resources/notes/矛盾的自己/"},{"title":"小阳人的自我修养","date":"2022-12-14T16:00:00.000Z","date_formatted":{"ll":"Dec 15, 2022","L":"12/15/2022","MM-DD":"12-15"},"updated":"2024-03-11T03:17:20.580Z","content":"\n判断是不是：喉咙有问题、发烧、浑身发冷无力，三中二就是中招了\n退烧药一定得有，可以不是布洛芬，但得有，其他症状酌情吃药\n大量喝电解质水：普通水+柠檬+少量白糖+更少量食用盐，混匀烧开喝\n正常流程：喉咙干痒一天，发烧两到三天，咽痛两三天，期间伴随咳嗽和流鼻涕，然后缓解一两天，总共七天左右（严重的表现有吞刀片、浑身痛、失去嗅觉味觉等）\n不同时期不同症状吃不同药，有些药不能混吃（阿莫西林除非后期真的发炎，否则不要吃\n判断好没好：身体症状基本消失（可能还会有点咳嗽，但流鼻涕咽痛就不行）+两次核酸阴性\n有数据表明，过敏患者或者鼻炎患者，感染症状相对较轻（我自己就是，感觉有道理\n\n","plink":"https://becase.top/resources/notes/小阳人的自我修养/"},{"title":"打工人的自我修养","date":"2022-12-14T16:00:00.000Z","date_formatted":{"ll":"Dec 15, 2022","L":"12/15/2022","MM-DD":"12-15"},"updated":"2024-03-11T03:17:20.581Z","content":"看表，五点半，准备撤退。\n领导，发消息，六点开会。\n群里，诸同事，纷纷反馈：\n甲回：已安排，今晚约会。\n乙说：要健身，私教昂贵。\n丙曰：误演出，门票难退。\n丁问：算加班？工资双倍？\n老板，眼见着，势头不对，\n急忙，讲历史，口称兄妹：\n看我，为公司，把心操碎，\n诉说，奋斗史，你们体会。\n生产，赶进度，通宵不睡；\n商务，陪客户，喝坏肠胃。\n当年，赴全力，不怕苦累；\n如今，再回首，满含热泪。\n上班，比待遇，越比越废；\n工作，讲奉献，值得敬佩。\n尔等，年轻人，幸福一辈，\n公司，是你家，恪守岗位。\n拼搏，殚心力，务必领会；\n奋斗，尽忠守，方成精锐！\n晚生，听此言，拍案反对：\n天天，巧言语，当我几岁？\n年年，画大饼，食之无味。\n加薪，空许诺，恍如梦寐；\n实际，年终奖，不够话费。\n套话，说再多，都是点缀；\n唯有，涨工资，才得实惠。\n","plink":"https://becase.top/resources/notes/打工人的自我修养/"}]